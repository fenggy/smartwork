/*! 力控科技版权所有 */
(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./real-server/bin/www.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../daemon/config/default-config.json":
/*!********************************!*\
  !*** external "./config.json" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("./config.json");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./real-server/app.js":
/*!****************************!*\
  !*** ./real-server/app.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Service } = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
const WebSocket = __webpack_require__(/*! ws */ "ws");
const rpcNode = __webpack_require__(/*! @hprose/rpc-node */ "./real-server/node_modules/@hprose/rpc-node/lib/index.js");
const dataSource = __webpack_require__(/*! ./lib/data-source */ "./real-server/lib/data-source.js");
const communicate = __webpack_require__(/*! ./communicate */ "./real-server/communicate.js");

//提供数据接口定义
module.exports = class realServer {
    constructor(config) {
        this.config = config;
        this.run();
    }
    /*
        功能:启动函数
    */
    run() {
        
        console.log(`[REAL-SERVER ${configJson.name}] 启动服务: ${this.config.name} 端口:${this.config.usedPort}`);
        //初始化rpc
        this.service = new Service();
        this.service.bind(new WebSocket.Server({ port: this.config.usedPort }, async (err, result) => {
            this.service.websocket.compress = true;
            //真正的代理适配器
            console.log(`[REAL-SERVER ${configJson.name}] 开始创建工作模块`);
            this.agentAdapter = new dataSource(this.config);
            console.log(`[REAL-SERVER ${configJson.name}] 开始rpc服务注册`);
            this.registerRpcService();
            console.log(`[REAL-SERVER ${configJson.name}] rpc服务注册成功`);
            await this.agentAdapter.connect();
            console.log(`[REAL-SERVER ${configJson.name}] 创建工作模块成功,服务启动成功`);
            //向daemon报告登录成功
            await communicate.report(this.config.usedPort, this.config.name);
        }));
    }

    registerRpcService() {
        this.service.websocket.onaccept = this.onAccept.bind(this);
        this.service.websocket.onclose = this.onClose.bind(this);
        this.service.add({ method: this.agentAdapter.subRealData.bind(this.agentAdapter), fullname: 'subRealData', passContext: true });
        this.service.add({ method: this.agentAdapter.getRealData.bind(this.agentAdapter), fullname: 'getRealData', passContext: true });
        this.service.add({ method: this.agentAdapter.unSubRealData.bind(this.agentAdapter), fullname: 'unSubRealData', passContext: true });
        this.service.add({ method: this.agentAdapter.getTagData.bind(this.agentAdapter), fullname: 'getTagData', passContext: true });
        this.service.add({ method: this.agentAdapter.getHisData.bind(this.agentAdapter), fullname: 'getHisData', passContext: true });
        this.service.add({ method: this.agentAdapter.getAlmData.bind(this.agentAdapter), fullname: 'getAlmData', passContext: true });
        this.service.add({ method: this.agentAdapter.getTagInfo.bind(this.agentAdapter), fullname: 'getTagInfo', passContext: true });
        this.service.add({ method: this.agentAdapter.getData.bind(this.agentAdapter), fullname: 'getData', passContext: true });
        this.service.add({ method: this.agentAdapter.setData.bind(this.agentAdapter), fullname: 'setData', passContext: true });
        this.service.add({ method: this.isConnected, fullname: 'isConnected', passContext: true });
    }
    isConnected() {
        //服务管理工具调用的接口。只要此服务启动了就返回true。与数据源是否链接无关
        return true;
    }
    //新连接处理
    onAccept(ws) {
        //客户端[ip:port]作为连接的key值
        let clientKey = (ws._socket.remoteAddress + ":" + ws._socket.remotePort).slice(7)
        this.agentAdapter.addClient(clientKey);
    }
    //连接断开
    onClose(ws) {
        //客户端[ip:port]作为连接的key值
        let clientKey = (ws._socket.remoteAddress + ":" + ws._socket.remotePort).slice(7)
        this.agentAdapter.delClient(clientKey);
    }
}

/***/ }),

/***/ "./real-server/bin/www.js":
/*!********************************!*\
  !*** ./real-server/bin/www.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//daemon全局配置
global.daemonConfig = __webpack_require__(/*! ../../daemon/config/default-config.json */ "../../daemon/config/default-config.json");
//debug
global.__debug = false;
const realServer = __webpack_require__(/*! ../app.js */ "./real-server/app.js");
const communicate = __webpack_require__(/*! ../communicate */ "./real-server/communicate.js");
const net = __webpack_require__(/*! net */ "net");

//real-server自己的配置
global.configJson = {};
if (process.argv[2] && process.argv[2] === "debug") {
    configJson = __webpack_require__(/*! ../config/default-config.json */ "../../daemon/config/default-config.json");
    configJson.usedPort = process.argv[3] ? process.argv[3] : 3001;
    __debug = true;
} else {
    if (process.argv[2]) {
        var jsonStr = new Buffer.from(process.argv[2], 'base64').toString();
        try {
            configJson = JSON.parse(jsonStr);
        } catch (e) {
            console.log("错误的配置参数");
            return;
        }
    }
}

/**
 * @description 检测可用端口，并启动server
 * @param {*} config 配置
 */
async function checkPortAndStart(config) {
    try {
        //端口
        let startPort = await communicate.getPort();
        if (startPort && startPort.port) {
            let usedPort = await chkCanUsedPort(startPort.port, 0);
            //real-server使用端口
            config.usedPort = usedPort;
            console.log(`[REAL-SERVER ${configJson.name}] 当前使用端口${usedPort}`);
            //启动
            new realServer(config);
        } else {
            console.log(`[REAL-SERVER] 未找到主服务的链接端口,5秒后重试`);
            setTimeout(() => {
                checkPortAndStart(config);
            }, 5000);
        }
    } catch (error) {
        console.log(`[REAL-SERVER ${configJson.name}] ${error}`);
    }
}

/**
 * 检测可以使用的端口
 * @param {number} port 要检测的端口
 * @param {number} curChkTime 已经检测的次数，最大值是500
 */
function chkCanUsedPort(port, curChkTime) {
    let server = net.createServer().listen(port);
    return new Promise((resolve, reject) => {
        //检测次数最大值
        const MAX_CHK_TIMES = 500;
        //监听到listen事件，说明当前端口可用
        server.on("listening", () => {
            server.close();
            resolve(port);
        });
        server.on("error", error => {
            //端口占用错误，一直递归到可以使用的端口
            if (error.code === 'EADDRINUSE' && curChkTime <= MAX_CHK_TIMES) {
                resolve(chkCanUsedPort(port + 1, curChkTime + 1));
            }
            if (error.code === 'EADDRINUSE' && curChkTime > MAX_CHK_TIMES) {
                error = `已经达到最大端口检测次数`;
            }
            reject(error);
        });
    })
}

//启动realserver
checkPortAndStart(configJson);


/***/ }),

/***/ "./real-server/communicate.js":
/*!************************************!*\
  !*** ./real-server/communicate.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * 与daemon通讯的api
 */
const request = __webpack_require__(/*! request */ "request");

class Communicate {
    constructor() {
        this.ip = '127.0.0.1';
        this.port = daemonConfig.port;
        //请求路径前缀
        this.prefix = '/service';
    }

    requestGet(url, callback) {
        request.get({ url, json: true }, (err, responce, body) => {
            if (err) callback(err);
            if (responce && responce.statusCode === 200) {
                callback(null, body)
            } else {
                callback(body);
            }
        });
    }

    requestPost(url, param, callback) {
        request.post({ url, json: true, body: param }, (err, responce, body) => {
            if (err) callback(err);
            if (responce && responce.statusCode === 200) {
                callback(null, body)
            } else {
                callback(body);
            }
        })
    }

    /**
     * 获取服务要使用的初始端口
     */
    getPort() {
        return new Promise((resolve, reject) => {
            let url = `http://${this.ip}:${this.port}${this.prefix}/real`;
            this.requestPost(url, { "type": "getPort", "serverType": "realServer" }, (err, data) => {
                if (err) {
                    console.log(`[REAL-SERVER ${configJson.name}] 获取服务要使用的初始端口:${err}`);
                }
                resolve(data);
            })
        })
    }

    /**
     * 登录成功向daemon报告服务使用的端口
     * @param {*} curUsePort 当前使用的端口
     */
    async report(curUsePort, serverName) {
        return new Promise((resolve, reject) => {
            let url = `http://${this.ip}:${this.port}${this.prefix}/real`;
            this.requestPost(url, { "type": "report", curUsePort, "serverType": "realServer", serverName }, (err, data) => {
                if (err) {
                    console.log("未找到daemon服务器,若本次未启动调试启动请忽略！");
                }
                resolve(data);
            })
        })
    }
}

//单例模式
let communicate = null;
if (communicate === null) {
    communicate = new Communicate();
}
module.exports = communicate;

/***/ }),

/***/ "./real-server/lib/data-source.js":
/*!****************************************!*\
  !*** ./real-server/lib/data-source.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dataFC7 = __webpack_require__(/*! ./source/fc7 */ "./real-server/lib/source/fc7.js");
const dataEF5 = __webpack_require__(/*! ./source/ef5 */ "./real-server/lib/source/ef5.js");
const dataPS6 = __webpack_require__(/*! ./source/ps6 */ "./real-server/lib/source/ps6.js");
module.exports = function(config) {
    switch(config.type){
        case "ef5":
            return new dataEF5(config);
        break;
        case "ps6":
            return new dataPS6(config);
        break;
        case "fc7":
            return new dataFC7(config);
        break;
        default:
            throw new Error('不存在的数据源类型:' + config.type)
        break;
    }
}

/***/ }),

/***/ "./real-server/lib/source/base.js":
/*!****************************************!*\
  !*** ./real-server/lib/source/base.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const _ = __webpack_require__(/*! lodash/core */ "./real-server/node_modules/lodash/core.js");
const FRtdb = __webpack_require__(/*! fcnode */ "fcnode");
module.exports = class dataSourceBase {
    constructor(config) {
        //所有客户端连接信息
        this.webClientRegDataInfo = {};
        //全局轮询请求点列表
        this.GlobalRequestData = {
            /*    
            tagname+parName:{
                    tagName:11,
                    parName:22,
                    prevValue:{}
                    value:{}
                }
            */
        };
        this.connectCount = 0;
        this.config = config;
        //初始化fcnode
        this.db = new FRtdb(
            this.config.ip,
            this.config.port,
            {
                // dialect: this.config.sourceType,
                dialect: this.config.type,
                username: this.config.username,
                password: this.config.password
            });
    }
    addClient(clientKey) {
        //客户端不存在
        if (this.webClientRegDataInfo[clientKey] == undefined) {
            this.webClientRegDataInfo[clientKey] = {
                regData: {},
                shellRegData: {},
                changeData: [],//返回给客户端属性
                lastTime: new Date()
            }
            console.log(`[REAL-SERVER ${configJson.name}] 新增客户端连接:${clientKey}`);
        } else {
            console.log(`[REAL-SERVER ${configJson.name}] 客户端已存在:${clientKey}`);
        }
    }
    delClient(clientKey) {
        //客户端不存在
        if (!this.webClientRegDataInfo[clientKey]) {
            console.log(`[REAL-SERVER ${configJson.name}] 删除客户端失败:${clientKey}`);
        } else {
            //注销客户端所有点
            _.map(this.webClientRegDataInfo[clientKey].regData, (tag, tagName) => {
                _.map(tag, (parObj, parName) => {
                    let uniquekey = tagName + "." + parName;
                    let find = this.GlobalRequestData[uniquekey];
                    if (find) {
                        find.refCount -= parObj.refCount;
                        //引用计数为0时，删除
                        if (find.refCount == 0) {
                            delete this.GlobalRequestData[uniquekey];
                        }
                    }
                })
            })
            delete this.webClientRegDataInfo[clientKey];
            console.log(`[REAL-SERVER ${configJson.name}] 成功删除客户端:${clientKey}`);
        }

    }
    getClient(clientKey) {
        if (!this.webClientRegDataInfo[clientKey]) {
            console.log(`[REAL-SERVER ${configJson.name}] 获取客户端对象失败:${clientKey}`);
        }
        return this.webClientRegDataInfo[clientKey]
    }
    /*
        功能:注册点
        参数:clientKey:注册到的连接标示
            json : 注册的信息
            reference : 是否注册。false标示只取当前值并不注册
        返回值:注册点的当前值
    */
    async register(clientKey, json, reference) {
        //本地是否先请求一次，获取初值
        let currentRequest = [];
        //处理当前连接引用计数
        json.map((requestData) => {
            let tagInfo = this.webClientRegDataInfo[clientKey].regData[requestData.tagName];
            if (tagInfo) {
                //当前注册属性若存在+1，不存在创建
                let parObj = tagInfo[requestData.parName];
                if (parObj) {
                    if (reference) {
                        parObj.refCount += 1;
                    }
                } else {
                    tagInfo[requestData.parName] = {
                        data: {
                            value: -9999,
                            time: "",
                            quality: ""
                        },
                        refCount: 1
                    }
                }
            } else {
                //创建点对象以及属性
                this.webClientRegDataInfo[clientKey].regData[requestData.tagName] = {
                    [requestData.parName]: {
                        data: {
                            value: -9999,
                            time: "",
                            quality: ""
                        },
                        refCount: 1
                    }
                };
            }
            //当前请求点信息，是否在全局列表中存在 存在引用+1
            let uniquekey = requestData.tagName + "." + (requestData.parName || "pv");
            let find = this.GlobalRequestData[uniquekey];
            if (find) {
                if (reference) {
                    find.refCount++;
                }
            } else {
                //不存在需要加到全局列表，等待下一次统一请求
                this.GlobalRequestData[uniquekey] = {
                    tagName: requestData.tagName,
                    parName: requestData.parName,
                    extName: requestData.extName,
                    data: {},
                    refCount: 1
                };
                currentRequest.push(requestData);
            }
        });
        return currentRequest;
    }
    /*
        功能:注销点
        参数:clientKey:需要注销的连接标示
            json : 注销的信息
            reference : 是否注销。false标示只取当前值并不注销
        返回值:注册点的当前值
    */
    unRegister(clientKey, json, reference) {
        let result = {
            error: "",
            data: {}
        }
        //客户端不存在
        if (!this.webClientRegDataInfo[clientKey]) {
            console.log(`[REAL-SERVER ${configJson.name}] client not exist.clientinfo::${clientKey}`);
            result.error = "client not exist";
            return result;
        }
        //处理当前连接引用计数
        json.map((requestData) => {
            let tagInfo = this.webClientRegDataInfo[clientKey].regData[requestData.tagName];
            if (tagInfo) {
                //当前注销属性若存在 计数-1，计数为0 删除属性
                let parObj = tagInfo[requestData.parName];
                if (parObj) {
                    if (reference) {
                        parObj.refCount -= 1;
                    }
                    //计数为0时，删除属性
                    if (parObj.refCount == 0) delete tagInfo[requestData.parName];
                } else {
                    var error = "error:tag prop not exist in client when unSubRealData.clientInfo:";
                    error += clientKey;
                    error += " taginfo: ";
                    error += requestData;
                    console.log(`[REAL-SERVER ${configJson.name}] ${error}`);
                }
                //点所有属性计数为0时，删除点
                if (_.isEmpty(tagInfo)) {
                    delete this.webClientRegDataInfo[clientKey].regData[requestData.tagName];
                }
            } else {
                var error = "error:tag not exist in client when unSubRealData.clientInfo:";
                error += clientKey;
                error += " taginfo: ";
                error += requestData;
                console.log(`[REAL-SERVER ${configJson.name}] ${error}`);
            }
            //当前请求点信息，是否在全局列表中存在 存在引用-1
            let uniquekey = requestData.tagName + "." + (requestData.parName || "pv");
            let find = this.GlobalRequestData[uniquekey];
            if (find) {
                if (reference) {
                    find.refCount--;
                }
                //引用计数为0时，删除
                if (find.refCount == 0) {
                    delete this.GlobalRequestData[uniquekey];
                }
            } else {
                var error = "error:tag not exist in global when unSubRealData.clientInfo:";
                error += clientKey;
                error += " taginfo: ";
                error += requestData;
                console.log(`[REAL-SERVER ${configJson.name}] ${error}`);
            }
        });
        return result;
    }
    /*
        功能:初始化数据源连接
        参数:无
        返回值:无
    */
    async connect(isReConnect = false) {
        //连接实时库
        if (isReConnect) {
            console.log(`[REAL-SERVER ${configJson.name}] 数据源第 ${this.connectCount} 次重新连接`);
        }
        let ret = await this.db.login();
        if (ret) {
            this.connectCount = 0;
            //连接成功,周期请求实时数据
            setTimeout(this.pollRequest.bind(this), 1000);
            setTimeout(this.managerCache.bind(this),3600000);
            await this.loadAllTags();
        } else {
            //重新连接
            this.connectCount++;
            setTimeout(() => {
                this.connect(true);
            }, 30000);
            console.log(`[REAL-SERVER ${configJson.name}] 实时库:${this.config.ip} 类型: ${this.config.type} 状态: 等待重新连接`);
        }
    }

    /*
        功能:加载数据库点表
        参数:无
        返回值:无
    */
    async loadAllTags() {

    }
    /*
        功能:获取所有应请求点
        参数:连接名称
        返回值:所有应请求点
    */
    getTags(clientKey) {
        if (typeof clientKey == "string" && clientKey !== "") {
            return this.webClientRegDataInfo[clientKey];
        }
    }
    /*
        功能:缓存变化点信息
        参数:responeData请求实时结果
            requestData请求信息
        返回值:无
    */
    cacheData(responeData, requestData) {
        responeData.map((data, index) => {
            if(requestData[index].globalRef){
                requestData[index].globalRef.data = data;
            }else{
                for (let key in this.webClientRegDataInfo) {
                    let client = this.webClientRegDataInfo[key];
                    for (let tagName in client.shellRegData){
                        if(tagName == data.tagName){
                            client.shellRegData[tagName].value = responeData;
                        }
                        
                    }
                }
            }
        });
        //将值更新到各个客户端中
        for (let key in this.webClientRegDataInfo) {
            //单个客户端
            const client = this.webClientRegDataInfo[key];
            //regData 每个客户端存的点名josn
            for (let tagName in client.regData) {
                //每个点下保存所有属性名称
                for (let parName in client.regData[tagName]) {
                    //从全局中获取最新值
                    let latestData = this.GlobalRequestData[tagName + "." + parName];
                    //暂时看值，时间戳 质量戳未考虑
                    if (client.regData[tagName][parName].data.value != latestData.data.value) {
                        client.regData[tagName][parName].data.value = latestData.data.value;
                        client.regData[tagName][parName].data.time = latestData.data.time;
                        client.regData[tagName][parName].data.quality = latestData.data.quality;
                        if (client.changeData.length > 16) {
                            client.changeData.shift();
                        }
                        //值不相等，更新，并且保存到更新礼拜中
                        client.changeData.push({
                            extName: latestData.extName,
                            parName: parName,
                            data: latestData.data
                        });
                    }
                }
            }

            

        }

    }
    /*
        功能:准备实时数据请求,缓存一次数据,根据reference决定是否注册点
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
            reference:是否注册
        返回值:未注册点的第一次缓存值
    */
    async prepareRealData(json, token, context, reference = true) {
        let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7);
        let currentRequest = await this.register(clientKey, json, reference);
        //请求回来数据刷新到全局列表中
        if (currentRequest.length > 0) {
            //加到本地列表，先请求一次
            let requestList = [];
            for (let i = 0; i < currentRequest.length; i++) {
                let requestData = currentRequest[i];
                let uniquekey = requestData.tagName + "." + (requestData.parName || "pv");
                requestList.push({
                    tagName: requestData.tagName,
                    parId: this.ModeProperty[requestData.parName].id || 13,
                    globalRef: this.GlobalRequestData[uniquekey]
                });
            }
            let responeData = await this.db.getData(requestList);
            if (this.isError(responeData.retCode)) {
                if (responeData.retCode == -19997) {
                    //当前fcNode无法返回 -19997 错误
                    console.log(`[REAL-SERVER ${configJson.name}] 部分错误`);
                    return [];
                } else if (responeData.data) {
                    responeData.data.map((data, index) => {
                        requestList[index].globalRef.data = data;
                    });
                } else {
                    console.log(`[REAL-SERVER ${configJson.name}] ${responeData.retCode}`);
                    return [];
                }
            } else {
                this.isReConnect(responeData.retCode);
            }
        }
        //再从全局列表中，把当前变量筛选回来
        let resultData = json.map((requestData) => {
            let uniquekey = requestData.tagName + "." + (requestData.parName || "pv");

            return {
                parName: requestData.parName,
                extName: this.GlobalRequestData[uniquekey].extName,
                data: this.GlobalRequestData[uniquekey].data
            };
        });
        return resultData;
    }
    /*
        功能:注销点（可视为注销点函数对外提供的函数别名）
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
            reference:是否注销
        返回值:无
    */
    async unprepareRealData(json, token, context, reference = true) {
        let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7)
        this.unRegister(clientKey, json, reference);
    }
    /*
        功能:获取当前连接的变化实时值
        参数:
        token:暂未使用
        context:连接信息
        返回值:
    */
    getRealData(token, context) {
        let responeData = [];
        let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7);
        let tags = this.getTags(clientKey);
        if (tags) {
            if (tags.changeData.length > 0) {
                //克隆返回
                responeData = _.clone(tags.changeData);
                //请求一次后清空
                tags.changeData = [];
            }
        }
        return responeData;
    }
    /*
        功能:暂未实现
        参数:   name:点名称
                token:暂未使用
                context:连接信息
        返回值:暂未确定
    */
    //轮询查点值
    getTagData(name, token, context) {
        let tmp = [];
        return tmp;
    }
    /*
        功能:注册点
        参数:   json:点名称
                token:暂未使用
                context:连接信息
        返回值:
    */
    async subRealData(json, token, context) {
        return await this.prepareRealData(json, token, context);
    }
    /*
        功能:注销点
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:
    */
    async unSubRealData(json, token, context) {
        return await this.unprepareRealData(json, token, context);
    }
    /*
        功能:获取历史数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:历史数据
    */
    async getHisData(json, token, context) {
        console.warn("子类必须完成此 getHisData 接口");
    }
    /*
        功能:获取报警数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:报警数据
    */
    async getAlmData(json, token, context) {
        console.warn("子类必须完成此 getAlmData 接口");
    }
    /*
        功能:获取点信息
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:点信息
    */
    async getTagInfo(json, token, context) {
        return this.tagTree;
    }
    /*
        功能:获取实时数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:此链接的变化实时值
    */
    async getData(arrJson, token, context) {
        console.warn("子类必须完成此 getData 接口");
    }
    /*
        功能:数据下置
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:
    */
    async setData(json, token, context) {
        console.warn("子类必须完成此 setData 接口");
    }
    /*
        功能:周期从数据源查询数据
        参数:无
        返回值:无
    */
    async pollRequest() {
        //构造请求结构
        let requestData = [];
        for (let key in this.GlobalRequestData) {
            const requestInfo = this.GlobalRequestData[key];
            requestData.push({
                tagName: requestInfo.tagName,
                parId: this.ModeProperty[requestInfo.parName].id || 13,
                globalRef: requestInfo
            })
        }
        for (let client in this.webClientRegDataInfo) {
            for (let cacheKey in this.webClientRegDataInfo[client].shellRegData) {
                let shellRegDataInfo = this.webClientRegDataInfo[client].shellRegData[cacheKey];
                requestData.push({
                    tagName: cacheKey,
                    parId: shellRegDataInfo.parId || 13
                });
            }
        }
        if (requestData.length > 0) {
            //向服务端请求            
            let responeData = await this.db.getData(requestData);
            if (this.isError(responeData.retCode)) {
                if (responeData.retCode == -19997) {
                    //当前fcNode无法返回 -19997 错误
                    console.log(`[REAL-SERVER ${configJson.name}] 部分错误`);
                    return [];
                } else if (responeData.data) {
                    this.cacheData(responeData.data, requestData);
                } else {
                    console.log(`[REAL-SERVER ${configJson.name}] ${responeData.retCode}`);
                    return [];
                }
            } else {
                this.isReConnect(responeData.retCode);
            }
        }
        setTimeout(this.pollRequest.bind(this), 1000);
    }

    managerCache(){
        for (let key in this.webClientRegDataInfo) {
            let client = this.webClientRegDataInfo[key];
            for (let tagName in client.shellRegData){
                if(new Date().getTime() - client.shellRegData[tagName].liveTime > 24 * 60 * 60 * 1000){
                    delete client.shellRegData[tagName];
                }
            }
        }
        setTimeout(this.managerCache.bind(this),3600000);
    }

    isReConnect(retCode) {
        if (retCode == -19795 //连接失败
            || retCode == -19791 //没有连接
            || retCode == -19998 //参数错误
            || retCode == -19788 /*pSpace重启，需要冲洗连接*/
            || retCode == -19799) {
            console.log("错误: " + retCode + "重新连接");
            this.connect(true);
        } else {
            console.log("错误: " + retCode);
        }
    }

    isError(retCode) {
        if (typeof retCode == "number") {
            if (retCode == 0 || retCode == -19997) {
                return true;
            } else {
                return false;
            }
        }
        return false;
    }
}

/***/ }),

/***/ "./real-server/lib/source/ef5.js":
/*!***************************************!*\
  !*** ./real-server/lib/source/ef5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dataSourceBase = __webpack_require__(/*! ./base */ "./real-server/lib/source/base.js");
const _ = __webpack_require__(/*! lodash/core */ "./real-server/node_modules/lodash/core.js");
//数据操作请求
module.exports = class agentAdapter extends dataSourceBase {
    constructor(config) {
        super(config);
        this.connectCount = 0;
        this.tagTree = {};
    }
    /*
        功能:加载数据库点表
        参数:无
        返回值:无
    */
    async loadAllTags() {

    }
    /*
        功能:获取历史数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:历史数据
    */
    async getHisData(json, token, context) {
        return await this.db.getHisData(json);
    }
    /*
        功能:获取报警数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:报警数据
    */
    async getAlmData(json, token, context) {
        let layInfo = this.db.getLayer();
        let layIds = [];
        if (layInfo && layInfo.data) {
            layInfo.data.map((lay) => {
                layIds.push(parseInt(lay.layerId));
            });
        }
        return await this.db.getAlarmByArea(layIds);
    }
    /*
        功能:获取实时数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:此链接的变化实时值
    */
    async getData(arrJson, token, context) {
        let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7);
        let regNameData = this.webClientRegDataInfo[clientKey].shellRegData;
        let requestList = [];
        //在缓存中的数据点
        let cacheResponeData = [];
        arrJson.map((tag) => {
            //在数据点缓存中存在
            if (regNameData[tag.tagName]) {
                regNameData[tag.tagName].liveTime = new Date().getTime();
                cacheResponeData.push(regNameData[tag.tagName].value);
            } else {
                requestList.push({
                    tagName: tag.tagName,
                    parId: this.ModeProperty[tag.parName].id || 13
                });
                regNameData[tag.tagName] = {
                    liveTime: new Date().getTime(),
                    parId: this.ModeProperty[tag.parName].id || 13,
                    value: null
                };
            }
        })
        if (requestList.length === 0) return cacheResponeData;
        let responeData = await this.db.getData(requestList);
        if (this.isError(responeData.retCode)) {
            if (responeData.retCode == -19997) {
                //当前fcNode无法返回 -19997 错误
                console.log("部分错误");
                return [];
            } else if (responeData.data) {
                for (let i = 0; i < responeData.data.length; i++) {
                    regNameData[responeData.data[i].tagName].value = responeData.data[i];
                }
                return [...responeData.data, ...cacheResponeData];
            } else {
                console.log(responeData.retCode, { type: "error" });
                return [];
            }
        } else {
            this.isReConnect(responeData.retCode);
        }
    }
    /*
        功能:数据下置
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:
    */
    async setData(json, token, context) {
        return await this.db.setData(json);
    }
}

/***/ }),

/***/ "./real-server/lib/source/fc7.js":
/*!***************************************!*\
  !*** ./real-server/lib/source/fc7.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dataSourceBase = __webpack_require__(/*! ./base */ "./real-server/lib/source/base.js");
const _ = __webpack_require__(/*! lodash/core */ "./real-server/node_modules/lodash/core.js");
//数据操作请求
module.exports = class agentAdapter extends dataSourceBase {
    constructor(config) {
        super(config);
        this.connectCount = 0;
        this.config = config;
        //支持的模型属性
        this.ModeProperty = {
            name: {
                id: 1
            },
            pv: {
                id: 13
            },
            desc: {
                id: 12
            }
        }
        this.tagTree = {};
    }
    /*
        功能:加载数据库点表
        参数:无
        返回值:无
    */
    async loadAllTags() {
        let tagInfos = this.db.getTagInfoEx(-1);
        //拼接所有点id，以及desc参数信息，获取点描述
        let tagIds = [];
        tagInfos.data.map((tag) => {
            tagIds.push({
                tagId: tag.tagId
            });
        });
        //获取点描述
        let tagDescs = await this.db.getData(tagIds);
        this.tagTree = {};
        if (tagDescs.data.length == tagInfos.data.length) {
            tagInfos.data.map((tag, tagIndex) => {
                let index = tag.tagName.indexOf("\\");
                if (index <= 0) {
                    //根节点下测点,直接注册
                    this.tagTree[tag.tagName] = {
                        name: tag.tagName,
                        desc: tagDescs.data[tagIndex].value,
                        longName: tag.tagName,
                        id: tag.tagId,
                        pv: {
                            value: 0,
                            time: 0,
                            quality: 0,
                        }
                    }
                } else {
                    let layInfos = tag.tagName.split("\\");
                    let root = this.tagTree;
                    //最后一级是点名
                    for (let i = 0; i < layInfos.length - 1; i++) {
                        const layName = layInfos[i];
                        if (!root[layName]) {
                            root[layName] = {};
                        }
                        root = root[layName];
                    }
                    //挂接点名
                    root[layInfos[layInfos.length - 1]] = {
                        name: layInfos[layInfos.length - 1],
                        desc: tagDescs.data[tagIndex].value,
                        longName: tag.tagName,
                        id: tag.tagId,
                        pv: {
                            value: 0,
                            time: 0,
                            quality: 0,
                        }
                    };
                }
            });
            console.log("实时库: " + this.config.ip + "  类型: " + this.config.type + " 连接成功，测点加载成功", { type: "start" });
        } else {

        }
    }
    /*
        功能:获取历史数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:历史数据
    */
    async getHisData(json, token, context) {
        return await this.db.getHisData(json);
    }
    /*
        功能:获取报警数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:报警数据
    */
    async getAlmData(json, token, context) {
        let layInfo = this.db.getLayer();
        let layIds = [];
        if (layInfo && layInfo.data) {
            layInfo.data.map((lay) => {
                layIds.push(parseInt(lay.layerId));
            });
        }
        return await this.db.getAlarmByArea(layIds);
    }
    /*
        功能:获取实时数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:此链接的变化实时值
    */
    async getData(arrJson, token, context) {
        let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7);
        let regNameData = this.webClientRegDataInfo[clientKey].shellRegData;
        let requestList = [];
        //在缓存中的数据点
        let cacheResponeData = [];
        arrJson.map((tag) => {
            //在数据点缓存中存在
            if (regNameData[tag.tagName]) {
                regNameData[tag.tagName].liveTime = new Date().getTime();
                cacheResponeData.push(regNameData[tag.tagName].value);
            } else {
                requestList.push({
                    tagName: tag.tagName,
                    parId: this.ModeProperty[tag.parName].id || 13
                });
                regNameData[tag.tagName] = {
                    liveTime: new Date().getTime(),
                    parId: this.ModeProperty[tag.parName].id || 13,
                    value: null
                };
            }
        })
        if (requestList.length === 0) return cacheResponeData;
        let responeData = await this.db.getData(requestList);
        if (this.isError(responeData.retCode)) {
            if (responeData.retCode == -19997) {
                //当前fcNode无法返回 -19997 错误
                console.log("部分错误");
                return [];
            } else if (responeData.data) {
                for (let i = 0; i < responeData.data.length; i++) {
                    regNameData[responeData.data[i].tagName].value = responeData.data[i];
                }
                return [...responeData.data, ...cacheResponeData];
            } else {
                console.log(responeData.retCode, { type: "error" });
                return [];
            }
        } else {
            this.isReConnect(responeData.retCode);
        }
    }
    /*
        功能:数据下置
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:
    */
    async setData(json, token, context) {
        return await this.db.setData(json);
    }
    /*
        功能:周期从数据源查询数据
        参数:无
        返回值:无
    */
    async pollRequest() {
        //构造请求结构
        let requestData = [];
        for (let key in this.GlobalRequestData) {
            const requestInfo = this.GlobalRequestData[key];
            requestData.push({
                tagName: requestInfo.tagName,
                parId: this.ModeProperty[requestInfo.parName].id || 13,
                globalRef: requestInfo
            })
        }
        if (requestData.length > 0) {
            //向服务端请求            
            let responeData = await this.db.getData(requestData);
            if (responeData && this.isError(responeData.retCode)) {
                if (responeData.retCode == -19997) {
                    //当前fcNode无法返回 -19997 错误
                    console.log("部分错误");
                    return [];
                } else if (responeData.data) {
                    this.cacheData(responeData.data, requestData);
                } else {
                    console.log(responeData.retCode, { type: "error" });
                    return [];
                }
            } else if (responeData) {
                this.isReConnect(responeData.retCode);
            }
        }
        setTimeout(this.pollRequest.bind(this), 1000);
    }
}


/***/ }),

/***/ "./real-server/lib/source/ps6.js":
/*!***************************************!*\
  !*** ./real-server/lib/source/ps6.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dataSourceBase = __webpack_require__(/*! ./base */ "./real-server/lib/source/base.js");
const _ = __webpack_require__(/*! lodash/core */ "./real-server/node_modules/lodash/core.js");
//数据操作请求
module.exports = class agentAdapter extends dataSourceBase {
	constructor(config) {
		super(config);
		//支持的模型属性
		this.ModeProperty = {
			name: {
				id: 1
			},
			pv: {
				id: 13
			},
			desc: {
				id: 12
			}
		}

		this.propIds = [0, 1, 2, 3, 5, 7, 11, 37, 39, 40];
		this.tagTree = {};
		this.nodeIdToTags = {};
	}
    /*
        功能:加载数据库点表
        参数:无
        返回值:无
    */
	async loadAllTags() {
		let result = await this.db.getTagQueryIds({
			'tagId': 0,
			'queryLevel': 0
		});
		if (this.isError(result.retCode)) {
			let tags = await this.db.getTagListProps({
				'tagIds': result.ids,
				'propIds': this.propIds
			})
			if (this.isError(tags.retCode)) {
				this.createTagTree(tags);
				console.log("实时库: " + this.config.ip + "  类型: " + this.config.type + "  状态: 已登录,测点加载成功", { type: "start" });
			}
		}
	}
    /*
        功能:构造点树结构
        参数:所有点及节点数组
        返回值:无
    */
	createTagTree(tags) {
		this.tagTree = {};
		if (tags.tagPropList) {
			//循环所有点数组。返回的为所有点和节点的一维数组。构造为已点id为树形名称的树形结构。
			for (let i = 0; i < tags.tagPropList.length; i++) {
				let once = tags.tagPropList[i];
				//once数组的下标由 this.propIds 请求的顺序和内容决定 
				if (once[6].data == 1) {
					if (this.nodeIdToTags[once[0].data]) {
						this.nodeIdToTags[once[0].data].name = once[2].data;
						this.nodeIdToTags[once[0].data].id = once[0].data;
						this.nodeIdToTags[once[0].data].type = once[1].data;
						this.nodeIdToTags[once[0].data].desc = once[4].data;
						this.nodeIdToTags[once[0].data].longName = once[3].data;
						this.nodeIdToTags[once[0].data].parentId = once[5].data;
					} else {
						this.nodeIdToTags[once[0].data] = {
							name: once[2].data,
							id: once[0].data,
							type: once[1].data,
							desc: once[4].data,
							longName: once[3].data,
							parentId: once[5].data,
							children: {}
						}
					}
				} else {
					if (this.nodeIdToTags[once[5].data]) {
						this.nodeIdToTags[once[5].data].children[once[2].data] = {
							name: once[2].data,
							id: once[0].data,
							type: once[1].data,
							desc: once[4].data,
							longName: once[3].data,
							parentId: once[5].data,
							alarmState: false,
							pv: {
								value: once[7].data,
								time: once[8].data,
								quality: once[9].data
							}
						};
					} else {
						if (once[5].data == 0) {
							this.nodeIdToTags[once[5].data] = {
								parentId: 0,
								children: {}
							}
						} else {
							this.nodeIdToTags[once[5].data] = {
								children: {}
							}
						}

						this.nodeIdToTags[once[5].data].children[once[2].data] = {
							name: once[2].data,
							id: once[0].data,
							type: once[1].data,
							desc: once[4].data,
							longName: once[3].data,
							parentId: once[5].data,
							alarmState: false,
							pv: {
								value: once[7].data,
								time: once[8].data,
								quality: once[9].data
							}
						}
					}
				}
			}
		}
		//由点id为树形名称的树结构构造为已点名称为树形名称的树结构
		//之所以不在上一步使用点名称构造树时应为不同节点下的点名称可以重名
		for (let p in this.nodeIdToTags) {
			//p == "0" 标示跟节点下的点。需要特殊处理
			if (p == "0" && this.nodeIdToTags[p].parentId == 0) {
				for (let p1 in this.nodeIdToTags[p].children) {
					var tempOne = this.nodeIdToTags[p].children[p1];
					this.tagTree[tempOne.name] = tempOne;
				}
			} else if (this.nodeIdToTags[p].parentId == 0) {
				this.tagTree[this.nodeIdToTags[p].name] = {
					desc: this.nodeIdToTags[p].desc,
					id: this.nodeIdToTags[p].id
				};
				for (let p1 in this.nodeIdToTags[p].children) {
					var tempOne = this.nodeIdToTags[p].children[p1];
					this.tagTree[this.nodeIdToTags[p].name][tempOne.name] = tempOne;
				}
			} else {
				var nameNodes = this.nodeIdToTags[p].longName.split("\\");
				var temp = this.tagTree;
				for (let j = 1; j < nameNodes.length - 1; j++) {
					if (temp[nameNodes[j]] == undefined) {
						temp[nameNodes[j]] = {
							desc: "",
							id: -1
						}
					}
					temp = temp[nameNodes[j]];
				}
				temp[this.nodeIdToTags[p].name] = {
					desc: this.nodeIdToTags[p].desc,
					id: this.nodeIdToTags[p].id
				}

				for (let p1 in this.nodeIdToTags[p].children) {
					var tempOne = this.nodeIdToTags[p].children[p1];
					temp[this.nodeIdToTags[p].name][tempOne.name] = tempOne;
				}
			}
		}
	}
    /*
        功能:获取历史数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:历史数据
    */
	async getHisData(json, token, context) {
		return await this.db.getHisData(json);
	}
    /*
        功能:获取报警数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:报警数据
    */
	async getAlmData(json, token, context) {
		let layInfo = await this.db.getLayer();
		let layIds = [];
		if (layInfo.length > 0) {
			layInfo.map((lay) => {
				layIds.push(parseInt(lay.layerId));
			});
		}
		return this.db.getAlarmByArea(layIds);

	}

    /*
        功能:获取实时数据
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:此链接的变化实时值
    */
	async getData(arrJson, token, context) {
		let clientKey = (context.remoteAddress.address + ":" + context.remoteAddress.port).slice(7);
		let regNameData = this.webClientRegDataInfo[clientKey].shellRegData;
		let requestList = [];
		//在缓存中的数据点
		let cacheResponeData = [];
		arrJson.map((tag) => {
			//在数据点缓存中存在
			if (regNameData[tag.tagName]) {
				regNameData[tag.tagName].liveTime = new Date().getTime();
				cacheResponeData.push(regNameData[tag.tagName].value);
			} else {
				requestList.push({
					tagName: tag.tagName,
					parId: this.ModeProperty[tag.parName].id || 13
				});
				regNameData[tag.tagName] = {
					liveTime: new Date().getTime(),
					parId: this.ModeProperty[tag.parName].id || 13,
					value: null
				};
			}
		})
		if (requestList.length === 0) return cacheResponeData;
		let responeData = await this.db.getData(requestList);
		if (this.isError(responeData.retCode)) {
			if (responeData.retCode == -19997) {
				//当前fcNode无法返回 -19997 错误
				console.log("部分错误");
				return [];
			} else if (responeData.data) {
				for (let i = 0; i < responeData.data.length; i++) {
					regNameData[responeData.data[i].tagName].value = responeData.data[i];
				}
				return [...responeData.data, ...cacheResponeData];
			} else {
				console.log(responeData.retCode, { type: "error" });
				return [];
			}
		} else {
			this.isReConnect(responeData.retCode);
		}
	}
    /*
        功能:数据下置
        参数:json:请求信息。
            token:暂未起效。
            context:连接信息。
        返回值:
    */
	async setData(json, token, context) {
		return await this.db.setData(json);
	}
}

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/ByteStream.js":
/*!***************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/ByteStream.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ByteStream.ts                                            |
|                                                          |
| hprose ByteStream for TypeScript.                        |
|                                                          |
| LastModified: Jan 15, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var EMPTY_BYTES = new Uint8Array(0);
var INIT_SIZE = 1024;
function writeInt32BE(bytes, offset, value) {
    bytes[offset++] = value >>> 24 & 0xFF;
    bytes[offset++] = value >>> 16 & 0xFF;
    bytes[offset++] = value >>> 8 & 0xFF;
    bytes[offset++] = value & 0xFF;
    return offset;
}
exports.writeInt32BE = writeInt32BE;
function writeInt32LE(bytes, offset, value) {
    bytes[offset++] = value & 0xFF;
    bytes[offset++] = value >>> 8 & 0xFF;
    bytes[offset++] = value >>> 16 & 0xFF;
    bytes[offset++] = value >>> 24 & 0xFF;
    return offset;
}
exports.writeInt32LE = writeInt32LE;
function pow2roundup(value) {
    --value;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    return value + 1;
}
var arrayLikeObjectArgumentsEnabled = true;
try {
    fromCharCode(new Uint8Array([1, 2]));
}
catch (e) {
    arrayLikeObjectArgumentsEnabled = false;
}
function toArray(arraylike) {
    var n = arraylike.length;
    var array = new Array(n);
    for (var i = 0; i < n; ++i) {
        array[i] = arraylike[i];
    }
    return array;
}
function fromCharCode(charCodes) {
    if (arrayLikeObjectArgumentsEnabled) {
        return String.fromCharCode.apply(String, charCodes);
    }
    return String.fromCharCode.apply(String, toArray(charCodes));
}
function readString(bytes, charLength) {
    if (charLength < 0)
        charLength = bytes.length;
    if (charLength === 0)
        return ['', 0];
    var charOffset = 0;
    var byteOffset = 0;
    var n = (charLength < 0x7FFF) ? charLength : 0x7FFF;
    var charCodes = new Uint16Array(n + 1);
    var byteLength = bytes.length;
    var buf = [];
    do {
        for (; charOffset < n && byteOffset < byteLength; charOffset++) {
            var unit = bytes[byteOffset++];
            switch (unit >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    charCodes[charOffset] = unit;
                    break;
                case 12:
                case 13:
                    if (byteOffset < byteLength) {
                        charCodes[charOffset] = ((unit & 0x1F) << 6)
                            | (bytes[byteOffset++] & 0x3F);
                        break;
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                case 14:
                    if (byteOffset + 1 < byteLength) {
                        charCodes[charOffset] = ((unit & 0x0F) << 12)
                            | ((bytes[byteOffset++] & 0x3F) << 6)
                            | (bytes[byteOffset++] & 0x3F);
                        break;
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                case 15:
                    if (byteOffset + 2 < byteLength) {
                        var rune = (((unit & 0x07) << 18)
                            | ((bytes[byteOffset++] & 0x3F) << 12)
                            | ((bytes[byteOffset++] & 0x3F) << 6)
                            | (bytes[byteOffset++] & 0x3F)) - 0x10000;
                        if (0 <= rune && rune <= 0xFFFFF) {
                            charCodes[charOffset++] = (((rune >> 10) & 0x03FF) | 0xD800);
                            charCodes[charOffset] = ((rune & 0x03FF) | 0xDC00);
                            break;
                        }
                        throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                default:
                    throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));
            }
        }
        buf.push(fromCharCode(charCodes.subarray(0, charOffset)));
        charLength -= charOffset;
        charOffset = 0;
        if (n > charLength)
            n = charLength;
    } while (charOffset < charLength && byteOffset < byteLength);
    return [buf.length === 1 ? buf[0] : buf.join(''), byteOffset];
}
function fromUint8Array(bytes) {
    return readString(bytes, bytes.length)[0];
}
exports.fromUint8Array = fromUint8Array;
function toBinaryString(bytes) {
    var data = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
    var n = data.length;
    if (n === 0)
        return '';
    if (n < 0xFFFF)
        return fromCharCode(data);
    var remain = n & 0x7FFF;
    var count = n >> 15;
    var buf = new Array(remain ? count + 1 : count);
    for (var i = 0; i < count; ++i)
        buf[i] = fromCharCode(data.subarray(i << 15, (i + 1) << 15));
    if (remain)
        buf[count] = fromCharCode(data.subarray(count << 15, n));
    return buf.join('');
}
exports.toBinaryString = toBinaryString;
var ByteStream = /** @class */ (function () {
    function ByteStream(value) {
        this.buffer = EMPTY_BYTES;
        this.size = 0;
        this.offset = 0;
        this.rmark = 0;
        this.wmark = 0;
        if (value) {
            if (typeof value === 'number') {
                this.buffer = new Uint8Array(value);
            }
            else if (typeof value === 'string') {
                this.writeString(value);
            }
            else {
                if (value instanceof ByteStream) {
                    this.buffer = value.toBytes();
                }
                else if (value instanceof Uint8Array) {
                    this.buffer = value;
                }
                else if (value instanceof Uint8ClampedArray) {
                    this.buffer = new Uint8Array(value.buffer, value.byteOffset, value.length);
                }
                else {
                    this.buffer = new Uint8Array(value);
                }
                this.size = value.length;
            }
            this.mark();
        }
    }
    /**
     * Decodes data to a string according to the Type.
     * @param data to be decoded to a string.
     */
    ByteStream.toString = function (data) {
        if (data === undefined)
            return Object.toString.apply(ByteStream);
        if (typeof data === 'string')
            return data;
        if (data instanceof ByteStream)
            return data.toString();
        if (data instanceof Uint8Array)
            return fromUint8Array(data);
        if (data instanceof ArrayBuffer)
            return fromUint8Array(new Uint8Array(data, 0));
        return fromCharCode(data);
    };
    ByteStream.prototype.grow = function (n) {
        var capacity = this.capacity;
        n = this.size + n;
        if (n > capacity) {
            if (capacity > 0) {
                var buf = new Uint8Array(pow2roundup(n));
                buf.set(this.buffer);
                this.buffer = buf;
            }
            else {
                this.buffer = new Uint8Array(Math.max(pow2roundup(n), INIT_SIZE));
            }
        }
    };
    Object.defineProperty(ByteStream.prototype, "capacity", {
        /**
         * Returns the current capacity of this stream.
         */
        get: function () {
            return this.buffer.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ByteStream.prototype, "length", {
        /**
         * Returns the current length of the data in this stream.
         */
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ByteStream.prototype, "position", {
        /**
         * Returns the position of the next reading operation in this stream.
         */
        get: function () {
            return this.offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ByteStream.prototype, "bytes", {
        /**
         * Returns all bytes data in this stream.
         * If the returned data is changed, the data in this stream will be also changed.
         */
        get: function () {
            return this.buffer.subarray(0, this.size);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ByteStream.prototype, "remains", {
        /**
         * Returns all bytes data in this stream that has not been read.
         * If the returned data is changed, the data in this stream will be also changed.
         */
        get: function () {
            return this.buffer.subarray(this.offset, this.size);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets this stream's mark at its reading and writing position.
     */
    ByteStream.prototype.mark = function () {
        this.wmark = this.size;
        this.rmark = this.offset;
    };
    /**
     * Resets this stream's reading and writing position to the previously-marked position.
     * Invoking this method neither changes nor discards the mark's value.
     */
    ByteStream.prototype.reset = function () {
        this.size = this.wmark;
        this.offset = this.rmark;
    };
    /**
     * Clears this stream.
     * The position is set to zero, the limit is set to the capacity, and the mark is discarded.
     */
    ByteStream.prototype.clear = function () {
        this.buffer = EMPTY_BYTES;
        this.size = 0;
        this.offset = 0;
        this.wmark = 0;
        this.rmark = 0;
    };
    /**
     * Writes a byte to the stream as a 1-byte value.
     * @param byte a byte value to be written.
     */
    ByteStream.prototype.writeByte = function (byte) {
        this.grow(1);
        this.buffer[this.size++] = byte;
    };
    /**
     * Writes value to this stream with big endian format.
     * @param value number to be written to this stream. value should be a valid signed 32-bit integer.
     * TypeError will be throwed when value is anything other than a signed 32-bit integer.
     */
    ByteStream.prototype.writeInt32BE = function (value) {
        if (value !== (value | 0)) {
            throw new TypeError('value is out of bounds');
        }
        this.grow(4);
        this.size = writeInt32BE(this.buffer, this.size, value);
    };
    /**
     * Writes value to this stream with big endian format.
     * @param value number to be written to this stream. value should be a valid unsigned 32-bit integer.
     * TypeError will be throwed when value is anything other than an unsigned 32-bit integer.
     */
    ByteStream.prototype.writeUInt32BE = function (value) {
        if (value < 0 || value !== (value | 0) && (value & 0x7FFFFFFF) + 0x80000000 !== value) {
            throw new TypeError('value is out of bounds');
        }
        this.grow(4);
        this.size = writeInt32BE(this.buffer, this.size, value | 0);
    };
    /**
     * Writes value to this stream with little endian format.
     * @param value number to be written to this stream. value should be a valid signed 32-bit integer.
     * TypeError will be throwed when value is anything other than a signed 32-bit integer.
     */
    ByteStream.prototype.writeInt32LE = function (value) {
        if (value !== (value | 0)) {
            throw new TypeError('value is out of bounds');
        }
        this.grow(4);
        this.size = writeInt32LE(this.buffer, this.size, value);
    };
    /**
     * Writes value to this stream with little endian format.
     * @param value number to be written to this stream. value should be a valid unsigned 32-bit integer.
     * TypeError will be throwed when value is anything other than an unsigned 32-bit integer.
     */
    ByteStream.prototype.writeUInt32LE = function (value) {
        if (value < 0 || value !== (value | 0) && (value & 0x7FFFFFFF) + 0x80000000 !== value) {
            throw new TypeError('value is out of bounds');
        }
        this.grow(4);
        this.size = writeInt32LE(this.buffer, this.size, value | 0);
    };
    /**
     * Writes binary data to this stream.
     * @param data to be written to this stream.
     */
    ByteStream.prototype.write = function (data) {
        var n = (data instanceof ArrayBuffer) ? data.byteLength : data.length;
        if (n === 0)
            return;
        this.grow(n);
        var bytes = this.buffer;
        var offset = this.size;
        if (data instanceof ByteStream) {
            bytes.set(data.bytes, offset);
        }
        else if (data instanceof ArrayBuffer) {
            bytes.set(new Uint8Array(data), offset);
        }
        else {
            bytes.set(data, offset);
        }
        this.size += n;
    };
    /**
     * Writes str to this stream with ascii encoding.
     * @param str to be written to this stream.
     */
    ByteStream.prototype.writeAsciiString = function (str) {
        var n = str.length;
        if (n === 0)
            return;
        this.grow(n);
        var bytes = this.buffer.subarray(this.size);
        for (var i = 0; i < n; ++i) {
            bytes[i] = str.charCodeAt(i);
        }
        this.size += n;
    };
    /**
     * Writes str to this stream with utf8 encoding.
     * @param str to be written to this stream.
     */
    ByteStream.prototype.writeString = function (str) {
        var n = str.length;
        if (n === 0)
            return;
        // The single code unit occupies up to 3 bytes.
        this.grow(n * 3);
        var bytes = this.buffer;
        var offset = this.size;
        for (var i = 0; i < n; ++i) {
            var charCode = str.charCodeAt(i);
            if (charCode < 0x80) {
                bytes[offset++] = charCode;
            }
            else if (charCode < 0x800) {
                bytes[offset++] = 0xC0 | (charCode >> 6);
                bytes[offset++] = 0x80 | (charCode & 0x3F);
            }
            else if (charCode < 0xD800 || charCode > 0xDFFF) {
                bytes[offset++] = 0xE0 | (charCode >> 12);
                bytes[offset++] = 0x80 | ((charCode >> 6) & 0x3F);
                bytes[offset++] = 0x80 | (charCode & 0x3F);
            }
            else {
                if (i + 1 < n) {
                    var nextCharCode = str.charCodeAt(i + 1);
                    if (charCode < 0xDC00 && 0xDC00 <= nextCharCode && nextCharCode <= 0xDFFF) {
                        var rune = (((charCode & 0x03FF) << 10) | (nextCharCode & 0x03FF)) + 0x010000;
                        bytes[offset++] = 0xF0 | (rune >> 18);
                        bytes[offset++] = 0x80 | ((rune >> 12) & 0x3F);
                        bytes[offset++] = 0x80 | ((rune >> 6) & 0x3F);
                        bytes[offset++] = 0x80 | (rune & 0x3F);
                        ++i;
                        continue;
                    }
                }
                throw new Error('Malformed string');
            }
        }
        this.size = offset;
    };
    /**
     * Reads and returns a single byte.
     * If no byte is available, returns -1.
     */
    ByteStream.prototype.readByte = function () {
        if (this.offset >= this.size)
            return -1;
        return this.buffer[this.offset++];
    };
    /**
     * Reads a signed 32-bit integer from this stream with the big endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    ByteStream.prototype.readInt32BE = function () {
        var bytes = this.buffer;
        var offset = this.offset;
        if (offset + 3 >= this.size) {
            throw new Error('EOF');
        }
        var result = bytes[offset++] << 24 | bytes[offset++] << 16 | bytes[offset++] << 8 | bytes[offset++];
        this.offset = offset;
        return result;
    };
    /**
     * Reads an unsigned 32-bit integer from this stream with the big endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    ByteStream.prototype.readUInt32BE = function () {
        var result = this.readInt32BE();
        if (result >= 0)
            return result;
        return (result & 0x7FFFFFFF) + 0x80000000;
    };
    /**
     * Reads a signed 32-bit integer from this stream with the little endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    ByteStream.prototype.readInt32LE = function () {
        var bytes = this.buffer;
        var offset = this.offset;
        if (offset + 3 >= this.size) {
            throw new Error('EOF');
        }
        var result = bytes[offset++] | bytes[offset++] << 8 | bytes[offset++] << 16 | bytes[offset++] << 24;
        this.offset = offset;
        return result;
    };
    /**
     * Reads an unsigned 32-bit integer from this stream with the little endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    ByteStream.prototype.readUInt32LE = function () {
        var result = this.readInt32LE();
        if (result >= 0)
            return result;
        return (result & 0x7FFFFFFF) + 0x80000000;
    };
    /**
     * Reads n bytes of data from this stream and returns the result as a Uint8Array.
     * If n is negative, reads to the end of this stream.
     * @param n The maximum number of bytes to read.
     */
    ByteStream.prototype.read = function (n) {
        if (n < 0 || this.offset + n > this.size)
            n = this.size - this.offset;
        if (n === 0)
            return EMPTY_BYTES;
        return this.buffer.subarray(this.offset, this.offset += n);
    };
    /**
     * Skips over and discards n bytes of data from this stream.
     * The actual number of bytes skipped is returned.
     * If n is negative, all remaining bytes are skipped.
     * @param n the number of bytes to be skipped.
     */
    ByteStream.prototype.skip = function (n) {
        if (n === 0)
            return 0;
        if (n < 0 || this.offset + n > this.size) {
            n = this.size - this.offset;
            this.offset = this.size;
        }
        else {
            this.offset += n;
        }
        return n;
    };
    /**
     * Returns a Uint8Array from the current position to the delimiter. The result includes delimiter.
     * Returns all remaining data if no delimiter is found.
     * After this method is called, The new position is after the delimiter.
     * @param delimiter a byte, which represents the end of reading data.
     */
    ByteStream.prototype.readBytes = function (delimiter) {
        var pos = this.buffer.indexOf(delimiter, this.offset);
        var result;
        if (pos === -1) {
            result = this.buffer.subarray(this.offset, this.size);
            this.offset = this.size;
        }
        else {
            result = this.buffer.subarray(this.offset, pos + 1);
            this.offset = pos + 1;
        }
        return result;
    };
    /**
     * Returns a string from the current position to the delimiter. The result doesn't include delimiter.
     * Returns all remaining data if no delimiter is found.
     * After this method is called, the new position is after the delimiter.
     * @param delimiter a byte, which represents the end of reading data.
     */
    ByteStream.prototype.readUntil = function (delimiter) {
        var pos = this.buffer.indexOf(delimiter, this.offset);
        var result = '';
        if (pos === this.offset) {
            this.offset++;
        }
        else if (pos === -1) {
            result = fromUint8Array(this.buffer.subarray(this.offset, this.size));
            this.offset = this.size;
        }
        else {
            result = fromUint8Array(this.buffer.subarray(this.offset, pos));
            this.offset = pos + 1;
        }
        return result;
    };
    /**
     * Reads n bytes of data from this stream and returns the result as an ascii string.
     * If n is negative, reads to the end of this stream.
     * @param n The maximum number of bytes to read.
     */
    ByteStream.prototype.readAsciiString = function (n) {
        return toBinaryString(this.read(n));
    };
    /**
     * Returns a Uint8Array containing a string of length n.
     * If n is negative, reads to the end of this stream.
     * @param n is the string(UTF16) length.
     */
    ByteStream.prototype.readStringAsBytes = function (n) {
        if (n === 0)
            return EMPTY_BYTES;
        var bytes = this.buffer.subarray(this.offset, this.size);
        if (n < 0) {
            this.offset = this.size;
            return bytes;
        }
        var offset = 0;
        for (var i = 0, length_1 = bytes.length; i < n && offset < length_1; i++) {
            var unit = bytes[offset++];
            switch (unit >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                case 12:
                case 13:
                    if (offset < length_1) {
                        offset++;
                        break;
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                case 14:
                    if (offset + 1 < length_1) {
                        offset += 2;
                        break;
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                case 15:
                    if (offset + 2 < length_1) {
                        var rune = (((unit & 0x07) << 18)
                            | ((bytes[offset++] & 0x3F) << 12)
                            | ((bytes[offset++] & 0x3F) << 6)
                            | (bytes[offset++] & 0x3F)) - 0x10000;
                        if (0 <= rune && rune <= 0xFFFFF) {
                            i++;
                            break;
                        }
                        throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));
                    }
                    throw new Error('Unfinished UTF-8 octet sequence');
                default:
                    throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));
            }
        }
        this.offset += offset;
        return bytes.subarray(0, offset);
    };
    /**
     * Returns a string of length n.
     * If n is negative, reads to the end of this stream.
     * @param n is the string(UTF16) length.
     */
    ByteStream.prototype.readString = function (n) {
        var _a = readString(this.buffer.subarray(this.offset, this.size), n), str = _a[0], length = _a[1];
        this.offset += length;
        return str;
    };
    /**
     * Returns a view of the the internal buffer and clears `this`.
     */
    ByteStream.prototype.takeBytes = function () {
        var bytes = this.bytes;
        this.clear();
        return bytes;
    };
    /**
     * Returns a copy of the current contents and leaves `this` intact.
     */
    ByteStream.prototype.toBytes = function () {
        return new Uint8Array(this.bytes);
    };
    /**
     * Returns a string representation of this stream.
     */
    ByteStream.prototype.toString = function () {
        return fromUint8Array(this.bytes);
    };
    /**
     * Creates an exact copy of this stream.
     */
    ByteStream.prototype.clone = function () {
        return new ByteStream(this.toBytes());
    };
    /**
     * Truncates this stream, only leaves the unread data.
     * The position is reset to 0.
     * The mark is cleared.
     */
    ByteStream.prototype.trunc = function () {
        this.buffer = this.remains;
        this.size = this.buffer.length;
        this.offset = 0;
        this.wmark = 0;
        this.rmark = 0;
    };
    return ByteStream;
}());
exports.ByteStream = ByteStream;
//# sourceMappingURL=ByteStream.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/Deserializer.js":
/*!*****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/Deserializer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Deserializer.ts                                          |
|                                                          |
| hprose Deserializer for TypeScript.                      |
|                                                          |
| LastModified: Mar 29, 2029                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ./ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var ArrayDeserializer_1 = __webpack_require__(/*! ./deserializers/ArrayDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/ArrayDeserializer.js");
var TypedArrayDeserializer_1 = __webpack_require__(/*! ./deserializers/TypedArrayDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/TypedArrayDeserializer.js");
var FunctionDeserializer_1 = __webpack_require__(/*! ./deserializers/FunctionDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/FunctionDeserializer.js");
var NumberDeserializer_1 = __webpack_require__(/*! ./deserializers/NumberDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/NumberDeserializer.js");
var BooleanDeserializer_1 = __webpack_require__(/*! ./deserializers/BooleanDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BooleanDeserializer.js");
var StringDeserializer_1 = __webpack_require__(/*! ./deserializers/StringDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/StringDeserializer.js");
var DateDeserializer_1 = __webpack_require__(/*! ./deserializers/DateDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/DateDeserializer.js");
var ByteStreamDeserializer_1 = __webpack_require__(/*! ./deserializers/ByteStreamDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/ByteStreamDeserializer.js");
var SetDeserializer_1 = __webpack_require__(/*! ./deserializers/SetDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/SetDeserializer.js");
var MapDeserializer_1 = __webpack_require__(/*! ./deserializers/MapDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/MapDeserializer.js");
var GuidDeserializer_1 = __webpack_require__(/*! ./deserializers/GuidDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/GuidDeserializer.js");
var ErrorDeserializer_1 = __webpack_require__(/*! ./deserializers/ErrorDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/ErrorDeserializer.js");
var NullDeserializer_1 = __webpack_require__(/*! ./deserializers/NullDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/NullDeserializer.js");
var DefaultDeserializer_1 = __webpack_require__(/*! ./deserializers/DefaultDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/DefaultDeserializer.js");
var guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "guid-typescript");
var deserializers = new Map();
function register(type, deserializer) {
    deserializers.set(type, deserializer);
}
exports.register = register;
function getInstance(type) {
    if (type) {
        switch (type) {
            case Function: return FunctionDeserializer_1.FunctionDeserializer.instance;
            case Number: return NumberDeserializer_1.NumberDeserializer.instance;
            case Boolean: return BooleanDeserializer_1.BooleanDeserializer.instance;
            case String: return StringDeserializer_1.StringDeserializer.instance;
            case Date: return DateDeserializer_1.DateDeserializer.instance;
            case Array: return ArrayDeserializer_1.ArrayDeserializer.instance;
            case ByteStream_1.ByteStream: return ByteStreamDeserializer_1.ByteStreamDeserializer.instance;
            case Uint8Array: return TypedArrayDeserializer_1.Uint8ArrayDeserializer.instance;
            case Uint8ClampedArray: return TypedArrayDeserializer_1.Uint8ClampedArrayDeserializer.instance;
            case Uint16Array: return TypedArrayDeserializer_1.Uint16ArrayDeserializer.instance;
            case Uint32Array: return TypedArrayDeserializer_1.Uint32ArrayDeserializer.instance;
            case Int8Array: return TypedArrayDeserializer_1.Int8ArrayDeserializer.instance;
            case Int16Array: return TypedArrayDeserializer_1.Int16ArrayDeserializer.instance;
            case Int32Array: return TypedArrayDeserializer_1.Int32ArrayDeserializer.instance;
            case Float32Array: return TypedArrayDeserializer_1.Float32ArrayDeserializer.instance;
            case Float64Array: return TypedArrayDeserializer_1.Float64ArrayDeserializer.instance;
            case Set: return SetDeserializer_1.SetDeserializer.instance;
            case Map: return MapDeserializer_1.MapDeserializer.instance;
            case guid_typescript_1.Guid: return GuidDeserializer_1.GuidDeserializer.instance;
            case Error: return ErrorDeserializer_1.ErrorDeserializer.instance;
        }
        var deserializer = deserializers.get(type);
        if (deserializer !== undefined)
            return deserializer;
    }
    if (type === null)
        return NullDeserializer_1.NullDeserializer.instance;
    return DefaultDeserializer_1.DefaultDeserializer.instance;
}
exports.getInstance = getInstance;
//# sourceMappingURL=Deserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/Formatter.js":
/*!**************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/Formatter.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Formatter.ts                                             |
|                                                          |
| hprose Formatter for TypeScript.                         |
|                                                          |
| LastModified: Feb 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ./ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var Writer_1 = __webpack_require__(/*! ./Writer */ "./real-server/node_modules/@hprose/io/lib/Writer.js");
var Reader_1 = __webpack_require__(/*! ./Reader */ "./real-server/node_modules/@hprose/io/lib/Reader.js");
function serialize(value, simple, utc) {
    var stream = new ByteStream_1.ByteStream();
    var writer = new Writer_1.Writer(stream, simple, utc);
    writer.serialize(value);
    return stream.bytes;
}
exports.serialize = serialize;
function deserialize(stream, type, simple) {
    if (!(stream instanceof ByteStream_1.ByteStream)) {
        stream = new ByteStream_1.ByteStream(stream);
    }
    var reader = new Reader_1.Reader(stream, simple);
    return reader.deserialize(type);
}
exports.deserialize = deserialize;
//# sourceMappingURL=Formatter.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/Reader.js":
/*!***********************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/Reader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Reader.ts                                                |
|                                                          |
| hprose Reader for TypeScript.                            |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ValueReader_1 = __webpack_require__(/*! ./ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js");
var TypeManager = __importStar(__webpack_require__(/*! ./TypeManager */ "./real-server/node_modules/@hprose/io/lib/TypeManager.js"));
var Deserializer = __importStar(__webpack_require__(/*! ./Deserializer */ "./real-server/node_modules/@hprose/io/lib/Deserializer.js"));
__webpack_require__(/*! ./deserializers/BigIntDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BigIntDeserializer.js");
__webpack_require__(/*! ./deserializers/BigIntArrayDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BigIntArrayDeserializer.js");
var ReaderRefer = /** @class */ (function () {
    function ReaderRefer() {
        this.ref = [];
    }
    Object.defineProperty(ReaderRefer.prototype, "lastIndex", {
        get: function () {
            return this.ref.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    ReaderRefer.prototype.add = function (value) {
        this.ref.push(value);
    };
    ReaderRefer.prototype.set = function (index, value) {
        this.ref[index] = value;
    };
    ReaderRefer.prototype.read = function (index) {
        return this.ref[index];
    };
    ReaderRefer.prototype.reset = function () {
        this.ref.length = 0;
    };
    return ReaderRefer;
}());
var Reader = /** @class */ (function () {
    function Reader(stream, simple) {
        if (simple === void 0) { simple = false; }
        this.stream = stream;
        this.ref = [];
        this.longType = 'number';
        this.dictType = 'object';
        this.simple = simple;
    }
    Object.defineProperty(Reader.prototype, "simple", {
        get: function () {
            return this.refer === undefined;
        },
        set: function (value) {
            this.refer = value ? undefined : new ReaderRefer();
        },
        enumerable: true,
        configurable: true
    });
    Reader.prototype.deserialize = function (type) {
        return Deserializer.getInstance(type).deserialize(this);
    };
    Reader.prototype.read = function (tag, type) {
        return Deserializer.getInstance(type).read(this, tag);
    };
    Reader.prototype.readClass = function () {
        var stream = this.stream;
        var name = ValueReader_1.readString(stream);
        var count = ValueReader_1.readCount(stream);
        var names = new Array(count);
        var strDeserialize = Deserializer.getInstance(String);
        for (var i = 0; i < count; ++i) {
            names[i] = strDeserialize.deserialize(this);
        }
        stream.readByte();
        this.ref.push({
            name: name,
            names: names,
            type: TypeManager.getType(name)
        });
    };
    Reader.prototype.getTypeInfo = function (index) {
        return this.ref[index];
    };
    Reader.prototype.readReference = function () {
        return this.refer ? this.refer.read(ValueReader_1.readInt(this.stream)) : undefined;
    };
    Reader.prototype.addReference = function (value) {
        if (this.refer)
            this.refer.add(value);
    };
    Reader.prototype.setReference = function (index, value) {
        if (this.refer)
            this.refer.set(index, value);
    };
    Object.defineProperty(Reader.prototype, "lastReferenceIndex", {
        get: function () {
            return this.refer ? this.refer.lastIndex : -1;
        },
        enumerable: true,
        configurable: true
    });
    Reader.prototype.reset = function () {
        if (this.refer)
            this.refer.reset();
        this.ref.length = 0;
    };
    return Reader;
}());
exports.Reader = Reader;
//# sourceMappingURL=Reader.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js":
/*!********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/ReferenceReader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ReferenceReader.ts                                       |
|                                                          |
| hprose reference reader for TypeScript.                  |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ValueReader = __importStar(__webpack_require__(/*! ./ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
function readBytes(reader) {
    var result = ValueReader.readBytes(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readBytes = readBytes;
function readAsciiString(reader) {
    var result = ValueReader.readAsciiString(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readAsciiString = readAsciiString;
function readString(reader) {
    var result = ValueReader.readString(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readString = readString;
function readGuid(reader) {
    var result = ValueReader.readGuid(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readGuid = readGuid;
function readDateTime(reader) {
    var result = ValueReader.readDateTime(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readDateTime = readDateTime;
function readTime(reader) {
    var result = ValueReader.readTime(reader.stream);
    reader.addReference(result);
    return result;
}
exports.readTime = readTime;
function readArray(reader) {
    var stream = reader.stream;
    var count = ValueReader.readCount(stream);
    var a = new Array(count);
    reader.addReference(a);
    for (var i = 0; i < count; ++i) {
        a[i] = reader.deserialize();
    }
    stream.readByte();
    return a;
}
exports.readArray = readArray;
function readSet(reader) {
    var stream = reader.stream;
    var count = ValueReader.readCount(stream);
    var a = new Set();
    reader.addReference(a);
    for (var i = 0; i < count; ++i) {
        a.add(reader.deserialize());
    }
    stream.readByte();
    return a;
}
exports.readSet = readSet;
function readMap(reader) {
    var stream = reader.stream;
    var map = new Map();
    reader.addReference(map);
    var count = ValueReader.readCount(stream);
    for (; count > 0; --count) {
        var key = reader.deserialize();
        var value = reader.deserialize();
        map.set(key, value);
    }
    stream.readByte();
    return map;
}
exports.readMap = readMap;
function readObject(reader) {
    var stream = reader.stream;
    var index = ValueReader.readInt(stream, 123 /* TagOpenbrace */);
    var typeInfo = reader.getTypeInfo(index);
    var type = typeInfo.type;
    var obj = (type) ? new type() : {};
    reader.addReference(obj);
    var names = typeInfo.names;
    var count = names.length;
    for (var i = 0; i < count; ++i) {
        obj[names[i]] = reader.deserialize();
    }
    stream.readByte();
    return obj;
}
exports.readObject = readObject;
function readObjectAsMap(reader) {
    var stream = reader.stream;
    var index = ValueReader.readInt(stream, 123 /* TagOpenbrace */);
    var typeInfo = reader.getTypeInfo(index);
    var map = new Map();
    reader.addReference(map);
    var names = typeInfo.names;
    var count = names.length;
    for (var i = 0; i < count; ++i) {
        map.set(names[i], reader.deserialize());
    }
    stream.readByte();
    return map;
}
exports.readObjectAsMap = readObjectAsMap;
//# sourceMappingURL=ReferenceReader.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/Serializer.js":
/*!***************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/Serializer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Serializer.ts                                            |
|                                                          |
| hprose Serializer for TypeScript.                        |
|                                                          |
| LastModified: Dec 18, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ./ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var BaseSerializer_1 = __webpack_require__(/*! ./serializers/BaseSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js");
var NumberSerializer_1 = __webpack_require__(/*! ./serializers/NumberSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/NumberSerializer.js");
var BooleanSerializer_1 = __webpack_require__(/*! ./serializers/BooleanSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BooleanSerializer.js");
var StringSerializer_1 = __webpack_require__(/*! ./serializers/StringSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/StringSerializer.js");
var DateSerializer_1 = __webpack_require__(/*! ./serializers/DateSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/DateSerializer.js");
var BytesSerializer_1 = __webpack_require__(/*! ./serializers/BytesSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BytesSerializer.js");
var GuidSerializer_1 = __webpack_require__(/*! ./serializers/GuidSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/GuidSerializer.js");
var TypedArraySerializer_1 = __webpack_require__(/*! ./serializers/TypedArraySerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/TypedArraySerializer.js");
var ArraySerializer_1 = __webpack_require__(/*! ./serializers/ArraySerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ArraySerializer.js");
var SetSerializer_1 = __webpack_require__(/*! ./serializers/SetSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/SetSerializer.js");
var MapSerializer_1 = __webpack_require__(/*! ./serializers/MapSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/MapSerializer.js");
var DictionarySerializer_1 = __webpack_require__(/*! ./serializers/DictionarySerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/DictionarySerializer.js");
var ObjectSerializer_1 = __webpack_require__(/*! ./serializers/ObjectSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ObjectSerializer.js");
var ErrorSerializer_1 = __webpack_require__(/*! ./serializers/ErrorSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ErrorSerializer.js");
var TypeManager = __importStar(__webpack_require__(/*! ./TypeManager */ "./real-server/node_modules/@hprose/io/lib/TypeManager.js"));
var ValueWriter_1 = __webpack_require__(/*! ./ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "guid-typescript");
var serializers = new Map();
var nullSerializer = new BaseSerializer_1.BaseSerializer();
var numberSerializer = new NumberSerializer_1.NumberSerializer();
var booleanSerializer = new BooleanSerializer_1.BooleanSerializer();
var stringSerializer = new StringSerializer_1.StringSerializer();
var dateSerializer = new DateSerializer_1.DateSerializer();
var bytesSerializer = new BytesSerializer_1.BytesSerializer();
var guidSerializer = new GuidSerializer_1.GuidSerializer();
var intArraySerializer = new TypedArraySerializer_1.TypedArraySerializer(ValueWriter_1.writeInteger);
var doubleArraySerializer = new TypedArraySerializer_1.TypedArraySerializer(ValueWriter_1.writeDouble);
var arraySerializer = new ArraySerializer_1.ArraySerializer();
var setSerializer = new SetSerializer_1.SetSerializer();
var mapSerializer = new MapSerializer_1.MapSerializer();
var dictionarySerializer = new DictionarySerializer_1.DictionarySerializer();
var errorSerializer = new ErrorSerializer_1.ErrorSerializer();
function register(type, serializer) {
    serializers.set(type, serializer);
}
exports.register = register;
function getInstance(value) {
    var type = value.constructor;
    switch (type) {
        case Function: return nullSerializer;
        case Number: return numberSerializer;
        case Boolean: return booleanSerializer;
        case String: return stringSerializer;
        case Date: return dateSerializer;
        case guid_typescript_1.Guid: return guidSerializer;
        case Array: return arraySerializer;
        case Set: return setSerializer;
        case Map: return mapSerializer;
        case ArrayBuffer:
        case Uint8Array:
        case Uint8ClampedArray:
        case ByteStream_1.ByteStream: return bytesSerializer;
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Uint16Array:
        case Uint32Array: return intArraySerializer;
        case Float32Array:
        case Float64Array: return doubleArraySerializer;
        case Error: return errorSerializer;
    }
    var serializer = serializers.get(type);
    if (serializer !== undefined)
        return serializer;
    if (Array.isArray(value) || Object.prototype.toString.call(value) === '[object Arguments]')
        return arraySerializer;
    if (value instanceof Error) {
        register(type, errorSerializer);
        return errorSerializer;
    }
    var name = TypeManager.getName(type);
    if (name === '')
        return dictionarySerializer;
    if (name === 'GeneratorFunction')
        return nullSerializer;
    if (name === 'AsyncFunction')
        return nullSerializer;
    var objectSerializer = new ObjectSerializer_1.ObjectSerializer(value, name);
    register(type, objectSerializer);
    return objectSerializer;
}
exports.getInstance = getInstance;
//# sourceMappingURL=Serializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/TypeManager.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/TypeManager.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| TypeManager.ts                                           |
|                                                          |
| hprose TypeManager for TypeScript.                       |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var typeCache = Object.create(null);
var nameCache = new WeakMap();
if (!('name' in Function.prototype)) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            var ctor = this.toString();
            return ctor.substr(0, ctor.indexOf('(')).replace(/(^\s*function\s*)|(\s*$)/ig, '');
        },
        writable: false,
        enumerable: false,
        configurable: true
    });
}
/**
 * Registers a type.
 */
function register(type, name) {
    if (name === undefined)
        name = type.name;
    nameCache.set(type, name);
    typeCache[name] = type;
}
exports.register = register;
/**
 * Returns whether the name has been registered.
 */
function isRegistered(name) {
    return name in typeCache;
}
exports.isRegistered = isRegistered;
/**
 * Gets name by type.
 */
function getName(type) {
    if (!type)
        return '';
    var name = nameCache.get(type);
    if (name)
        return name;
    name = type.name;
    if (name === '' || name === 'Object')
        return '';
    nameCache.set(type, name);
    typeCache[name] = type;
    return name;
}
exports.getName = getName;
var root = null;
try {
    root = typeof global === 'object' ? global : window;
}
catch (e) { }
function loadType(name) {
    if (!root)
        return undefined;
    var obj = root;
    var names = name.split('.');
    for (var i = 0; i < names.length; i++) {
        obj = obj[names[i]];
        if (obj === undefined) {
            return undefined;
        }
    }
    if (typeof (obj) !== 'function')
        return undefined;
    return obj;
}
function findType(alias, positions, i, c) {
    if (i < positions.length) {
        alias[positions[i++]] = c;
        var type = findType(alias, positions, i, '.');
        if (type === undefined && i < positions.length) {
            type = findType(alias, positions, i, '_');
        }
        return type;
    }
    return loadType(alias.join(''));
}
/**
 * Gets type by name.
 */
function getType(name) {
    var type = typeCache[name];
    if (type)
        return type;
    type = loadType(name);
    if (type) {
        register(type, name);
        return type;
    }
    var positions = [];
    var pos = name.indexOf('_');
    while (pos >= 0) {
        positions[positions.length] = pos;
        pos = name.indexOf('_', pos + 1);
    }
    if (positions.length > 0) {
        var alias = name.split('');
        type = findType(alias, positions, 0, '.');
        if (type === undefined) {
            type = findType(alias, positions, 0, '_');
        }
        if (type) {
            register(type, name);
            return type;
        }
    }
    type = function () { };
    Object.defineProperty(type, 'name', { value: name });
    register(type, name);
    return type;
}
exports.getType = getType;
//# sourceMappingURL=TypeManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/ValueReader.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/ValueReader.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ValueReader.ts                                           |
|                                                          |
| hprose value reader for TypeScript.                      |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "guid-typescript");
function readInt(stream, tag) {
    if (tag === void 0) { tag = 59 /* TagSemicolon */; }
    var s = stream.readUntil(tag);
    if (s.length === 0)
        return 0;
    return parseInt(s, 10);
}
exports.readInt = readInt;
function readDouble(stream) {
    return parseFloat(stream.readUntil(59 /* TagSemicolon */));
}
exports.readDouble = readDouble;
function readInfinity(stream) {
    return ((stream.readByte() === 45 /* TagNeg */) ? -Infinity : Infinity);
}
exports.readInfinity = readInfinity;
function readCount(stream) {
    return readInt(stream, 123 /* TagOpenbrace */);
}
exports.readCount = readCount;
function readLength(stream) {
    return readInt(stream, 34 /* TagQuote */);
}
exports.readLength = readLength;
function readString(stream) {
    var n = readLength(stream);
    var result = stream.readString(n);
    stream.readByte();
    return result;
}
exports.readString = readString;
function readBytes(stream) {
    var n = readLength(stream);
    var result = stream.read(n);
    stream.readByte();
    return result;
}
exports.readBytes = readBytes;
function readAsciiString(stream) {
    var n = readLength(stream);
    var result = stream.readAsciiString(n);
    stream.readByte();
    return result;
}
exports.readAsciiString = readAsciiString;
function readGuid(stream) {
    stream.readByte();
    var result = guid_typescript_1.Guid.parse(stream.readAsciiString(36));
    stream.readByte();
    return result;
}
exports.readGuid = readGuid;
function read4Digit(stream) {
    var n = stream.readByte() - 0x30;
    n = n * 10 + stream.readByte() - 0x30;
    n = n * 10 + stream.readByte() - 0x30;
    return n * 10 + stream.readByte() - 0x30;
}
function read2Digit(stream) {
    var n = stream.readByte() - 0x30;
    return n * 10 + stream.readByte() - 0x30;
}
function readMillisecond(stream) {
    var millisecond = stream.readByte() - 0x30;
    millisecond = millisecond * 10 + stream.readByte() - 0x30;
    millisecond = millisecond * 10 + stream.readByte() - 0x30;
    var tag = stream.readByte();
    if ((tag >= 0x30) && (tag <= 0x39)) {
        stream.skip(2);
        tag = stream.readByte();
        if ((tag >= 0x30) && (tag <= 0x39)) {
            stream.skip(2);
            tag = stream.readByte();
        }
    }
    return [millisecond, tag];
}
function readTime(stream) {
    var _a;
    var hour = read2Digit(stream);
    var minute = read2Digit(stream);
    var second = read2Digit(stream);
    var millisecond = 0;
    var tag = stream.readByte();
    if (tag === 46 /* TagPoint */) {
        _a = readMillisecond(stream), millisecond = _a[0], tag = _a[1];
    }
    if (tag === 90 /* TagUTC */) {
        return new Date(Date.UTC(1970, 0, 1, hour, minute, second, millisecond));
    }
    return new Date(1970, 0, 1, hour, minute, second, millisecond);
}
exports.readTime = readTime;
function readDateTime(stream) {
    var _a;
    var year = read4Digit(stream);
    var month = read2Digit(stream) - 1;
    var day = read2Digit(stream);
    var tag = stream.readByte();
    if (tag === 84 /* TagTime */) {
        var hour = read2Digit(stream);
        var minute = read2Digit(stream);
        var second = read2Digit(stream);
        var millisecond = 0;
        tag = stream.readByte();
        if (tag === 46 /* TagPoint */) {
            _a = readMillisecond(stream), millisecond = _a[0], tag = _a[1];
        }
        if (tag === 90 /* TagUTC */) {
            return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
        }
        return new Date(year, month, day, hour, minute, second, millisecond);
    }
    if (tag === 90 /* TagUTC */) {
        return new Date(Date.UTC(year, month, day));
    }
    return new Date(year, month, day);
}
exports.readDateTime = readDateTime;
//# sourceMappingURL=ValueReader.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/ValueWriter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ValueWriter.ts                                           |
|                                                          |
| hprose value writer for TypeScript.                      |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
function writeInteger(stream, value) {
    if (0 <= value && value <= 9) {
        stream.writeByte(0x30 + value);
    }
    else {
        if (value === (value | 0)) {
            stream.writeByte(105 /* TagInteger */);
        }
        else {
            stream.writeByte(108 /* TagLong */);
        }
        stream.writeAsciiString('' + value);
        stream.writeByte(59 /* TagSemicolon */);
    }
}
exports.writeInteger = writeInteger;
function writeDouble(stream, value) {
    if (isNaN(value)) {
        stream.writeByte(78 /* TagNaN */);
    }
    else if (isFinite(value)) {
        stream.writeByte(100 /* TagDouble */);
        stream.writeAsciiString('' + value);
        stream.writeByte(59 /* TagSemicolon */);
    }
    else {
        stream.writeByte(73 /* TagInfinity */);
        stream.writeByte((value > 0) ? 43 /* TagPos */ : 45 /* TagNeg */);
    }
}
exports.writeDouble = writeDouble;
function writeBigInt(stream, value) {
    if (0 <= value && value <= 9) {
        stream.writeByte(0x30 + Number(value));
    }
    else {
        stream.writeByte(108 /* TagLong */);
        stream.writeAsciiString('' + value);
        stream.writeByte(59 /* TagSemicolon */);
    }
}
exports.writeBigInt = writeBigInt;
function writeStringBody(stream, value) {
    var n = value.length;
    if (n > 0)
        stream.writeAsciiString('' + n);
    stream.writeByte(34 /* TagQuote */);
    stream.writeString(value);
    stream.writeByte(34 /* TagQuote */);
}
exports.writeStringBody = writeStringBody;
function writeUTCDate(stream, value) {
    var year = value.getUTCFullYear();
    var month = value.getUTCMonth() + 1;
    var day = value.getUTCDate();
    var hour = value.getUTCHours();
    var minute = value.getUTCMinutes();
    var second = value.getUTCSeconds();
    var millisecond = value.getUTCMilliseconds();
    writeDateTime(stream, year, month, day, hour, minute, second, millisecond, true);
}
exports.writeUTCDate = writeUTCDate;
function writeLocalDate(stream, value) {
    var year = value.getFullYear();
    var month = value.getMonth() + 1;
    var day = value.getDate();
    var hour = value.getHours();
    var minute = value.getMinutes();
    var second = value.getSeconds();
    var millisecond = value.getMilliseconds();
    writeDateTime(stream, year, month, day, hour, minute, second, millisecond, false);
}
exports.writeLocalDate = writeLocalDate;
function writeDateTime(stream, year, month, day, hour, minute, second, millisecond, utc) {
    if ((hour === 0) && (minute === 0) && (second === 0) && (millisecond === 0)) {
        writeDate(stream, year, month, day);
    }
    else if ((year === 1970) && (month === 1) && (day === 1)) {
        writeTime(stream, hour, minute, second, millisecond);
    }
    else {
        writeDate(stream, year, month, day);
        writeTime(stream, hour, minute, second, millisecond);
    }
    stream.writeByte(utc ? 90 /* TagUTC */ : 59 /* TagSemicolon */);
}
exports.writeDateTime = writeDateTime;
function writeDate(stream, year, month, day) {
    stream.writeByte(68 /* TagDate */);
    stream.writeAsciiString(('0000' + year).slice(-4));
    stream.writeAsciiString(('00' + month).slice(-2));
    stream.writeAsciiString(('00' + day).slice(-2));
}
exports.writeDate = writeDate;
function writeTime(stream, hour, minute, second, millisecond) {
    stream.writeByte(84 /* TagTime */);
    stream.writeAsciiString(('00' + hour).slice(-2));
    stream.writeAsciiString(('00' + minute).slice(-2));
    stream.writeAsciiString(('00' + second).slice(-2));
    if (millisecond > 0) {
        stream.writeByte(46 /* TagPoint */);
        stream.writeAsciiString(('000' + millisecond).slice(-3));
    }
}
exports.writeTime = writeTime;
//# sourceMappingURL=ValueWriter.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/Writer.js":
/*!***********************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/Writer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Writer.ts                                                |
|                                                          |
| hprose Writer for TypeScript.                            |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Serializer = __importStar(__webpack_require__(/*! ./Serializer */ "./real-server/node_modules/@hprose/io/lib/Serializer.js"));
__webpack_require__(/*! ./serializers/BigIntSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BigIntSerializer.js");
__webpack_require__(/*! ./serializers/BigIntArraySerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BigIntArraySerializer.js");
var WriterRefer = /** @class */ (function () {
    function WriterRefer() {
        this.ref = new Map();
        this.last = 0;
    }
    WriterRefer.prototype.addCount = function (count) {
        this.last += count;
    };
    WriterRefer.prototype.set = function (value) {
        this.ref.set(value, this.last++);
    };
    WriterRefer.prototype.write = function (stream, value) {
        var index = this.ref.get(value);
        if (index !== undefined) {
            stream.writeByte(114 /* TagRef */);
            stream.writeAsciiString('' + index);
            stream.writeByte(59 /* TagSemicolon */);
            return true;
        }
        return false;
    };
    WriterRefer.prototype.reset = function () {
        this.ref.clear();
        this.last = 0;
    };
    return WriterRefer;
}());
var Writer = /** @class */ (function () {
    function Writer(stream, simple, utc) {
        if (simple === void 0) { simple = false; }
        if (utc === void 0) { utc = false; }
        this.stream = stream;
        this.utc = utc;
        this.ref = new Map();
        this.last = 0;
        this.simple = simple;
    }
    Object.defineProperty(Writer.prototype, "simple", {
        get: function () {
            return this.refer === undefined;
        },
        set: function (value) {
            this.refer = value ? undefined : new WriterRefer();
        },
        enumerable: true,
        configurable: true
    });
    Writer.prototype.serialize = function (value) {
        if (value === undefined || value === null) {
            this.stream.writeByte(110 /* TagNull */);
        }
        else {
            Serializer.getInstance(value).serialize(this, value);
        }
    };
    Writer.prototype.write = function (value) {
        if (value === undefined || value === null) {
            this.stream.writeByte(110 /* TagNull */);
        }
        else {
            Serializer.getInstance(value).write(this, value);
        }
    };
    Writer.prototype.writeReference = function (value) {
        return this.refer ? this.refer.write(this.stream, value) : false;
    };
    Writer.prototype.setReference = function (value) {
        if (this.refer)
            this.refer.set(value);
    };
    Writer.prototype.addReferenceCount = function (count) {
        if (this.refer)
            this.refer.addCount(count);
    };
    Writer.prototype.reset = function () {
        if (this.refer)
            this.refer.reset();
        this.ref.clear();
        this.last = 0;
    };
    Writer.prototype.writeClass = function (type, action) {
        var r = this.ref.get(type);
        if (r === undefined) {
            action();
            r = this.last++;
            this.ref.set(type, r);
        }
        return r;
    };
    return Writer;
}());
exports.Writer = Writer;
//# sourceMappingURL=Writer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/ArrayDeserializer.js":
/*!************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/ArrayDeserializer.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ArrayDeserializer.ts                                     |
|                                                          |
| hprose array deserializer for TypeScript.                |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var ArrayDeserializer = /** @class */ (function (_super) {
    __extends(ArrayDeserializer, _super);
    function ArrayDeserializer() {
        return _super.call(this, 'Array') || this;
    }
    ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 97 /* TagList */: return ReferenceReader.readArray(reader);
            case 101 /* TagEmpty */: return [];
            case 115 /* TagString */: return ReferenceReader.readString(reader).split('');
            case 98 /* TagBytes */: return Array.from(ReferenceReader.readBytes(reader));
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Uint8Array) {
                    return Array.from(result);
                }
                else if (result instanceof String) {
                    return result.split('');
                }
                else {
                    return result;
                }
            }
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    ArrayDeserializer.instance = new ArrayDeserializer();
    return ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.ArrayDeserializer = ArrayDeserializer;
//# sourceMappingURL=ArrayDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js":
/*!***********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BaseDeserializer.ts                                      |
|                                                          |
| hprose base deserializer for TypeScript.                 |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
function tagToString(tag) {
    switch (tag) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 105 /* TagInteger */: return 'int32 number';
        case 108 /* TagLong */: return 'long number';
        case 100 /* TagDouble */: return 'double number';
        case 110 /* TagNull */: return 'null | undefined';
        case 101 /* TagEmpty */: return 'empty string';
        case 116 /* TagTrue */: return 'true';
        case 102 /* TagFalse */: return 'false';
        case 78 /* TagNaN */: return 'NaN';
        case 73 /* TagInfinity */: return 'Infinity';
        case 68 /* TagDate */:
        case 84 /* TagTime */: return 'Date';
        case 98 /* TagBytes */: return 'Uint8Array';
        case 117 /* TagUTF8Char */:
        case 115 /* TagString */: return 'string';
        case 103 /* TagGuid */: return 'guid string';
        case 97 /* TagList */: return 'Array';
        case 109 /* TagMap */: return 'object | Map';
        case 99 /* TagClass */: return 'class';
        case 111 /* TagObject */: return 'Object';
        case 114 /* TagRef */: return 'Reference';
        case 69 /* TagError */: return 'Error';
        default: throw new Error('Unexpected Tag: 0x' + (tag & 0xFF).toString(16));
    }
}
var BaseDeserializer = /** @class */ (function () {
    function BaseDeserializer(type) {
        if (type === void 0) { type = 'undefined'; }
        this.type = type;
    }
    BaseDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 110 /* TagNull */: return undefined;
            case 114 /* TagRef */: return reader.readReference();
            case 99 /* TagClass */:
                reader.readClass();
                return this.deserialize(reader);
            case 69 /* TagError */:
                throw new Error(reader.deserialize(String));
        }
        throw new Error('Cannot convert ' + tagToString(tag) + ' to ' + this.type + '.');
    };
    BaseDeserializer.prototype.deserialize = function (reader) {
        return this.read(reader, reader.stream.readByte());
    };
    return BaseDeserializer;
}());
exports.BaseDeserializer = BaseDeserializer;
//# sourceMappingURL=BaseDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/BigIntArrayDeserializer.js":
/*!******************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/BigIntArrayDeserializer.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BigIntArrayDeserializer.ts                               |
|                                                          |
| hprose bigint Array deserializer for TypeScript.         |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var Deserializer_1 = __webpack_require__(/*! ../Deserializer */ "./real-server/node_modules/@hprose/io/lib/Deserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
function readBigIntArray(reader, type) {
    var stream = reader.stream;
    var count = ValueReader.readCount(stream);
    var a = new type(count);
    reader.addReference(a);
    var deserializer = Deserializer_1.getInstance(BigInt);
    for (var i = 0; i < count; ++i) {
        a[i] = deserializer.deserialize(reader);
    }
    stream.readByte();
    return a;
}
if (typeof BigInt64Array !== 'undefined') {
    var empty_1 = new BigInt64Array(0);
    var BigInt64ArrayDeserializer = /** @class */ (function (_super) {
        __extends(BigInt64ArrayDeserializer, _super);
        function BigInt64ArrayDeserializer() {
            return _super.call(this, 'BigInt64Array') || this;
        }
        BigInt64ArrayDeserializer.prototype.read = function (reader, tag) {
            switch (tag) {
                case 101 /* TagEmpty */: return empty_1;
                case 97 /* TagList */: return readBigIntArray(reader, BigInt64Array);
                default:
                    return _super.prototype.read.call(this, reader, tag);
            }
        };
        BigInt64ArrayDeserializer.instance = new BigInt64ArrayDeserializer();
        return BigInt64ArrayDeserializer;
    }(BaseDeserializer_1.BaseDeserializer));
    Deserializer_1.register(BigInt64Array, BigInt64ArrayDeserializer.instance);
}
if (typeof BigUint64Array !== 'undefined') {
    var empty_2 = new BigUint64Array(0);
    var BigUint64ArrayDeserializer = /** @class */ (function (_super) {
        __extends(BigUint64ArrayDeserializer, _super);
        function BigUint64ArrayDeserializer() {
            return _super.call(this, 'BigUint64Array') || this;
        }
        BigUint64ArrayDeserializer.prototype.read = function (reader, tag) {
            switch (tag) {
                case 101 /* TagEmpty */: return empty_2;
                case 97 /* TagList */: return readBigIntArray(reader, BigUint64Array);
                default:
                    return _super.prototype.read.call(this, reader, tag);
            }
        };
        BigUint64ArrayDeserializer.instance = new BigUint64ArrayDeserializer();
        return BigUint64ArrayDeserializer;
    }(BaseDeserializer_1.BaseDeserializer));
    Deserializer_1.register(BigUint64Array, BigUint64ArrayDeserializer.instance);
}
//# sourceMappingURL=BigIntArrayDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/BigIntDeserializer.js":
/*!*************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/BigIntDeserializer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BigIntDeserializer.ts                                    |
|                                                          |
| hprose bigint deserializer for TypeScript.               |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var Deserializer_1 = __webpack_require__(/*! ../Deserializer */ "./real-server/node_modules/@hprose/io/lib/Deserializer.js");
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
if (typeof BigInt !== 'undefined') {
    var BigIntDeserializer = /** @class */ (function (_super) {
        __extends(BigIntDeserializer, _super);
        function BigIntDeserializer() {
            return _super.call(this, 'bigint') || this;
        }
        BigIntDeserializer.prototype.read = function (reader, tag) {
            if (tag >= 0x30 && tag <= 0x39) {
                return BigInt(tag - 0x30);
            }
            var stream = reader.stream;
            switch (tag) {
                case 105 /* TagInteger */:
                case 108 /* TagLong */:
                case 100 /* TagDouble */: return BigInt(stream.readUntil(59 /* TagSemicolon */));
                case 116 /* TagTrue */: return BigInt(1);
                case 102 /* TagFalse */:
                case 101 /* TagEmpty */: return BigInt(0);
                case 115 /* TagString */: return BigInt(ReferenceReader.readString(reader));
                case 117 /* TagUTF8Char */: return BigInt(stream.readString(1).charCodeAt(1));
                case 68 /* TagDate */: return BigInt(ReferenceReader.readDateTime(reader).getTime());
                case 84 /* TagTime */: return BigInt(ReferenceReader.readTime(reader).getTime());
                case 114 /* TagRef */: {
                    var result = reader.readReference();
                    if (result instanceof Date) {
                        return BigInt(result.getTime());
                    }
                    else {
                        return BigInt(result.toString());
                    }
                }
                default: return _super.prototype.read.call(this, reader, tag);
            }
        };
        BigIntDeserializer.instance = new BigIntDeserializer();
        return BigIntDeserializer;
    }(BaseDeserializer_1.BaseDeserializer));
    Deserializer_1.register(BigInt, BigIntDeserializer.instance);
}
//# sourceMappingURL=BigIntDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/BooleanDeserializer.js":
/*!**************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/BooleanDeserializer.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BooleanDeserializer.ts                                   |
|                                                          |
| hprose boolean deserializer for TypeScript.              |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var BooleanDeserializer = /** @class */ (function (_super) {
    __extends(BooleanDeserializer, _super);
    function BooleanDeserializer() {
        return _super.call(this, 'boolean') || this;
    }
    BooleanDeserializer.prototype.read = function (reader, tag) {
        var stream = reader.stream;
        switch (tag) {
            case 116 /* TagTrue */: return true;
            case 102 /* TagFalse */:
            case 101 /* TagEmpty */:
            case 78 /* TagNaN */:
            case 0x30: return false;
            case 105 /* TagInteger */:
            case 108 /* TagLong */: return ValueReader.readInt(stream) !== 0;
            case 100 /* TagDouble */: return ValueReader.readDouble(stream) !== 0;
            case 115 /* TagString */: return Boolean(ReferenceReader.readString(reader));
            case 117 /* TagUTF8Char */: return '0\0'.indexOf(stream.readString(1)) === -1;
            case 73 /* TagInfinity */:
                stream.readByte();
                return true;
            case 114 /* TagRef */: return Boolean(reader.readReference().toString());
            default:
                if (tag >= 0x31 && tag <= 0x39) {
                    return true;
                }
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    BooleanDeserializer.instance = new BooleanDeserializer();
    return BooleanDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.BooleanDeserializer = BooleanDeserializer;
//# sourceMappingURL=BooleanDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/ByteStreamDeserializer.js":
/*!*****************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/ByteStreamDeserializer.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ByteStreamDeserializer.ts                                |
|                                                          |
| hprose ByteStream deserializer for TypeScript.           |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ../ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var TypedArrayDeserializer_1 = __webpack_require__(/*! ./TypedArrayDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/TypedArrayDeserializer.js");
var ReferenceReader_1 = __webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js");
var ByteStreamDeserializer = /** @class */ (function (_super) {
    __extends(ByteStreamDeserializer, _super);
    function ByteStreamDeserializer() {
        return _super.call(this, 'ByteStream') || this;
    }
    ByteStreamDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 98 /* TagBytes */: return new ByteStream_1.ByteStream(ReferenceReader_1.readBytes(reader));
            case 101 /* TagEmpty */: return new ByteStream_1.ByteStream(0);
            case 97 /* TagList */: return new ByteStream_1.ByteStream(TypedArrayDeserializer_1.readIntArray(reader, Uint8Array));
            case 117 /* TagUTF8Char */: return new ByteStream_1.ByteStream(reader.stream.readString(1));
            case 115 /* TagString */: return new ByteStream_1.ByteStream(ReferenceReader_1.readString(reader));
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Uint8Array) {
                    return new ByteStream_1.ByteStream(result);
                }
                else {
                    return new ByteStream_1.ByteStream(result.toString());
                }
            }
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    ByteStreamDeserializer.instance = new ByteStreamDeserializer();
    return ByteStreamDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.ByteStreamDeserializer = ByteStreamDeserializer;
//# sourceMappingURL=ByteStreamDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/DateDeserializer.js":
/*!***********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/DateDeserializer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| DateDeserializer.ts                                      |
|                                                          |
| hprose date deserializer for TypeScript.                 |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var DateDeserializer = /** @class */ (function (_super) {
    __extends(DateDeserializer, _super);
    function DateDeserializer() {
        return _super.call(this, 'Date') || this;
    }
    DateDeserializer.prototype.read = function (reader, tag) {
        var stream = reader.stream;
        switch (tag) {
            case 68 /* TagDate */: return ReferenceReader.readDateTime(reader);
            case 84 /* TagTime */: return ReferenceReader.readTime(reader);
            case 105 /* TagInteger */: return new Date(ValueReader.readInt(stream));
            case 108 /* TagLong */: return new Date(ValueReader.readInt(stream));
            case 100 /* TagDouble */: return new Date(Math.floor(ValueReader.readDouble(stream)));
            case 115 /* TagString */: return new Date(ReferenceReader.readString(reader));
            case 116 /* TagTrue */: return new Date(1);
            case 102 /* TagFalse */:
            case 101 /* TagEmpty */: return new Date(0);
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Date) {
                    return result;
                }
                else {
                    return new Date(result.toString());
                }
            }
            default:
                if (tag >= 0x30 && tag <= 0x39) {
                    return new Date(tag - 0x30);
                }
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    DateDeserializer.instance = new DateDeserializer();
    return DateDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.DateDeserializer = DateDeserializer;
//# sourceMappingURL=DateDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/DefaultDeserializer.js":
/*!**************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/DefaultDeserializer.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| DefaultDeserializer.ts                                   |
|                                                          |
| hprose DefaultDeserializer for TypeScript.               |
|                                                          |
| LastModified: Feb 8, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var StringDeserializer_1 = __webpack_require__(/*! ./StringDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/StringDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var DefaultDeserializer = /** @class */ (function (_super) {
    __extends(DefaultDeserializer, _super);
    function DefaultDeserializer() {
        return _super.call(this, 'any') || this;
    }
    DefaultDeserializer.prototype.read = function (reader, tag) {
        if (tag >= 0x30 && tag <= 0x39) {
            return tag - 0x30;
        }
        var stream = reader.stream;
        switch (tag) {
            case 105 /* TagInteger */: return ValueReader.readInt(stream);
            case 115 /* TagString */: return ReferenceReader.readString(reader);
            case 98 /* TagBytes */: return ReferenceReader.readBytes(reader);
            case 116 /* TagTrue */: return true;
            case 102 /* TagFalse */: return false;
            case 101 /* TagEmpty */: return '';
            case 111 /* TagObject */: return ReferenceReader.readObject(reader);
            case 68 /* TagDate */: return ReferenceReader.readDateTime(reader);
            case 84 /* TagTime */: return ReferenceReader.readTime(reader);
            case 103 /* TagGuid */: return ReferenceReader.readGuid(reader);
            case 108 /* TagLong */:
                switch (reader.longType) {
                    case 'number':
                        return ValueReader.readInt(stream);
                    case 'bigint':
                        if (typeof BigInt !== 'undefined') {
                            return BigInt(stream.readUntil(59 /* TagSemicolon */));
                        }
                    // tslint:disable-next-line:no-switch-case-fall-through
                    case 'string':
                        return stream.readUntil(59 /* TagSemicolon */);
                }
                break;
            case 100 /* TagDouble */: return ValueReader.readDouble(stream);
            case 78 /* TagNaN */: return NaN;
            case 73 /* TagInfinity */: return ValueReader.readInfinity(stream);
            case 117 /* TagUTF8Char */: return stream.readString(1);
            case 97 /* TagList */: return ReferenceReader.readArray(reader);
            case 109 /* TagMap */: return (reader.dictType === 'map') ? ReferenceReader.readMap(reader) : readDict(reader);
            case 69 /* TagError */: return new Error(reader.deserialize(String));
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    DefaultDeserializer.instance = new DefaultDeserializer();
    return DefaultDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.DefaultDeserializer = DefaultDeserializer;
function readDict(reader) {
    var stream = reader.stream;
    var dict = Object.create(null);
    reader.addReference(dict);
    var count = ValueReader.readCount(stream);
    var strDeserializer = StringDeserializer_1.StringDeserializer.instance;
    var deserializer = DefaultDeserializer.instance;
    for (; count > 0; --count) {
        var key = strDeserializer.deserialize(reader);
        var value = deserializer.deserialize(reader);
        dict[key] = value;
    }
    stream.readByte();
    return dict;
}
//# sourceMappingURL=DefaultDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/ErrorDeserializer.js":
/*!************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/ErrorDeserializer.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ErrorDeserializer.ts                                     |
|                                                          |
| hprose Error deserializer for TypeScript.                |
|                                                          |
| LastModified: Feb 8, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ErrorDeserializer = /** @class */ (function (_super) {
    __extends(ErrorDeserializer, _super);
    function ErrorDeserializer() {
        return _super.call(this, 'Error') || this;
    }
    ErrorDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 69 /* TagError */: return new Error(reader.deserialize(String));
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    ErrorDeserializer.instance = new ErrorDeserializer();
    return ErrorDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.ErrorDeserializer = ErrorDeserializer;
//# sourceMappingURL=ErrorDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/FunctionDeserializer.js":
/*!***************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/FunctionDeserializer.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| FunctionDeserializer.ts                                  |
|                                                          |
| hprose function deserializer for TypeScript.             |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var FunctionDeserializer = /** @class */ (function (_super) {
    __extends(FunctionDeserializer, _super);
    function FunctionDeserializer() {
        return _super.call(this, 'function') || this;
    }
    FunctionDeserializer.instance = new FunctionDeserializer();
    return FunctionDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.FunctionDeserializer = FunctionDeserializer;
//# sourceMappingURL=FunctionDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/GuidDeserializer.js":
/*!***********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/GuidDeserializer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| GuidDeserializer.ts                                      |
|                                                          |
| hprose Guid deserializer for TypeScript.                 |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "guid-typescript");
var GuidDeserializer = /** @class */ (function (_super) {
    __extends(GuidDeserializer, _super);
    function GuidDeserializer() {
        return _super.call(this, 'Guid') || this;
    }
    GuidDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 103 /* TagGuid */: return ReferenceReader.readGuid(reader);
            case 115 /* TagString */: return guid_typescript_1.Guid.parse(ReferenceReader.readString(reader));
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof guid_typescript_1.Guid) {
                    return result;
                }
                else {
                    return guid_typescript_1.Guid.parse(result.toString());
                }
            }
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    GuidDeserializer.instance = new GuidDeserializer();
    return GuidDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.GuidDeserializer = GuidDeserializer;
//# sourceMappingURL=GuidDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/IntDeserializer.js":
/*!**********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/IntDeserializer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| IntDeserializer.ts                                       |
|                                                          |
| hprose int deserializer for TypeScript.                  |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var IntDeserializer = /** @class */ (function (_super) {
    __extends(IntDeserializer, _super);
    function IntDeserializer() {
        return _super.call(this, 'int') || this;
    }
    IntDeserializer.prototype.read = function (reader, tag) {
        if (tag >= 0x30 && tag <= 0x39) {
            return tag - 0x30;
        }
        var stream = reader.stream;
        switch (tag) {
            case 105 /* TagInteger */:
            case 108 /* TagLong */: return ValueReader.readInt(stream);
            case 100 /* TagDouble */: return Math.floor(ValueReader.readDouble(stream));
            case 116 /* TagTrue */: return 1;
            case 102 /* TagFalse */:
            case 101 /* TagEmpty */: return 0;
            case 115 /* TagString */: return parseInt(ReferenceReader.readString(reader));
            case 117 /* TagUTF8Char */: return stream.readString(1).charCodeAt(1);
            case 68 /* TagDate */: return ReferenceReader.readDateTime(reader).getTime();
            case 84 /* TagTime */: return ReferenceReader.readTime(reader).getTime();
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Date) {
                    return result.getTime();
                }
                else {
                    return parseInt(result.toString());
                }
            }
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    IntDeserializer.instance = new IntDeserializer();
    return IntDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.IntDeserializer = IntDeserializer;
//# sourceMappingURL=IntDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/MapDeserializer.js":
/*!**********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/MapDeserializer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MapDeserializer.ts                                       |
|                                                          |
| hprose Map deserializer for TypeScript.                  |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var MapDeserializer = /** @class */ (function (_super) {
    __extends(MapDeserializer, _super);
    function MapDeserializer() {
        return _super.call(this, 'Map') || this;
    }
    MapDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return new Map();
            case 109 /* TagMap */: return ReferenceReader.readMap(reader);
            case 111 /* TagObject */: return ReferenceReader.readObjectAsMap(reader);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    MapDeserializer.instance = new MapDeserializer();
    return MapDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.MapDeserializer = MapDeserializer;
//# sourceMappingURL=MapDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/NullDeserializer.js":
/*!***********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/NullDeserializer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| NullDeserializer.ts                                      |
|                                                          |
| hprose null deserializer for TypeScript.                 |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DefaultDeserializer_1 = __webpack_require__(/*! ./DefaultDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/DefaultDeserializer.js");
var NullDeserializer = /** @class */ (function (_super) {
    __extends(NullDeserializer, _super);
    function NullDeserializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullDeserializer.prototype.read = function (reader, tag) {
        if (tag === 110 /* TagNull */)
            return null;
        return _super.prototype.read.call(this, reader, tag);
    };
    NullDeserializer.instance = new NullDeserializer();
    return NullDeserializer;
}(DefaultDeserializer_1.DefaultDeserializer));
exports.NullDeserializer = NullDeserializer;
//# sourceMappingURL=NullDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/NumberDeserializer.js":
/*!*************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/NumberDeserializer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| NumberDeserializer.ts                                    |
|                                                          |
| hprose number deserializer for TypeScript.               |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var NumberDeserializer = /** @class */ (function (_super) {
    __extends(NumberDeserializer, _super);
    function NumberDeserializer() {
        return _super.call(this, 'number') || this;
    }
    NumberDeserializer.prototype.read = function (reader, tag) {
        if (tag >= 0x30 && tag <= 0x39) {
            return tag - 0x30;
        }
        var stream = reader.stream;
        switch (tag) {
            case 105 /* TagInteger */:
            case 108 /* TagLong */: return ValueReader.readInt(stream);
            case 100 /* TagDouble */: return ValueReader.readDouble(stream);
            case 78 /* TagNaN */: return NaN;
            case 73 /* TagInfinity */: return ValueReader.readInfinity(stream);
            case 116 /* TagTrue */: return 1;
            case 102 /* TagFalse */:
            case 101 /* TagEmpty */: return 0;
            case 115 /* TagString */: return Number(ReferenceReader.readString(reader));
            case 117 /* TagUTF8Char */: return stream.readString(1).charCodeAt(1);
            case 68 /* TagDate */: return ReferenceReader.readDateTime(reader).getTime();
            case 84 /* TagTime */: return ReferenceReader.readTime(reader).getTime();
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Date) {
                    return result.getTime();
                }
                else {
                    return Number(result.toString());
                }
            }
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    NumberDeserializer.instance = new NumberDeserializer();
    return NumberDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.NumberDeserializer = NumberDeserializer;
//# sourceMappingURL=NumberDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/SetDeserializer.js":
/*!**********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/SetDeserializer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| SetDeserializer.ts                                       |
|                                                          |
| hprose Set deserializer for TypeScript.                  |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ReferenceReader_1 = __webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js");
var SetDeserializer = /** @class */ (function (_super) {
    __extends(SetDeserializer, _super);
    function SetDeserializer() {
        return _super.call(this, 'Set') || this;
    }
    SetDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return new Set();
            case 97 /* TagList */: return ReferenceReader_1.readSet(reader);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    SetDeserializer.instance = new SetDeserializer();
    return SetDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.SetDeserializer = SetDeserializer;
//# sourceMappingURL=SetDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/StringDeserializer.js":
/*!*************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/StringDeserializer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| StringDeserializer.ts                                    |
|                                                          |
| hprose string deserializer for TypeScript.               |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader = __importStar(__webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
var ReferenceReader = __importStar(__webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
var StringDeserializer = /** @class */ (function (_super) {
    __extends(StringDeserializer, _super);
    function StringDeserializer() {
        return _super.call(this, 'string') || this;
    }
    StringDeserializer.prototype.read = function (reader, tag) {
        if (tag >= 0x30 && tag <= 0x39) {
            return String.fromCharCode(tag);
        }
        var stream = reader.stream;
        switch (tag) {
            case 105 /* TagInteger */:
            case 108 /* TagLong */:
            case 100 /* TagDouble */: return stream.readUntil(59 /* TagSemicolon */);
            case 115 /* TagString */: return ReferenceReader.readString(reader);
            case 98 /* TagBytes */: return ReferenceReader.readAsciiString(reader);
            case 116 /* TagTrue */: return 'true';
            case 102 /* TagFalse */: return 'false';
            case 101 /* TagEmpty */: return '';
            case 68 /* TagDate */: return ReferenceReader.readDateTime(reader).toString();
            case 84 /* TagTime */: return ReferenceReader.readTime(reader).toTimeString();
            case 103 /* TagGuid */: return ReferenceReader.readGuid(reader).toString();
            case 78 /* TagNaN */: return 'NaN';
            case 73 /* TagInfinity */: return ValueReader.readInfinity(stream).toString();
            case 117 /* TagUTF8Char */: return stream.readString(1);
            case 97 /* TagList */: return ReferenceReader.readArray(reader).join('');
            case 114 /* TagRef */: return reader.readReference().toString();
            default: return _super.prototype.read.call(this, reader, tag);
        }
    };
    StringDeserializer.instance = new StringDeserializer();
    return StringDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.StringDeserializer = StringDeserializer;
//# sourceMappingURL=StringDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/deserializers/TypedArrayDeserializer.js":
/*!*****************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/deserializers/TypedArrayDeserializer.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| TypedArrayDeserializer.ts                                |
|                                                          |
| hprose TypedArray deserializer for TypeScript.           |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ../ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var IntDeserializer_1 = __webpack_require__(/*! ./IntDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/IntDeserializer.js");
var NumberDeserializer_1 = __webpack_require__(/*! ./NumberDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/NumberDeserializer.js");
var BaseDeserializer_1 = __webpack_require__(/*! ./BaseDeserializer */ "./real-server/node_modules/@hprose/io/lib/deserializers/BaseDeserializer.js");
var ValueReader_1 = __webpack_require__(/*! ../ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js");
var ReferenceReader_1 = __webpack_require__(/*! ../ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js");
function readIntArray(reader, type) {
    var stream = reader.stream;
    var count = ValueReader_1.readCount(stream);
    var a = new type(count);
    reader.addReference(a);
    var deserializer = IntDeserializer_1.IntDeserializer.instance;
    for (var i = 0; i < count; ++i) {
        a[i] = deserializer.deserialize(reader);
    }
    stream.readByte();
    return a;
}
exports.readIntArray = readIntArray;
function readNumberArray(reader, type) {
    var stream = reader.stream;
    var count = ValueReader_1.readCount(stream);
    var a = new type(count);
    reader.addReference(a);
    var deserializer = NumberDeserializer_1.NumberDeserializer.instance;
    for (var i = 0; i < count; ++i) {
        a[i] = deserializer.deserialize(reader);
    }
    stream.readByte();
    return a;
}
exports.readNumberArray = readNumberArray;
var emptyInt8Array = new Int8Array(0);
var Int8ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Int8ArrayDeserializer, _super);
    function Int8ArrayDeserializer() {
        return _super.call(this, 'Int8Array') || this;
    }
    Int8ArrayDeserializer.prototype.read = function (reader, tag) {
        var bytes;
        switch (tag) {
            case 101 /* TagEmpty */: return emptyInt8Array;
            case 97 /* TagList */: return readIntArray(reader, Int8Array);
            case 98 /* TagBytes */:
                bytes = ReferenceReader_1.readBytes(reader);
                break;
            case 117 /* TagUTF8Char */:
                bytes = new ByteStream_1.ByteStream(reader.stream.readString(1)).bytes;
                break;
            case 115 /* TagString */:
                bytes = new ByteStream_1.ByteStream(ReferenceReader_1.readString(reader)).bytes;
                break;
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
        return new Int8Array(bytes.buffer, bytes.byteOffset, bytes.length);
    };
    Int8ArrayDeserializer.instance = new Int8ArrayDeserializer();
    return Int8ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Int8ArrayDeserializer = Int8ArrayDeserializer;
var emptyInt16Array = new Int16Array(0);
var Int16ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Int16ArrayDeserializer, _super);
    function Int16ArrayDeserializer() {
        return _super.call(this, 'Int16Array') || this;
    }
    Int16ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyInt16Array;
            case 97 /* TagList */: return readIntArray(reader, Int16Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Int16ArrayDeserializer.instance = new Int16ArrayDeserializer();
    return Int16ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Int16ArrayDeserializer = Int16ArrayDeserializer;
var emptyInt32Array = new Int32Array(0);
var Int32ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Int32ArrayDeserializer, _super);
    function Int32ArrayDeserializer() {
        return _super.call(this, 'Int32Array') || this;
    }
    Int32ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyInt32Array;
            case 97 /* TagList */: return readIntArray(reader, Int32Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Int32ArrayDeserializer.instance = new Int32ArrayDeserializer();
    return Int32ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Int32ArrayDeserializer = Int32ArrayDeserializer;
var emptyUint8Array = new Uint8Array(0);
var Uint8ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Uint8ArrayDeserializer, _super);
    function Uint8ArrayDeserializer() {
        return _super.call(this, 'Uint8Array') || this;
    }
    Uint8ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 98 /* TagBytes */: return ReferenceReader_1.readBytes(reader);
            case 101 /* TagEmpty */: return emptyUint8Array;
            case 97 /* TagList */: return readIntArray(reader, Uint8Array);
            case 117 /* TagUTF8Char */: return new ByteStream_1.ByteStream(reader.stream.readString(1)).bytes;
            case 115 /* TagString */: return new ByteStream_1.ByteStream(ReferenceReader_1.readString(reader)).bytes;
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Uint8Array) {
                    return result;
                }
                else {
                    return new ByteStream_1.ByteStream(result.toString()).bytes;
                }
            }
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Uint8ArrayDeserializer.instance = new Uint8ArrayDeserializer();
    return Uint8ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Uint8ArrayDeserializer = Uint8ArrayDeserializer;
var emptyUint8ClampedArray = new Uint8ClampedArray(0);
var Uint8ClampedArrayDeserializer = /** @class */ (function (_super) {
    __extends(Uint8ClampedArrayDeserializer, _super);
    function Uint8ClampedArrayDeserializer() {
        return _super.call(this, 'Uint8ClampedArray') || this;
    }
    Uint8ClampedArrayDeserializer.prototype.read = function (reader, tag) {
        var bytes;
        switch (tag) {
            case 101 /* TagEmpty */: return emptyUint8ClampedArray;
            case 97 /* TagList */: return readIntArray(reader, Uint8ClampedArray);
            case 98 /* TagBytes */:
                bytes = ReferenceReader_1.readBytes(reader);
                break;
            case 117 /* TagUTF8Char */:
                bytes = new ByteStream_1.ByteStream(reader.stream.readString(1)).bytes;
                break;
            case 115 /* TagString */:
                bytes = new ByteStream_1.ByteStream(ReferenceReader_1.readString(reader)).bytes;
                break;
            case 114 /* TagRef */: {
                var result = reader.readReference();
                if (result instanceof Uint8ClampedArray) {
                    return result;
                }
                if (result instanceof Uint8Array) {
                    bytes = result;
                }
                else {
                    bytes = new ByteStream_1.ByteStream(result.toString()).bytes;
                }
                break;
            }
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
        return new Uint8ClampedArray(bytes.buffer, bytes.byteOffset, bytes.length);
    };
    Uint8ClampedArrayDeserializer.instance = new Uint8ClampedArrayDeserializer();
    return Uint8ClampedArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Uint8ClampedArrayDeserializer = Uint8ClampedArrayDeserializer;
var emptyUint16Array = new Uint16Array(0);
var Uint16ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Uint16ArrayDeserializer, _super);
    function Uint16ArrayDeserializer() {
        return _super.call(this, 'Uint16Array') || this;
    }
    Uint16ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyUint16Array;
            case 97 /* TagList */: return readIntArray(reader, Uint16Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Uint16ArrayDeserializer.instance = new Uint16ArrayDeserializer();
    return Uint16ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Uint16ArrayDeserializer = Uint16ArrayDeserializer;
var emptyUint32Array = new Uint32Array(0);
var Uint32ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Uint32ArrayDeserializer, _super);
    function Uint32ArrayDeserializer() {
        return _super.call(this, 'Uint32Array') || this;
    }
    Uint32ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyUint32Array;
            case 97 /* TagList */: return readIntArray(reader, Uint32Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Uint32ArrayDeserializer.instance = new Uint32ArrayDeserializer();
    return Uint32ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Uint32ArrayDeserializer = Uint32ArrayDeserializer;
var emptyFloat32Array = new Float32Array(0);
var Float32ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Float32ArrayDeserializer, _super);
    function Float32ArrayDeserializer() {
        return _super.call(this, 'Float32Array') || this;
    }
    Float32ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyFloat32Array;
            case 97 /* TagList */: return readNumberArray(reader, Float32Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Float32ArrayDeserializer.instance = new Float32ArrayDeserializer();
    return Float32ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Float32ArrayDeserializer = Float32ArrayDeserializer;
var emptyFloat64Array = new Float64Array(0);
var Float64ArrayDeserializer = /** @class */ (function (_super) {
    __extends(Float64ArrayDeserializer, _super);
    function Float64ArrayDeserializer() {
        return _super.call(this, 'Float64Array') || this;
    }
    Float64ArrayDeserializer.prototype.read = function (reader, tag) {
        switch (tag) {
            case 101 /* TagEmpty */: return emptyFloat64Array;
            case 97 /* TagList */: return readNumberArray(reader, Float64Array);
            default:
                return _super.prototype.read.call(this, reader, tag);
        }
    };
    Float64ArrayDeserializer.instance = new Float64ArrayDeserializer();
    return Float64ArrayDeserializer;
}(BaseDeserializer_1.BaseDeserializer));
exports.Float64ArrayDeserializer = Float64ArrayDeserializer;
//# sourceMappingURL=TypedArrayDeserializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/index.js":
/*!**********************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| hprose.io.ts                                             |
|                                                          |
| @hprose/io for TypeScript.                               |
|                                                          |
| LastModified: Jan 22, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ./ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
exports.ByteStream = ByteStream_1.ByteStream;
exports.writeInt32BE = ByteStream_1.writeInt32BE;
exports.writeInt32LE = ByteStream_1.writeInt32LE;
exports.fromUint8Array = ByteStream_1.fromUint8Array;
exports.toBinaryString = ByteStream_1.toBinaryString;
var Writer_1 = __webpack_require__(/*! ./Writer */ "./real-server/node_modules/@hprose/io/lib/Writer.js");
exports.Writer = Writer_1.Writer;
var Reader_1 = __webpack_require__(/*! ./Reader */ "./real-server/node_modules/@hprose/io/lib/Reader.js");
exports.Reader = Reader_1.Reader;
var TypeManager = __importStar(__webpack_require__(/*! ./TypeManager */ "./real-server/node_modules/@hprose/io/lib/TypeManager.js"));
exports.TypeManager = TypeManager;
var Serializer = __importStar(__webpack_require__(/*! ./Serializer */ "./real-server/node_modules/@hprose/io/lib/Serializer.js"));
exports.Serializer = Serializer;
var Deserializer = __importStar(__webpack_require__(/*! ./Deserializer */ "./real-server/node_modules/@hprose/io/lib/Deserializer.js"));
exports.Deserializer = Deserializer;
var Formatter = __importStar(__webpack_require__(/*! ./Formatter */ "./real-server/node_modules/@hprose/io/lib/Formatter.js"));
exports.Formatter = Formatter;
var ReferenceReader = __importStar(__webpack_require__(/*! ./ReferenceReader */ "./real-server/node_modules/@hprose/io/lib/ReferenceReader.js"));
exports.ReferenceReader = ReferenceReader;
var ValueReader = __importStar(__webpack_require__(/*! ./ValueReader */ "./real-server/node_modules/@hprose/io/lib/ValueReader.js"));
exports.ValueReader = ValueReader;
var ValueWriter = __importStar(__webpack_require__(/*! ./ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js"));
exports.ValueWriter = ValueWriter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/ArraySerializer.js":
/*!********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/ArraySerializer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ArraySerializer.ts                                       |
|                                                          |
| hprose array serializer for TypeScript.                  |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ArraySerializer = /** @class */ (function (_super) {
    __extends(ArraySerializer, _super);
    function ArraySerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ArraySerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(97 /* TagList */);
        var n = value.length;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        for (var i = 0; i < n; i++) {
            writer.serialize(value[i]);
        }
        stream.writeByte(125 /* TagClosebrace */);
    };
    return ArraySerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.ArraySerializer = ArraySerializer;
//# sourceMappingURL=ArraySerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js":
/*!*******************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BaseSerializer.ts                                        |
|                                                          |
| hprose BaseSerializer for TypeScript.                    |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var BaseSerializer = /** @class */ (function () {
    function BaseSerializer() {
    }
    BaseSerializer.prototype.write = function (writer, value) {
        writer.stream.writeByte(110 /* TagNull */);
    };
    BaseSerializer.prototype.serialize = function (writer, value) {
        this.write(writer, value);
    };
    return BaseSerializer;
}());
exports.BaseSerializer = BaseSerializer;
//# sourceMappingURL=BaseSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/BigIntArraySerializer.js":
/*!**************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/BigIntArraySerializer.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BigIntArraySerializer.ts                                 |
|                                                          |
| hprose bigint array serializer for TypeScript.           |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var Serializer_1 = __webpack_require__(/*! ../Serializer */ "./real-server/node_modules/@hprose/io/lib/Serializer.js");
if ((typeof BigInt64Array !== 'undefined') && (typeof BigUint64Array !== 'undefined')) {
    var BigIntArraySerializer = /** @class */ (function (_super) {
        __extends(BigIntArraySerializer, _super);
        function BigIntArraySerializer() {
            return _super.call(this) || this;
        }
        BigIntArraySerializer.prototype.write = function (writer, value) {
            _super.prototype.write.call(this, writer, value);
            var stream = writer.stream;
            stream.writeByte(97 /* TagList */);
            var n = value.length;
            if (n > 0)
                stream.writeAsciiString('' + n);
            stream.writeByte(123 /* TagOpenbrace */);
            for (var i = 0; i < n; i++) {
                ValueWriter_1.writeBigInt(stream, value[i]);
            }
            stream.writeByte(125 /* TagClosebrace */);
        };
        return BigIntArraySerializer;
    }(ReferenceSerializer_1.ReferenceSerializer));
    var bigintArraySerializer = new BigIntArraySerializer();
    Serializer_1.register(BigInt64Array, bigintArraySerializer);
    Serializer_1.register(BigUint64Array, bigintArraySerializer);
}
//# sourceMappingURL=BigIntArraySerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/BigIntSerializer.js":
/*!*********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/BigIntSerializer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BigIntSerializer.ts                                      |
|                                                          |
| hprose bigint serializer for TypeScript.                 |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var BaseSerializer_1 = __webpack_require__(/*! ./BaseSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js");
var Serializer_1 = __webpack_require__(/*! ../Serializer */ "./real-server/node_modules/@hprose/io/lib/Serializer.js");
if (typeof BigInt !== 'undefined') {
    var BigIntSerializer = /** @class */ (function (_super) {
        __extends(BigIntSerializer, _super);
        function BigIntSerializer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BigIntSerializer.prototype.write = function (writer, value) {
            ValueWriter_1.writeBigInt(writer.stream, value);
        };
        return BigIntSerializer;
    }(BaseSerializer_1.BaseSerializer));
    Serializer_1.register(BigInt, new BigIntSerializer());
}
//# sourceMappingURL=BigIntSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/BooleanSerializer.js":
/*!**********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/BooleanSerializer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BooleanSerializer.ts                                     |
|                                                          |
| hprose boolean serializer for TypeScript.                |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseSerializer_1 = __webpack_require__(/*! ./BaseSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js");
var BooleanSerializer = /** @class */ (function (_super) {
    __extends(BooleanSerializer, _super);
    function BooleanSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BooleanSerializer.prototype.write = function (writer, value) {
        writer.stream.writeByte(value.valueOf() ? 116 /* TagTrue */ : 102 /* TagFalse */);
    };
    return BooleanSerializer;
}(BaseSerializer_1.BaseSerializer));
exports.BooleanSerializer = BooleanSerializer;
//# sourceMappingURL=BooleanSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/BytesSerializer.js":
/*!********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/BytesSerializer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| BytesSerializer.ts                                       |
|                                                          |
| hprose bytes serializer for TypeScript.                  |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var BytesSerializer = /** @class */ (function (_super) {
    __extends(BytesSerializer, _super);
    function BytesSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BytesSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(98 /* TagBytes */);
        var n = (value instanceof ArrayBuffer) ? value.byteLength : value.length;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(34 /* TagQuote */);
        stream.write(value);
        stream.writeByte(34 /* TagQuote */);
    };
    return BytesSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.BytesSerializer = BytesSerializer;
//# sourceMappingURL=BytesSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/DateSerializer.js":
/*!*******************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/DateSerializer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| DateSerializer.ts                                        |
|                                                          |
| hprose Date serializer for TypeScript.                   |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var DateSerializer = /** @class */ (function (_super) {
    __extends(DateSerializer, _super);
    function DateSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DateSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        writer.utc ? ValueWriter_1.writeUTCDate(stream, value) : ValueWriter_1.writeLocalDate(stream, value);
    };
    return DateSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.DateSerializer = DateSerializer;
//# sourceMappingURL=DateSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/DictionarySerializer.js":
/*!*************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/DictionarySerializer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| DictionarySerializer.ts                                  |
|                                                          |
| hprose dictionary serializer for TypeScript.             |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var DictionarySerializer = /** @class */ (function (_super) {
    __extends(DictionarySerializer, _super);
    function DictionarySerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DictionarySerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        var fields = [];
        if (value.hasOwnProperty === undefined) {
            for (var key in value) {
                if (typeof value[key] !== 'function') {
                    fields[fields.length] = key;
                }
            }
        }
        else {
            for (var key in value) {
                if (value.hasOwnProperty(key) && typeof value[key] !== 'function') {
                    fields[fields.length] = key;
                }
            }
        }
        var n = fields.length;
        stream.writeByte(109 /* TagMap */);
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        for (var i = 0; i < n; i++) {
            writer.serialize(fields[i]);
            writer.serialize(value[fields[i]]);
        }
        stream.writeByte(125 /* TagClosebrace */);
    };
    return DictionarySerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.DictionarySerializer = DictionarySerializer;
//# sourceMappingURL=DictionarySerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/ErrorSerializer.js":
/*!********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/ErrorSerializer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ErrorSerializer.ts                                       |
|                                                          |
| hprose error serializer for TypeScript.                  |
|                                                          |
| LastModified: Feb 8, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var ErrorSerializer = /** @class */ (function (_super) {
    __extends(ErrorSerializer, _super);
    function ErrorSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ErrorSerializer.prototype.write = function (writer, value) {
        // No reference to Error
        writer.addReferenceCount(1);
        var stream = writer.stream;
        stream.writeByte(69 /* TagError */);
        stream.writeByte(115 /* TagString */);
        ValueWriter_1.writeStringBody(stream, value.message);
    };
    return ErrorSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.ErrorSerializer = ErrorSerializer;
//# sourceMappingURL=ErrorSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/GuidSerializer.js":
/*!*******************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/GuidSerializer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| GuidSerializer.ts                                        |
|                                                          |
| hprose Guid serializer for TypeScript.                   |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var GuidSerializer = /** @class */ (function (_super) {
    __extends(GuidSerializer, _super);
    function GuidSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GuidSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(103 /* TagGuid */);
        stream.writeByte(123 /* TagOpenbrace */);
        stream.writeAsciiString(value.toString());
        stream.writeByte(125 /* TagClosebrace */);
    };
    return GuidSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.GuidSerializer = GuidSerializer;
//# sourceMappingURL=GuidSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/MapSerializer.js":
/*!******************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/MapSerializer.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MapSerializer.ts                                         |
|                                                          |
| hprose Map serializer for TypeScript.                    |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var MapSerializer = /** @class */ (function (_super) {
    __extends(MapSerializer, _super);
    function MapSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MapSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(109 /* TagMap */);
        var n = value.size;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        value.forEach(function (v, k) {
            writer.serialize(k);
            writer.serialize(v);
        });
        stream.writeByte(125 /* TagClosebrace */);
    };
    return MapSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.MapSerializer = MapSerializer;
//# sourceMappingURL=MapSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/NumberSerializer.js":
/*!*********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/NumberSerializer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| NumberSerializer.ts                                      |
|                                                          |
| hprose number serializer for TypeScript.                 |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseSerializer_1 = __webpack_require__(/*! ./BaseSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var NumberSerializer = /** @class */ (function (_super) {
    __extends(NumberSerializer, _super);
    function NumberSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NumberSerializer.prototype.write = function (writer, value) {
        value = value.valueOf();
        if (Number.isSafeInteger(value)) {
            ValueWriter_1.writeInteger(writer.stream, value);
        }
        else {
            ValueWriter_1.writeDouble(writer.stream, value);
        }
    };
    return NumberSerializer;
}(BaseSerializer_1.BaseSerializer));
exports.NumberSerializer = NumberSerializer;
//# sourceMappingURL=NumberSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/ObjectSerializer.js":
/*!*********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/ObjectSerializer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ObjectSerializer.ts                                      |
|                                                          |
| hprose object serializer for TypeScript.                 |
|                                                          |
| LastModified: Dec 18, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ByteStream_1 = __webpack_require__(/*! ../ByteStream */ "./real-server/node_modules/@hprose/io/lib/ByteStream.js");
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var ObjectSerializer = /** @class */ (function (_super) {
    __extends(ObjectSerializer, _super);
    function ObjectSerializer(obj, name, fields) {
        if (fields === void 0) { fields = []; }
        var _this = _super.call(this) || this;
        _this.type = obj.constructor;
        if (fields.length === 0) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key) && typeof obj[key] !== 'function') {
                    fields[fields.length] = key.toString();
                }
            }
        }
        _this.fields = fields;
        var stream = new ByteStream_1.ByteStream();
        stream.writeByte(99 /* TagClass */);
        ValueWriter_1.writeStringBody(stream, name);
        var n = fields.length;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        for (var i = 0; i < n; i++) {
            stream.writeByte(115 /* TagString */);
            ValueWriter_1.writeStringBody(stream, fields[i]);
        }
        stream.writeByte(125 /* TagClosebrace */);
        _this.metadata = stream.takeBytes();
        return _this;
    }
    ObjectSerializer.prototype.write = function (writer, value) {
        var stream = writer.stream;
        var fields = this.fields;
        var metadata = this.metadata;
        var n = fields.length;
        var r = writer.writeClass(this.type, function () {
            stream.write(metadata);
            writer.addReferenceCount(n);
        });
        _super.prototype.write.call(this, writer, value);
        stream.writeByte(111 /* TagObject */);
        stream.writeAsciiString('' + r);
        stream.writeByte(123 /* TagOpenbrace */);
        for (var i = 0; i < n; i++) {
            writer.serialize(value[fields[i]]);
        }
        stream.writeByte(125 /* TagClosebrace */);
    };
    return ObjectSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.ObjectSerializer = ObjectSerializer;
//# sourceMappingURL=ObjectSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js":
/*!************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ReferenceSerializer.ts                                   |
|                                                          |
| hprose reference serializer for TypeScript.              |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseSerializer_1 = __webpack_require__(/*! ./BaseSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/BaseSerializer.js");
var ReferenceSerializer = /** @class */ (function (_super) {
    __extends(ReferenceSerializer, _super);
    function ReferenceSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ReferenceSerializer.prototype.write = function (writer, value) {
        writer.setReference(value);
    };
    ReferenceSerializer.prototype.serialize = function (writer, value) {
        if (!writer.writeReference(value))
            this.write(writer, value);
    };
    return ReferenceSerializer;
}(BaseSerializer_1.BaseSerializer));
exports.ReferenceSerializer = ReferenceSerializer;
//# sourceMappingURL=ReferenceSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/SetSerializer.js":
/*!******************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/SetSerializer.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| SetSerializer.ts                                         |
|                                                          |
| hprose Set serializer for TypeScript.                    |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var SetSerializer = /** @class */ (function (_super) {
    __extends(SetSerializer, _super);
    function SetSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SetSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(97 /* TagList */);
        var n = value.size;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        value.forEach(function (v) { return writer.serialize(v); });
        stream.writeByte(125 /* TagClosebrace */);
    };
    return SetSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.SetSerializer = SetSerializer;
//# sourceMappingURL=SetSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/StringSerializer.js":
/*!*********************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/StringSerializer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| StringSerializer.ts                                      |
|                                                          |
| hprose string serializer for TypeScript.                 |
|                                                          |
| LastModified: Jan 11, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var ValueWriter_1 = __webpack_require__(/*! ../ValueWriter */ "./real-server/node_modules/@hprose/io/lib/ValueWriter.js");
var StringSerializer = /** @class */ (function (_super) {
    __extends(StringSerializer, _super);
    function StringSerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StringSerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(115 /* TagString */);
        ValueWriter_1.writeStringBody(stream, value);
    };
    StringSerializer.prototype.serialize = function (writer, value) {
        var stream = writer.stream;
        switch (value.length) {
            case 0:
                stream.writeByte(101 /* TagEmpty */);
                break;
            case 1:
                stream.writeByte(117 /* TagUTF8Char */);
                stream.writeString(value);
                break;
            default:
                _super.prototype.serialize.call(this, writer, value);
                break;
        }
    };
    return StringSerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.StringSerializer = StringSerializer;
//# sourceMappingURL=StringSerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/io/lib/serializers/TypedArraySerializer.js":
/*!*************************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/io/lib/serializers/TypedArraySerializer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| TypedArraySerializer.ts                                  |
|                                                          |
| hprose typed array serializer for TypeScript.            |
|                                                          |
| LastModified: Jan 6, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ReferenceSerializer_1 = __webpack_require__(/*! ./ReferenceSerializer */ "./real-server/node_modules/@hprose/io/lib/serializers/ReferenceSerializer.js");
var TypedArraySerializer = /** @class */ (function (_super) {
    __extends(TypedArraySerializer, _super);
    function TypedArraySerializer(writeNumber) {
        var _this = _super.call(this) || this;
        _this.writeNumber = writeNumber;
        return _this;
    }
    TypedArraySerializer.prototype.write = function (writer, value) {
        _super.prototype.write.call(this, writer, value);
        var stream = writer.stream;
        stream.writeByte(97 /* TagList */);
        var n = value.length;
        if (n > 0)
            stream.writeAsciiString('' + n);
        stream.writeByte(123 /* TagOpenbrace */);
        for (var i = 0; i < n; i++) {
            this.writeNumber(stream, value[i]);
        }
        stream.writeByte(125 /* TagClosebrace */);
    };
    return TypedArraySerializer;
}(ReferenceSerializer_1.ReferenceSerializer));
exports.TypedArraySerializer = TypedArraySerializer;
//# sourceMappingURL=TypedArraySerializer.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Client.js":
/*!*****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Client.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Client.ts                                                |
|                                                          |
| Client for TypeScript.                                   |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ClientCodec_1 = __webpack_require__(/*! ./ClientCodec */ "./real-server/node_modules/@hprose/rpc-core/lib/ClientCodec.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./real-server/node_modules/@hprose/rpc-core/lib/ClientContext.js");
var InvokeManager_1 = __webpack_require__(/*! ./InvokeManager */ "./real-server/node_modules/@hprose/rpc-core/lib/InvokeManager.js");
var IOManager_1 = __webpack_require__(/*! ./IOManager */ "./real-server/node_modules/@hprose/rpc-core/lib/IOManager.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./real-server/node_modules/@hprose/rpc-core/lib/Utils.js");
function makeInvoke(client, name) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        var context = (args.length > 0 && args[args.length - 1] instanceof ClientContext_1.ClientContext) ? args.pop() : new ClientContext_1.ClientContext();
        return client.invoke(name, args, context);
    };
}
function setMethods(client, service, namespace, name, methods) {
    if (service[name] !== undefined) {
        return;
    }
    service[name] = Object.create(null);
    if (!Array.isArray(methods)) {
        methods = [methods];
    }
    namespace = namespace + name + '_';
    for (var i = 0; i < methods.length; i++) {
        var node = methods[i];
        if (typeof node === 'string') {
            service[name][node] = makeInvoke(client, namespace + node);
        }
        else {
            for (var n in node) {
                setMethods(client, service[name], namespace, n, node[n]);
            }
        }
    }
}
function useService(client, functions) {
    var root = Utils_1.normalize(functions);
    var service = Object.create(null);
    for (var i = 0; i < root.length; i++) {
        var node = root[i];
        if (typeof node === 'string') {
            if (service[node] === undefined) {
                service[node] = makeInvoke(client, node);
            }
        }
        else {
            for (var name_1 in node) {
                setMethods(client, service, '', name_1, node[name_1]);
            }
        }
    }
    return service;
}
var ServiceProxyHandler = /** @class */ (function () {
    function ServiceProxyHandler(client, namespace) {
        this.client = client;
        this.namespace = namespace;
    }
    ServiceProxyHandler.prototype.get = function (target, p, receiver) {
        if (typeof p === 'symbol') {
            return undefined;
        }
        if (p === 'then') {
            return undefined;
        }
        if (!(p in target)) {
            target[p] = new Proxy(function () { }, new ServiceProxyHandler(this.client, this.namespace ? this.namespace + '_' + p : '' + p));
        }
        return target[p];
    };
    ServiceProxyHandler.prototype.apply = function (target, thisArg, args) {
        if (this.namespace) {
            var context = (args.length > 0 && args[args.length - 1] instanceof ClientContext_1.ClientContext) ? args.pop() : new ClientContext_1.ClientContext();
            return this.client.invoke(this.namespace, args, context);
        }
        throw new TypeError("target is not a function");
    };
    return ServiceProxyHandler;
}());
var Client = /** @class */ (function () {
    function Client(uri) {
        var _a;
        var _this = this;
        this.returnTypes = Object.create(null);
        this.requestHeaders = Object.create(null);
        this.codec = ClientCodec_1.DefaultClientCodec.instance;
        this.timeout = 30000;
        this.urilist = [];
        this.transports = Object.create(null);
        this.invokeManager = new InvokeManager_1.InvokeManager(this.call.bind(this));
        this.ioManager = new IOManager_1.IOManager(this.transport.bind(this));
        Client.transports.forEach(function (_a) {
            var name = _a.name, ctor = _a.ctor;
            var transport = new ctor();
            _this.transports[name] = transport;
            Object.defineProperty(_this, name, {
                get: function () { return transport; },
                set: function (value) {
                    transport = value;
                    _this.transports[name] = value;
                },
                enumerable: false,
                configurable: false
            });
        });
        if (uri) {
            if (typeof uri === 'string') {
                this.urilist.push(uri);
            }
            else {
                (_a = this.urilist).push.apply(_a, uri);
            }
        }
    }
    Client.register = function (name, ctor) {
        Client.transports.push({ name: name, ctor: ctor });
        ctor.schemes.forEach(function (scheme) { return Client.protocols[scheme + ':'] = name; });
    };
    Object.defineProperty(Client.prototype, "uris", {
        get: function () {
            return this.urilist;
        },
        set: function (value) {
            if (value.length > 0) {
                this.urilist = value.slice(0);
                this.urilist.sort(function () { return Math.random() - 0.5; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Client.prototype.useService = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var namespace;
        var returnTypes;
        switch (args.length) {
            case 1:
                if (Array.isArray(args[0])) {
                    return useService(this, args[0]);
                }
                else if (typeof args[0] === 'string') {
                    namespace = args[0];
                }
                else {
                    returnTypes = args[0];
                }
                break;
            case 2:
                namespace = args[0];
                returnTypes = args[1];
                break;
        }
        var service = Object.create(null);
        if (returnTypes) {
            for (var name_2 in returnTypes) {
                var fullname = '' + name_2;
                if (namespace) {
                    fullname = namespace + '_' + name_2;
                }
                this.returnTypes[fullname] = returnTypes[name_2];
                service[name_2] = makeInvoke(this, fullname);
            }
            return service;
        }
        return new Proxy(service, new ServiceProxyHandler(this, namespace));
    };
    Client.prototype.useServiceAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var names;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.invoke('~')];
                    case 1:
                        names = _a.sent();
                        return [2 /*return*/, useService(this, names)];
                }
            });
        });
    };
    Client.prototype.use = function () {
        var _a, _b;
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        if (handlers.length <= 0)
            return this;
        switch (handlers[0].length) {
            case 4:
                (_a = this.invokeManager).use.apply(_a, handlers);
                break;
            case 3:
                (_b = this.ioManager).use.apply(_b, handlers);
                break;
            default: throw new TypeError('Invalid parameter type');
        }
        return this;
    };
    Client.prototype.unuse = function () {
        var _a, _b;
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        if (handlers.length <= 0)
            return this;
        switch (handlers[0].length) {
            case 4:
                (_a = this.invokeManager).unuse.apply(_a, handlers);
                break;
            case 3:
                (_b = this.ioManager).unuse.apply(_b, handlers);
                break;
            default: throw new TypeError('Invalid parameter type');
        }
        return this;
    };
    Client.prototype.invoke = function (name, args, context) {
        if (args === void 0) { args = []; }
        if (context === void 0) { context = new ClientContext_1.ClientContext(); }
        return __awaiter(this, void 0, void 0, function () {
            var clientContext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (args === null) {
                            args = [];
                        }
                        if (!(args.length > 0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(args)];
                    case 1:
                        args = _a.sent();
                        _a.label = 2;
                    case 2:
                        clientContext = (context instanceof ClientContext_1.ClientContext) ? context : new ClientContext_1.ClientContext(context);
                        clientContext.init(this, this.returnTypes[name]);
                        return [2 /*return*/, this.invokeManager.handler(name, args, clientContext)];
                }
            });
        });
    };
    Client.prototype.call = function (name, args, context) {
        return __awaiter(this, void 0, void 0, function () {
            var codec, request, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        codec = this.codec;
                        request = codec.encode(name, args, context);
                        return [4 /*yield*/, this.request(request, context)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, codec.decode(response, context)];
                }
            });
        });
    };
    Client.prototype.request = function (request, context) {
        return this.ioManager.handler(request, context);
    };
    Client.prototype.transport = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, name;
            return __generator(this, function (_a) {
                uri = Utils_1.parseURI(context.uri);
                name = Client.protocols[uri.protocol];
                if (name !== undefined) {
                    return [2 /*return*/, this.transports[name].transport(request, context)];
                }
                throw new Error("The protocol \"" + uri.protocol + "\" is not supported.");
            });
        });
    };
    Client.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () {
            var results, name_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        results = [];
                        for (name_3 in this.transports) {
                            results.push(this.transports[name_3].abort());
                        }
                        return [4 /*yield*/, Promise.all(results)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Client.transports = [];
    Client.protocols = Object.create(null);
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=Client.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/ClientCodec.js":
/*!**********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/ClientCodec.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ClientCodec.ts                                           |
|                                                          |
| ClientCodec for TypeScript.                              |
|                                                          |
| LastModified: Jan 27, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var DefaultClientCodec = /** @class */ (function () {
    function DefaultClientCodec() {
        this.simple = false;
        this.utc = false;
        this.longType = 'number';
        this.dictType = 'object';
    }
    DefaultClientCodec.prototype.encode = function (name, args, context) {
        var stream = new io_1.ByteStream();
        var writer = new io_1.Writer(stream, this.simple, this.utc);
        var headers = context.requestHeaders;
        if (this.simple) {
            headers.simple = true;
        }
        var size = 0;
        for (var _ in headers) {
            size++;
        }
        if (size > 0) {
            stream.writeByte(72 /* TagHeader */);
            writer.serialize(headers);
            writer.reset();
        }
        stream.writeByte(67 /* TagCall */);
        writer.serialize(name);
        if (args.length > 0) {
            writer.reset();
            writer.serialize(args);
        }
        stream.writeByte(122 /* TagEnd */);
        return stream.takeBytes();
    };
    DefaultClientCodec.prototype.decode = function (response, context) {
        var stream = new io_1.ByteStream(response);
        var reader = new io_1.Reader(stream, false);
        reader.longType = this.longType;
        reader.dictType = this.dictType;
        var tag = stream.readByte();
        if (tag === 72 /* TagHeader */) {
            var headers = reader.deserialize();
            for (var name_1 in headers) {
                context.responseHeaders[name_1] = headers[name_1];
            }
            reader.reset();
            tag = stream.readByte();
        }
        switch (tag) {
            case 82 /* TagResult */:
                if (context.responseHeaders.simple) {
                    reader.simple = true;
                }
                return reader.deserialize(context.returnType);
            case 69 /* TagError */:
                throw new Error(reader.deserialize(String));
            case 122 /* TagEnd */:
                return context.type === null ? null : undefined;
            default:
                throw new Error('Invalid response:\r\n' + stream.toString());
        }
    };
    DefaultClientCodec.instance = new DefaultClientCodec();
    return DefaultClientCodec;
}());
exports.DefaultClientCodec = DefaultClientCodec;
//# sourceMappingURL=ClientCodec.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/ClientContext.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/ClientContext.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ClientContext.ts                                         |
|                                                          |
| ClientContext for TypeScript.                            |
|                                                          |
| LastModified: Dec 30, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Context_1 = __webpack_require__(/*! ./Context */ "./real-server/node_modules/@hprose/rpc-core/lib/Context.js");
var ClientContext = /** @class */ (function (_super) {
    __extends(ClientContext, _super);
    function ClientContext(items) {
        var _this = _super.call(this) || this;
        if (!!items) {
            _this.copy(items, _this);
            if ('requestHeaders' in items) {
                _this.copy(items['requestHeaders'], _this.requestHeaders);
            }
        }
        return _this;
    }
    ClientContext.prototype.init = function (client, returnType) {
        this.client = client;
        if (client.uris.length > 0)
            this.uri = client.uris[0];
        if (this.returnType === undefined)
            this.returnType = returnType;
        if (this.timeout === undefined)
            this.timeout = client.timeout;
        this.copy(client.requestHeaders, this.requestHeaders);
    };
    return ClientContext;
}(Context_1.Context));
exports.ClientContext = ClientContext;
//# sourceMappingURL=ClientContext.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Context.js":
/*!******************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Context.ts                                               |
|                                                          |
| Context for TypeScript.                                  |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var Context = /** @class */ (function () {
    function Context() {
        this.requestHeaders = Object.create(null);
        this.responseHeaders = Object.create(null);
    }
    Context.prototype.copy = function (src, dist) {
        if (src) {
            for (var name_1 in src) {
                if ((name_1 !== 'requestHeaders') &&
                    (name_1 !== 'responseHeaders') &&
                    (!src.hasOwnProperty || src.hasOwnProperty(name_1))) {
                    dist[name_1] = src[name_1];
                }
            }
        }
    };
    Context.prototype.clone = function () {
        var result = Object.create(this.constructor.prototype);
        this.copy(this, result);
        this.copy(this.requestHeaders, result.requestHeaders);
        this.copy(this.responseHeaders, result.responseHeaders);
        return result;
    };
    return Context;
}());
exports.Context = Context;
//# sourceMappingURL=Context.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/CookieManager.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/CookieManager.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| CookieManager.ts                                         |
|                                                          |
| CookieManager for TypeScript.                            |
|                                                          |
| LastModified: Dec 18, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var cookieManager = Object.create(null);
function setCookie(headers, host) {
    if (host === void 0) { host = '@'; }
    function _setCookie(value) {
        var _a;
        if (value === undefined)
            return;
        var cookies = value.trim().split(';');
        var cookie = Object.create(null);
        _a = cookies[0].trim().split('=', 2), cookie.name = _a[0], cookie.value = _a[1];
        for (var i = 1; i < cookies.length; i++) {
            var _b = cookies[i].trim().split('=', 2), k = _b[0], v = _b[1];
            cookie[k.toUpperCase()] = v;
        }
        // Tomcat can return SetCookie2 with path wrapped in "
        if (cookie.PATH) {
            var n = cookie.PATH.length;
            if (n > 2 && cookie.PATH.charAt(0) === '"' && cookie.PATH.charAt(n - 1) === '"') {
                cookie.PATH = cookie.PATH.substr(1, n - 2);
            }
        }
        else {
            cookie.PATH = '/';
        }
        if (cookie.EXPIRES) {
            cookie.EXPIRES = Date.parse(cookie.EXPIRES);
        }
        if (cookie.DOMAIN) {
            cookie.DOMAIN = cookie.DOMAIN.toLowerCase();
        }
        else {
            cookie.DOMAIN = host;
        }
        cookie.SECURE = (cookie.SECURE !== undefined);
        if (cookieManager[cookie.DOMAIN] === undefined) {
            cookieManager[cookie.DOMAIN] = Object.create(null);
        }
        cookieManager[cookie.DOMAIN][cookie.name] = cookie;
    }
    for (var name_1 in headers) {
        name_1 = name_1.toLowerCase();
        if ((name_1 === 'set-cookie') || (name_1 === 'set-cookie2')) {
            var value = headers[name_1];
            (Array.isArray(value) ? value : [value]).forEach(_setCookie);
        }
    }
}
exports.setCookie = setCookie;
function getCookie(host, path, secure) {
    host = (host !== null && host !== void 0 ? host : '@');
    path = (path !== null && path !== void 0 ? path : '/');
    var cookies = [];
    for (var domain in cookieManager) {
        if (host.indexOf(domain) > -1) {
            var names = [];
            for (var name_2 in cookieManager[domain]) {
                var cookie = cookieManager[domain][name_2];
                if (cookie.EXPIRES && ((new Date()).getTime() > cookie.EXPIRES)) {
                    names.push(name_2);
                }
                else if (path.indexOf(cookie.PATH) === 0) {
                    if ((secure === cookie.SECURE) && (cookie.value !== null)) {
                        cookies.push(cookie.name + '=' + cookie.value);
                    }
                }
            }
            for (var i = 0, n = names.length; i < n; ++i) {
                delete cookieManager[domain][names[i]];
            }
        }
    }
    if (cookies.length > 0) {
        return cookies.join('; ');
    }
    return '';
}
exports.getCookie = getCookie;
//# sourceMappingURL=CookieManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Deferred.js":
/*!*******************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Deferred.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Deferred.ts                                              |
|                                                          |
| Deferred for TypeScript.                                 |
|                                                          |
| LastModified: Jan 10, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
function defer() {
    var deferred = Object.create(null);
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
exports.defer = defer;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/IOManager.js":
/*!********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/IOManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| IOManager.ts                                             |
|                                                          |
| IOManager for TypeScript.                                |
|                                                          |
| LastModified: Feb 16, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var PluginManager_1 = __webpack_require__(/*! ./PluginManager */ "./real-server/node_modules/@hprose/rpc-core/lib/PluginManager.js");
var IOManager = /** @class */ (function (_super) {
    __extends(IOManager, _super);
    function IOManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IOManager.prototype.getNextHandler = function (handler, next) {
        return function (request, context) { return handler(request, context, next); };
    };
    return IOManager;
}(PluginManager_1.PluginManager));
exports.IOManager = IOManager;
//# sourceMappingURL=IOManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/InvokeManager.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/InvokeManager.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| InvokeManager.ts                                         |
|                                                          |
| InvokeManager for TypeScript.                            |
|                                                          |
| LastModified: Feb 16, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var PluginManager_1 = __webpack_require__(/*! ./PluginManager */ "./real-server/node_modules/@hprose/rpc-core/lib/PluginManager.js");
var InvokeManager = /** @class */ (function (_super) {
    __extends(InvokeManager, _super);
    function InvokeManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InvokeManager.prototype.getNextHandler = function (handler, next) {
        return function (name, args, context) { return handler(name, args, context, next); };
    };
    return InvokeManager;
}(PluginManager_1.PluginManager));
exports.InvokeManager = InvokeManager;
//# sourceMappingURL=InvokeManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Method.js":
/*!*****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Method.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Method.ts                                                |
|                                                          |
| Method for TypeScript.                                   |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var Method = /** @class */ (function () {
    function Method(method, name, target, paramTypes) {
        this.method = method;
        this.name = name;
        this.target = target;
        this.paramTypes = paramTypes;
        if (name === '' || name === undefined) {
            if (method.name === '') {
                throw new Error('name must not be empty');
            }
            name = method.name;
        }
    }
    return Method;
}());
exports.Method = Method;
//# sourceMappingURL=Method.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/MethodManager.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/MethodManager.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MethodManager.ts                                         |
|                                                          |
| MethodManager for TypeScript.                            |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var Method_1 = __webpack_require__(/*! ./Method */ "./real-server/node_modules/@hprose/rpc-core/lib/Method.js");
var MethodManager = /** @class */ (function () {
    function MethodManager() {
        this.methods = Object.create(null);
        this.names = [];
    }
    MethodManager.prototype.getNames = function () {
        return this.names;
    };
    MethodManager.prototype.get = function (name) {
        name = name.toLowerCase();
        return (name in this.methods) ? this.methods[name] : this.methods['*'];
    };
    MethodManager.prototype.remove = function (name) {
        delete this.methods[name.toLowerCase()];
        var index = this.names.indexOf(name);
        if (index > -1) {
            this.names.splice(index, 1);
        }
    };
    MethodManager.prototype.add = function (method) {
        var name = method.name;
        if (name === '' || name === undefined) {
            name = method.fullname;
            if (name === '' || name === undefined) {
                name = method.method.name;
                if (name === '') {
                    throw new Error('name must not be empty');
                }
            }
            method.name = name;
        }
        this.methods[name.toLowerCase()] = method;
        if (this.names.indexOf(name) === -1) {
            this.names.push(name);
        }
    };
    MethodManager.prototype.addFunction = function (fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        switch (args.length) {
            case 0:
                this.add(new Method_1.Method(fn));
                break;
            case 1:
                if (typeof args[0] === 'string') {
                    this.add(new Method_1.Method(fn, args[0]));
                }
                else {
                    this.add(new Method_1.Method(fn, undefined, undefined, args[0]));
                }
                break;
            case 2:
                this.add(new Method_1.Method(fn, args[0], undefined, args[1]));
                break;
        }
    };
    MethodManager.prototype.addMethod = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (typeof args[0] === 'string') {
            var method = args[1][args[0]];
            if (typeof method === 'function') {
                this.add(new Method_1.Method(method, args[0], args[1], args[2]));
            }
            else {
                throw new Error('obj[name] must be a function');
            }
        }
        else {
            switch (args.length) {
                case 2:
                    this.add(new Method_1.Method(args[0], undefined, args[1]));
                    break;
                case 3:
                    if (typeof args[2] === 'string') {
                        this.add(new Method_1.Method(args[0], args[2], args[1]));
                    }
                    else {
                        this.add(new Method_1.Method(args[0], undefined, args[1], args[2]));
                    }
                    break;
                case 4:
                    this.add(new Method_1.Method(args[0], args[2], args[1], args[3]));
            }
        }
    };
    MethodManager.prototype.addMissingMethod = function (fn, target) {
        var method = new Method_1.Method(fn, '*', target);
        method.missing = true;
        if (fn.length === 3) {
            method.passContext = true;
        }
        this.add(method);
    };
    MethodManager.prototype.addFunctions = function (functions) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var names;
        var paramTypes;
        switch (args.length) {
            case 1:
                if ((args[0].length > 1) && (typeof args[0][0] === 'string')) {
                    names = args[0];
                }
                else {
                    paramTypes = args[0];
                }
                break;
            case 2:
                names = args[0];
                paramTypes = args[1];
                break;
        }
        var n = functions.length;
        if (names && names.length !== n) {
            throw new Error('names.length must be equal to functions.length');
        }
        for (var i = 0; i < n; ++i) {
            this.add(new Method_1.Method(functions[i], names ? names[i] : undefined, undefined, paramTypes));
        }
    };
    MethodManager.prototype.addMethods = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var n = args[0].length;
        if (n === 0)
            return;
        var methods;
        var target = args[1];
        var names;
        var paramTypes;
        if (typeof args[0][0] === 'string') {
            names = args[0];
            paramTypes = args[2];
            for (var i = 0; i < n; ++i) {
                var method = target[names[i]];
                if (typeof method === 'function') {
                    this.add(new Method_1.Method(method, names[i], target, paramTypes));
                }
                else {
                    throw new Error('obj[name] must be a function');
                }
            }
            return;
        }
        else {
            methods = args[0];
        }
        switch (args.length) {
            case 3:
                if (args[2].length > 0 && typeof args[2][0] === 'string') {
                    names = args[2];
                }
                else {
                    paramTypes = args[2];
                }
                break;
            case 4:
                names = args[2];
                paramTypes = args[3];
        }
        if (names && names.length !== n) {
            throw new Error('names.length must be equal to functions.length');
        }
        for (var i = 0; i < n; ++i) {
            this.add(new Method_1.Method(methods[i], names ? names[i] : undefined, target, paramTypes));
        }
    };
    MethodManager.prototype.addInstanceMethods = function (target, namespace) {
        for (var name_1 in target) {
            if ((!target.hasOwnProperty || target.hasOwnProperty(name_1)) && typeof target[name_1] === 'function') {
                var fullname = namespace ? namespace + '_' + name_1 : name_1;
                this.add(new Method_1.Method(target[name_1], fullname, target));
            }
        }
    };
    return MethodManager;
}());
exports.MethodManager = MethodManager;
//# sourceMappingURL=MethodManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/MockAgent.js":
/*!********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/MockAgent.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MockAgent.ts                                             |
|                                                          |
| MockAgent for TypeScript.                                |
|                                                          |
| LastModified: Feb 27, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var MockAgent = /** @class */ (function () {
    function MockAgent() {
    }
    MockAgent.register = function (address, handler) {
        MockAgent.handlers[address] = handler;
    };
    MockAgent.cancel = function (address) {
        delete MockAgent.handlers[address];
    };
    MockAgent.handler = function (address, request) {
        return __awaiter(this, void 0, void 0, function () {
            var handler;
            return __generator(this, function (_a) {
                handler = MockAgent.handlers[address];
                if (handler) {
                    return [2 /*return*/, handler(address, request)];
                }
                throw new Error('Server is stopped');
            });
        });
    };
    MockAgent.handlers = Object.create(null);
    return MockAgent;
}());
exports.MockAgent = MockAgent;
//# sourceMappingURL=MockAgent.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/MockHandler.js":
/*!**********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/MockHandler.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MockHandler.ts                                           |
|                                                          |
| MockHandler for TypeScript.                              |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ServiceContext_1 = __webpack_require__(/*! ./ServiceContext */ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceContext.js");
var Service_1 = __webpack_require__(/*! ./Service */ "./real-server/node_modules/@hprose/rpc-core/lib/Service.js");
var MockAgent_1 = __webpack_require__(/*! ./MockAgent */ "./real-server/node_modules/@hprose/rpc-core/lib/MockAgent.js");
var MockServer = /** @class */ (function () {
    function MockServer(address) {
        this.address = address;
    }
    MockServer.prototype.close = function () {
        MockAgent_1.MockAgent.cancel(this.address);
    };
    return MockServer;
}());
exports.MockServer = MockServer;
var MockHandler = /** @class */ (function () {
    function MockHandler(service) {
        var _this = this;
        this.service = service;
        this.handler = function (address, request) { return __awaiter(_this, void 0, void 0, function () {
            var context, addressInfo;
            return __generator(this, function (_a) {
                if (request.length > this.service.maxRequestLength) {
                    throw new Error('Request entity too large');
                }
                context = new ServiceContext_1.ServiceContext(this.service);
                addressInfo = { 'family': 'mock', 'address': address, 'port': 0 };
                context.remoteAddress = addressInfo;
                context.localAddress = addressInfo;
                context.handler = this;
                return [2 /*return*/, this.service.handle(request, context)];
            });
        }); };
    }
    MockHandler.prototype.bind = function (server) {
        MockAgent_1.MockAgent.register(server.address, this.handler);
    };
    MockHandler.serverTypes = [MockServer];
    return MockHandler;
}());
exports.MockHandler = MockHandler;
Service_1.Service.register('mock', MockHandler);
//# sourceMappingURL=MockHandler.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/MockTransport.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/MockTransport.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MockTransport.ts                                         |
|                                                          |
| MockTransport for TypeScript.                            |
|                                                          |
| LastModified: Feb 27, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Client_1 = __webpack_require__(/*! ./Client */ "./real-server/node_modules/@hprose/rpc-core/lib/Client.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./real-server/node_modules/@hprose/rpc-core/lib/Utils.js");
var MockAgent_1 = __webpack_require__(/*! ./MockAgent */ "./real-server/node_modules/@hprose/rpc-core/lib/MockAgent.js");
var Deferred_1 = __webpack_require__(/*! ./Deferred */ "./real-server/node_modules/@hprose/rpc-core/lib/Deferred.js");
var TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./real-server/node_modules/@hprose/rpc-core/lib/TimeoutError.js");
var MockTransport = /** @class */ (function () {
    function MockTransport() {
    }
    MockTransport.prototype.transport = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, result, timeoutId_1;
            return __generator(this, function (_a) {
                uri = Utils_1.parseURI(context.uri);
                result = Deferred_1.defer();
                if (context.timeout > 0) {
                    timeoutId_1 = setTimeout(function () {
                        result.reject(new TimeoutError_1.TimeoutError());
                    }, context.timeout);
                    result.promise.then(function () {
                        clearTimeout(timeoutId_1);
                    }, function () {
                        clearTimeout(timeoutId_1);
                    });
                }
                MockAgent_1.MockAgent.handler(uri.hostname, request).then(function (value) { return result.resolve(value); }, function (reason) { return result.reject(reason); });
                return [2 /*return*/, result.promise];
            });
        });
    };
    MockTransport.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    MockTransport.schemes = ['mock'];
    return MockTransport;
}());
exports.MockTransport = MockTransport;
Client_1.Client.register('mock', MockTransport);
//# sourceMappingURL=MockTransport.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/PluginManager.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/PluginManager.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| PluginManager.ts                                         |
|                                                          |
| PluginManager for TypeScript.                            |
|                                                          |
| LastModified: Feb 16, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var PluginManager = /** @class */ (function () {
    function PluginManager(defaultHandler) {
        this.defaultHandler = defaultHandler;
        this.handlers = [];
        this.firstHandler = defaultHandler;
    }
    PluginManager.prototype.rebuildHandler = function () {
        var handlers = this.handlers;
        var next = this.defaultHandler;
        var n = handlers.length;
        for (var i = n - 1; i >= 0; --i) {
            next = this.getNextHandler(handlers[i], next);
        }
        this.firstHandler = next;
    };
    Object.defineProperty(PluginManager.prototype, "handler", {
        get: function () {
            return this.firstHandler;
        },
        enumerable: true,
        configurable: true
    });
    PluginManager.prototype.use = function () {
        var _a;
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        (_a = this.handlers).push.apply(_a, handlers);
        this.rebuildHandler();
    };
    PluginManager.prototype.unuse = function () {
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        var rebuild = false;
        for (var i = 0, n = handlers.length; i < n; ++i) {
            var index = this.handlers.indexOf(handlers[i]);
            if (index >= 0) {
                this.handlers.splice(index, 1);
                rebuild = true;
            }
        }
        if (rebuild)
            this.rebuildHandler();
    };
    return PluginManager;
}());
exports.PluginManager = PluginManager;
//# sourceMappingURL=PluginManager.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Service.js":
/*!******************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Service.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Service.ts                                               |
|                                                          |
| Service for TypeScript.                                  |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ServiceCodec_1 = __webpack_require__(/*! ./ServiceCodec */ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceCodec.js");
var InvokeManager_1 = __webpack_require__(/*! ./InvokeManager */ "./real-server/node_modules/@hprose/rpc-core/lib/InvokeManager.js");
var IOManager_1 = __webpack_require__(/*! ./IOManager */ "./real-server/node_modules/@hprose/rpc-core/lib/IOManager.js");
var Method_1 = __webpack_require__(/*! ./Method */ "./real-server/node_modules/@hprose/rpc-core/lib/Method.js");
var MethodManager_1 = __webpack_require__(/*! ./MethodManager */ "./real-server/node_modules/@hprose/rpc-core/lib/MethodManager.js");
var Service = /** @class */ (function () {
    function Service() {
        var _this = this;
        this.codec = ServiceCodec_1.DefaultServiceCodec.instance;
        this.maxRequestLength = 0x7FFFFFFF;
        this.invokeManager = new InvokeManager_1.InvokeManager(this.execute.bind(this));
        this.ioManager = new IOManager_1.IOManager(this.process.bind(this));
        this.methodManager = new MethodManager_1.MethodManager();
        this.handlers = Object.create(null);
        this.options = Object.create(null);
        var _loop_1 = function (name_1) {
            var ctor = Service.handlers[name_1];
            var handler = new ctor(this_1);
            this_1.handlers[name_1] = handler;
            Object.defineProperty(this_1, name_1, {
                get: function () { return handler; },
                set: function (value) {
                    handler = value;
                    _this.handlers[name_1] = value;
                },
                enumerable: true,
                configurable: true
            });
        };
        var this_1 = this;
        for (var name_1 in Service.handlers) {
            _loop_1(name_1);
        }
        this.add(new Method_1.Method(this.methodManager.getNames.bind(this.methodManager), '~'));
    }
    Service.register = function (name, ctor) {
        Service.handlers[name] = ctor;
        ctor.serverTypes.forEach(function (type) {
            if (Service.serverTypes.has(type)) {
                Service.serverTypes.get(type).push(name);
            }
            else {
                Service.serverTypes.set(type, [name]);
            }
        });
    };
    Object.defineProperty(Service.prototype, "names", {
        get: function () {
            return this.methodManager.getNames();
        },
        enumerable: true,
        configurable: true
    });
    Service.prototype.bind = function (server, name) {
        var type = server.constructor;
        var serverTypes = Service.serverTypes;
        if (serverTypes.has(type)) {
            var names = serverTypes.get(type);
            for (var i = 0, n = names.length; i < n; ++i) {
                if ((name === undefined) || (name === names[i])) {
                    this.handlers[names[i]].bind(server);
                }
            }
        }
        else {
            throw new Error('This type server is not supported.');
        }
        return this;
    };
    Service.prototype.handle = function (request, context) {
        return this.ioManager.handler(request, context);
    };
    Service.prototype.process = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var codec, result, _a, name_2, args, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        codec = this.codec;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = codec.decode(request, context), name_2 = _a[0], args = _a[1];
                        return [4 /*yield*/, this.invokeManager.handler(name_2, args, context)];
                    case 2:
                        result = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        result = e_1;
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, codec.encode(result, context)];
                }
            });
        });
    };
    Service.prototype.execute = function (name, args, context) {
        return __awaiter(this, void 0, void 0, function () {
            var method, func;
            return __generator(this, function (_a) {
                method = context.method;
                func = method.method;
                if (method.missing) {
                    if (method.passContext) {
                        return [2 /*return*/, func.apply(method.target, [name, args, context])];
                    }
                    return [2 /*return*/, func.apply(method.target, [name, args])];
                }
                if (method.passContext) {
                    args.push(context);
                }
                return [2 /*return*/, func.apply(method.target, args)];
            });
        });
    };
    Service.prototype.use = function () {
        var _a, _b;
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        if (handlers.length <= 0)
            return this;
        switch (handlers[0].length) {
            case 4:
                (_a = this.invokeManager).use.apply(_a, handlers);
                break;
            case 3:
                (_b = this.ioManager).use.apply(_b, handlers);
                break;
            default: throw new TypeError('Invalid parameter type');
        }
        return this;
    };
    Service.prototype.unuse = function () {
        var _a, _b;
        var handlers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            handlers[_i] = arguments[_i];
        }
        if (handlers.length <= 0)
            return this;
        switch (handlers[0].length) {
            case 4:
                (_a = this.invokeManager).unuse.apply(_a, handlers);
                break;
            case 3:
                (_b = this.ioManager).unuse.apply(_b, handlers);
                break;
            default: throw new TypeError('Invalid parameter type');
        }
        return this;
    };
    Service.prototype.get = function (name) {
        return this.methodManager.get(name);
    };
    Service.prototype.add = function (method) {
        this.methodManager.add(method);
        return this;
    };
    Service.prototype.remove = function (name) {
        this.methodManager.remove(name);
        return this;
    };
    Service.prototype.addFunction = function (fn) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.methodManager).addFunction.apply(_a, __spreadArrays([fn], args));
        return this;
    };
    Service.prototype.addMethod = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.methodManager).addMethod.apply(_a, __spreadArrays([args[0], args[1]], args.slice(2)));
        return this;
    };
    Service.prototype.addMissingMethod = function (fn, target) {
        this.methodManager.addMissingMethod(fn, target);
        return this;
    };
    Service.prototype.addFunctions = function (functions) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = this.methodManager).addFunctions.apply(_a, __spreadArrays([functions], args));
        return this;
    };
    Service.prototype.addMethods = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.methodManager).addMethods.apply(_a, __spreadArrays([args[0], args[1]], args.slice(2)));
        return this;
    };
    Service.prototype.addInstanceMethods = function (target, prefix) {
        this.methodManager.addInstanceMethods(target, prefix);
        return this;
    };
    Service.handlers = Object.create(null);
    Service.serverTypes = new Map();
    return Service;
}());
exports.Service = Service;
//# sourceMappingURL=Service.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceCodec.js":
/*!***********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/ServiceCodec.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ServiceCodec.ts                                          |
|                                                          |
| ServiceCodec for TypeScript.                             |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var DefaultServiceCodec = /** @class */ (function () {
    function DefaultServiceCodec() {
        this.debug = false;
        this.simple = false;
        this.utc = false;
        this.longType = 'number';
        this.dictType = 'object';
        this.nullType = undefined;
    }
    DefaultServiceCodec.prototype.encode = function (result, context) {
        var stream = new io_1.ByteStream();
        var writer = new io_1.Writer(stream, this.simple, this.utc);
        var headers = context.responseHeaders;
        if (this.simple) {
            headers.simple = true;
        }
        var size = 0;
        for (var _ in headers) {
            size++;
        }
        if (size > 0) {
            stream.writeByte(72 /* TagHeader */);
            writer.serialize(headers);
            writer.reset();
        }
        if (result instanceof Error) {
            stream.writeByte(69 /* TagError */);
            writer.serialize(this.debug ? result.stack ? result.stack : result.message : result.message);
        }
        else {
            stream.writeByte(82 /* TagResult */);
            writer.serialize(result);
        }
        stream.writeByte(122 /* TagEnd */);
        return stream.takeBytes();
    };
    DefaultServiceCodec.prototype.decodeMethod = function (name, context) {
        var service = context.service;
        var method = service.get(name);
        if (method === undefined) {
            throw new Error('Can\'t find this method ' + name + '().');
        }
        context.method = method;
        return method;
    };
    DefaultServiceCodec.prototype.decodeArguments = function (method, reader, context) {
        var stream = reader.stream;
        var tag = stream.readByte();
        if (method.missing) {
            if (tag === 97 /* TagList */) {
                reader.reset();
                return reader.read(tag, Array);
            }
            return [];
        }
        var args = [];
        if (tag === 97 /* TagList */) {
            reader.reset();
            var count = io_1.ValueReader.readCount(stream);
            var paramTypes = method.paramTypes;
            if (paramTypes === undefined) {
                paramTypes = new Array(count).fill(this.nullType);
            }
            else {
                paramTypes.length = count;
                for (var i = 0; i < count; ++i) {
                    if (paramTypes[i] === undefined) {
                        paramTypes[i] = this.nullType;
                    }
                }
            }
            args = new Array(count);
            reader.addReference(args);
            for (var i = 0; i < count; ++i) {
                args[i] = reader.deserialize(paramTypes[i]);
            }
            stream.readByte();
        }
        return args;
    };
    DefaultServiceCodec.prototype.decode = function (request, context) {
        if (request.length === 0) {
            this.decodeMethod('~', context);
            return ['~', []];
        }
        var stream = new io_1.ByteStream(request);
        var reader = new io_1.Reader(stream, false);
        reader.longType = this.longType;
        reader.dictType = this.dictType;
        var tag = stream.readByte();
        if (tag === 72 /* TagHeader */) {
            var headers = reader.deserialize(this.nullType);
            for (var name_1 in headers) {
                context.requestHeaders[name_1] = headers[name_1];
            }
            reader.reset();
            tag = stream.readByte();
        }
        switch (tag) {
            case 67 /* TagCall */:
                if (context.requestHeaders.simple) {
                    reader.simple = true;
                }
                var name_2 = reader.deserialize(String);
                var args = this.decodeArguments(this.decodeMethod(name_2, context), reader, context);
                return [name_2, args];
            case 122 /* TagEnd */:
                this.decodeMethod('~', context);
                return ['~', []];
            default:
                throw new Error('Invalid request:\r\n' + stream.toString());
        }
    };
    DefaultServiceCodec.instance = new DefaultServiceCodec();
    return DefaultServiceCodec;
}());
exports.DefaultServiceCodec = DefaultServiceCodec;
//# sourceMappingURL=ServiceCodec.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceContext.js":
/*!*************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/ServiceContext.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ServiceContext.ts                                        |
|                                                          |
| ServiceContext for TypeScript.                           |
|                                                          |
| LastModified: Dec 30, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Context_1 = __webpack_require__(/*! ./Context */ "./real-server/node_modules/@hprose/rpc-core/lib/Context.js");
var ServiceContext = /** @class */ (function (_super) {
    __extends(ServiceContext, _super);
    function ServiceContext(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    return ServiceContext;
}(Context_1.Context));
exports.ServiceContext = ServiceContext;
//# sourceMappingURL=ServiceContext.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/TimeoutError.js":
/*!***********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/TimeoutError.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| TimeoutError.ts                                          |
|                                                          |
| TimeoutError for TypeScript.                             |
|                                                          |
| LastModified: Dec 26, 2018                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message) {
        if (message === void 0) { message = 'timeout'; }
        return _super.call(this, message) || this;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/Utils.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/Utils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| Utils.ts                                                 |
|                                                          |
| Utils for TypeScript.                                    |
|                                                          |
| LastModified: Jan 9, 2019                                |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
function parseURI(uri) {
    var pattern = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?');
    var matches = uri.match(pattern);
    if (matches) {
        var host = matches[4].split(':', 2);
        return {
            protocol: matches[1],
            host: matches[4],
            hostname: host[0],
            port: parseInt(host[1], 10) || 0,
            path: matches[5],
            query: matches[7],
            fragment: matches[9]
        };
    }
    throw new Error('Invalid URI');
}
exports.parseURI = parseURI;
function normalize(functions) {
    var root = [Object.create(null)];
    for (var i = 0, n = functions.length; i < n; ++i) {
        var func = functions[i].split('_');
        var n_1 = func.length - 1;
        if (n_1 > 0) {
            var node = root;
            for (var j = 0; j < n_1; j++) {
                var f = func[j];
                if (node[0][f] === undefined) {
                    node[0][f] = [Object.create(null)];
                }
                node = node[0][f];
            }
            node.push(func[n_1]);
        }
        root.push(functions[i]);
    }
    return root;
}
exports.normalize = normalize;
function getCallback(resolve, reject) {
    return function () {
        switch (arguments.length) {
            case 1:
                var arg = arguments[0];
                if (arg instanceof Error) {
                    reject(arg);
                }
                else {
                    resolve(arg);
                }
                break;
            case 2:
                var arg1 = arguments[0];
                var arg2 = arguments[1];
                if (arg1 instanceof Error) {
                    reject(arg1);
                }
                else if (arg2 instanceof Error) {
                    reject(arg2);
                }
                else if (arg1 === undefined) {
                    resolve(arg2);
                }
                else {
                    resolve(arg1);
                }
                break;
        }
    };
}
function promisify(fn, thisArg) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            args.push(getCallback(resolve, reject));
            try {
                fn.apply(thisArg, args);
            }
            catch (error) {
                reject(error);
            }
        });
    };
}
exports.promisify = promisify;
var CRC32TABLE = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
];
function crc32(data, crc) {
    if (crc === void 0) { crc = 0; }
    crc = crc ^ (-1);
    for (var i = 0, n = data.length; i < n; ++i) {
        crc = (crc >>> 8) ^ CRC32TABLE[(crc ^ data[i]) & 0xFF];
    }
    return crc ^ (-1);
}
exports.crc32 = crc32;
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-core/lib/index.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-core/lib/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| index.ts                                                 |
|                                                          |
| @hprose/rpc-core for TypeScript.                         |
|                                                          |
| LastModified: Feb 16, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var Client_1 = __webpack_require__(/*! ./Client */ "./real-server/node_modules/@hprose/rpc-core/lib/Client.js");
exports.Client = Client_1.Client;
var ClientCodec_1 = __webpack_require__(/*! ./ClientCodec */ "./real-server/node_modules/@hprose/rpc-core/lib/ClientCodec.js");
exports.DefaultClientCodec = ClientCodec_1.DefaultClientCodec;
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./real-server/node_modules/@hprose/rpc-core/lib/ClientContext.js");
exports.ClientContext = ClientContext_1.ClientContext;
var Context_1 = __webpack_require__(/*! ./Context */ "./real-server/node_modules/@hprose/rpc-core/lib/Context.js");
exports.Context = Context_1.Context;
var CookieManager_1 = __webpack_require__(/*! ./CookieManager */ "./real-server/node_modules/@hprose/rpc-core/lib/CookieManager.js");
exports.getCookie = CookieManager_1.getCookie;
exports.setCookie = CookieManager_1.setCookie;
var Deferred_1 = __webpack_require__(/*! ./Deferred */ "./real-server/node_modules/@hprose/rpc-core/lib/Deferred.js");
exports.defer = Deferred_1.defer;
var PluginManager_1 = __webpack_require__(/*! ./PluginManager */ "./real-server/node_modules/@hprose/rpc-core/lib/PluginManager.js");
exports.PluginManager = PluginManager_1.PluginManager;
var InvokeManager_1 = __webpack_require__(/*! ./InvokeManager */ "./real-server/node_modules/@hprose/rpc-core/lib/InvokeManager.js");
exports.InvokeManager = InvokeManager_1.InvokeManager;
var IOManager_1 = __webpack_require__(/*! ./IOManager */ "./real-server/node_modules/@hprose/rpc-core/lib/IOManager.js");
exports.IOManager = IOManager_1.IOManager;
var Method_1 = __webpack_require__(/*! ./Method */ "./real-server/node_modules/@hprose/rpc-core/lib/Method.js");
exports.Method = Method_1.Method;
var MethodManager_1 = __webpack_require__(/*! ./MethodManager */ "./real-server/node_modules/@hprose/rpc-core/lib/MethodManager.js");
exports.MethodManager = MethodManager_1.MethodManager;
var TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./real-server/node_modules/@hprose/rpc-core/lib/TimeoutError.js");
exports.TimeoutError = TimeoutError_1.TimeoutError;
var Utils_1 = __webpack_require__(/*! ./Utils */ "./real-server/node_modules/@hprose/rpc-core/lib/Utils.js");
exports.parseURI = Utils_1.parseURI;
exports.normalize = Utils_1.normalize;
exports.promisify = Utils_1.promisify;
exports.crc32 = Utils_1.crc32;
var Service_1 = __webpack_require__(/*! ./Service */ "./real-server/node_modules/@hprose/rpc-core/lib/Service.js");
exports.Service = Service_1.Service;
var ServiceCodec_1 = __webpack_require__(/*! ./ServiceCodec */ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceCodec.js");
exports.DefaultServiceCodec = ServiceCodec_1.DefaultServiceCodec;
var ServiceContext_1 = __webpack_require__(/*! ./ServiceContext */ "./real-server/node_modules/@hprose/rpc-core/lib/ServiceContext.js");
exports.ServiceContext = ServiceContext_1.ServiceContext;
var MockHandler_1 = __webpack_require__(/*! ./MockHandler */ "./real-server/node_modules/@hprose/rpc-core/lib/MockHandler.js");
exports.MockServer = MockHandler_1.MockServer;
exports.MockHandler = MockHandler_1.MockHandler;
var MockTransport_1 = __webpack_require__(/*! ./MockTransport */ "./real-server/node_modules/@hprose/rpc-core/lib/MockTransport.js");
exports.MockTransport = MockTransport_1.MockTransport;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/HttpHandler.js":
/*!**********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/HttpHandler.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| HttpHandler.ts                                           |
|                                                          |
| HttpHandler for TypeScript.                              |
|                                                          |
| LastModified: Mar 29, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = __importStar(__webpack_require__(/*! http */ "http"));
var https = __importStar(__webpack_require__(/*! https */ "https"));
var net_1 = __webpack_require__(/*! net */ "net");
var fs = __importStar(__webpack_require__(/*! fs */ "fs"));
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var lastModified = (new Date()).toUTCString();
var etag = '"' + Math.floor(Math.random() * 2147483647).toString(16) +
    ':' + Math.floor(Math.random() * 2147483647).toString(16) + '"';
var HttpHandler = /** @class */ (function () {
    function HttpHandler(service) {
        var _this = this;
        this.service = service;
        this.p3p = true;
        this.get = true;
        this.crossDomain = true;
        this.timeout = 30000;
        this.httpHeaders = Object.create(null);
        this.origins = Object.create(null);
        this.originCount = 0;
        this._crossDomainXmlFile = '';
        this._crossDomainXmlContent = Buffer.alloc(0);
        this._clientAccessPolicyXmlFile = '';
        this._clientAccessPolicyXmlContent = Buffer.alloc(0);
        this.handler = function (request, response) { return __awaiter(_this, void 0, void 0, function () {
            var context, size;
            var _this = this;
            return __generator(this, function (_a) {
                context = new rpc_core_1.ServiceContext(this.service);
                context.request = request;
                context.response = response;
                context.remoteAddress = {
                    'family': request.socket.remoteFamily,
                    'address': request.socket.remoteAddress,
                    'port': request.socket.remotePort
                };
                context.localAddress = {
                    'family': net_1.isIPv6(request.socket.localAddress) ? 'IPv6' : 'IPv4',
                    'address': request.socket.localAddress,
                    'port': request.socket.localPort
                };
                context.handler = this;
                context['httpRequestHeaders'] = request.headers;
                size = Number(request.headers['content-length']);
                if (size > this.service.maxRequestLength) {
                    response.statusCode = 413;
                    response.statusMessage = 'Request Entity Too Large';
                    response.end();
                    return [2 /*return*/, Promise.resolve()];
                }
                if (this.timeout > 0) {
                    request.setTimeout(this.timeout, function () {
                        request.destroy(new rpc_core_1.TimeoutError());
                    });
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var instream = size ? new io_1.ByteStream(size) : new io_1.ByteStream();
                        var ondata = function (chunk) {
                            if (instream.length + chunk.length > size) {
                                request.off('data', ondata);
                                response.statusCode = 413;
                                response.statusMessage = 'Request Entity Too Large';
                                response.end();
                                return resolve();
                            }
                            instream.write(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.length));
                        };
                        request.on('data', ondata);
                        request.on('end', function () { return __awaiter(_this, void 0, void 0, function () {
                            var result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (request.method === 'GET') {
                                            if (this._clientAccessPolicyXmlContent.length > 0
                                                && this.clientAccessPolicyXmlHandler(request, response)) {
                                                return [2 /*return*/, resolve()];
                                            }
                                            if (this._crossDomainXmlContent.length > 0
                                                && this.crossDomainXmlHandler(request, response)) {
                                                return [2 /*return*/, resolve()];
                                            }
                                            if (!this.get) {
                                                response.statusCode = 403;
                                                response.statusMessage = 'Forbidden';
                                                return [2 /*return*/, resolve()];
                                            }
                                        }
                                        return [4 /*yield*/, this.service.handle(instream.takeBytes(), context)];
                                    case 1:
                                        result = _a.sent();
                                        try {
                                            this.sendHeader(request, response, context);
                                        }
                                        catch (e) {
                                            return [2 /*return*/, reject(e)];
                                        }
                                        this.end(result, response);
                                        resolve();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        request.on('error', function (error) {
                            if (_this.onerror)
                                _this.onerror(error);
                            reject(error);
                        });
                        request.on('close', function () {
                            if (_this.onclose)
                                _this.onclose(request);
                            reject();
                        });
                    })];
            });
        }); };
    }
    HttpHandler.prototype.bind = function (server) {
        var _this = this;
        server.on('request', this.handler);
        server.on('error', function (error) {
            if (_this.onerror)
                _this.onerror(error);
        });
    };
    HttpHandler.prototype.crossDomainXmlHandler = function (request, response) {
        if (request.url && request.url.toLowerCase().endsWith('/crossdomain.xml')) {
            if (request.headers['if-modified-since'] === lastModified &&
                request.headers['if-none-match'] === etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader('Last-Modified', lastModified);
                response.setHeader('Etag', etag);
                response.setHeader('Content-Type', 'text/xml');
                response.setHeader('Content-Length', this._crossDomainXmlContent.length);
                response.write(this._crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    };
    HttpHandler.prototype.clientAccessPolicyXmlHandler = function (request, response) {
        if (request.url && request.url.toLowerCase().endsWith('/clientaccesspolicy.xml')) {
            if (request.headers['if-modified-since'] === lastModified &&
                request.headers['if-none-match'] === etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader('Last-Modified', lastModified);
                response.setHeader('Etag', etag);
                response.setHeader('Content-Type', 'text/xml');
                response.setHeader('Content-Length', this._clientAccessPolicyXmlContent.length);
                response.write(this._clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    };
    HttpHandler.prototype.setHeader = function (response, headers) {
        if (headers) {
            for (var name_1 in headers) {
                var value = headers[name_1];
                if (value !== undefined) {
                    response.setHeader(name_1, value);
                }
            }
        }
    };
    HttpHandler.prototype.sendHeader = function (request, response, context) {
        if ('httpStatusCode' in context) {
            response.statusCode = Number(context['httpStatusCode']);
        }
        else {
            response.statusCode = 200;
        }
        response.setHeader('Content-Type', 'text/plain');
        if (this.p3p) {
            response.setHeader('P3P', 'CP="CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi ' +
                'CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL ' +
                'UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV"');
        }
        if (this.crossDomain) {
            var origin_1 = request.headers['origin'];
            if (typeof origin_1 === 'string' && origin_1 !== 'null') {
                if (this.originCount === 0 || this.origins[origin_1]) {
                    response.setHeader('Access-Control-Allow-Origin', origin_1);
                    response.setHeader('Access-Control-Allow-Credentials', 'true');
                }
            }
            else {
                response.setHeader('Access-Control-Allow-Origin', '*');
            }
        }
        this.setHeader(response, this.httpHeaders);
        this.setHeader(response, context['httpResponseHeaders']);
    };
    HttpHandler.prototype.end = function (data, response) {
        response.setHeader('Content-Length', data.length);
        response.end(Buffer.from(data.buffer, data.byteOffset, data.length));
    };
    HttpHandler.prototype.addAccessControlAllowOrigin = function (origin) {
        if (!this.origins[origin]) {
            this.origins[origin] = true;
            this.originCount++;
        }
    };
    HttpHandler.prototype.removeAccessControlAllowOrigin = function (origin) {
        if (this.origins[origin]) {
            delete this.origins[origin];
            this.originCount--;
        }
    };
    Object.defineProperty(HttpHandler.prototype, "crossDomainXmlFile", {
        get: function () {
            return this._crossDomainXmlFile;
        },
        set: function (value) {
            this._crossDomainXmlFile = value;
            this._crossDomainXmlContent = fs.readFileSync(this._crossDomainXmlFile);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HttpHandler.prototype, "crossDomainXmlContent", {
        get: function () {
            return this._crossDomainXmlContent;
        },
        set: function (value) {
            this._crossDomainXmlFile = '';
            this._crossDomainXmlContent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HttpHandler.prototype, "clientAccessPolicyXmlFile", {
        get: function () {
            return this._clientAccessPolicyXmlFile;
        },
        set: function (value) {
            this._clientAccessPolicyXmlFile = value;
            this._clientAccessPolicyXmlContent = fs.readFileSync(this._clientAccessPolicyXmlFile);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HttpHandler.prototype, "clientAccessPolicyXmlContent", {
        get: function () {
            return this._clientAccessPolicyXmlContent;
        },
        set: function (value) {
            this._clientAccessPolicyXmlFile = '';
            this._clientAccessPolicyXmlContent = value;
        },
        enumerable: true,
        configurable: true
    });
    HttpHandler.serverTypes = [http.Server, https.Server];
    return HttpHandler;
}());
exports.HttpHandler = HttpHandler;
rpc_core_1.Service.register('http', HttpHandler);
//# sourceMappingURL=HttpHandler.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/HttpTransport.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/HttpTransport.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| HttpTransport.ts                                         |
|                                                          |
| HttpTransport for TypeScript.                            |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var url_1 = __webpack_require__(/*! url */ "url");
var http = __importStar(__webpack_require__(/*! http */ "http"));
var https = __importStar(__webpack_require__(/*! https */ "https"));
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var HttpTransport = /** @class */ (function () {
    function HttpTransport() {
        this.counter = 0;
        this.requests = Object.create(null);
        this.keepAlive = true;
        this.httpAgent = new http.Agent({ keepAlive: true });
        this.httpsAgent = new https.Agent({ keepAlive: true });
        this.options = Object.create(null);
        this.httpRequestHeaders = Object.create(null);
    }
    HttpTransport.prototype.getRequestHeader = function (httpRequestHeaders) {
        var headers = Object.create(null);
        for (var name_1 in this.httpRequestHeaders) {
            headers[name_1] = this.httpRequestHeaders[name_1];
        }
        if (httpRequestHeaders) {
            for (var name_2 in httpRequestHeaders) {
                headers[name_2] = httpRequestHeaders[name_2];
            }
        }
        return headers;
    };
    HttpTransport.prototype.transport = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var options, client, secure, key, httpContext, cookie;
            var _this = this;
            return __generator(this, function (_a) {
                options = url_1.parse(context.uri);
                switch (options.protocol) {
                    case 'http:':
                        client = http;
                        secure = false;
                        options.agent = this.httpAgent;
                        break;
                    case 'https:':
                        client = https;
                        secure = true;
                        options.agent = this.httpsAgent;
                        break;
                    default:
                        throw new Error('unsupported ' + options.protocol + 'protocol');
                }
                for (key in this.options) {
                    if (!this.options.hasOwnProperty || this.options.hasOwnProperty(key)) {
                        options[key] = this.options[key];
                    }
                }
                httpContext = context;
                options.method = 'POST';
                options.headers = this.getRequestHeader(httpContext.httpRequestHeaders);
                options.headers['Content-Length'] = request.length;
                cookie = rpc_core_1.getCookie(options.host, options.path, secure);
                if (cookie) {
                    options.headers['Cookie'] = cookie;
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var index = _this.counter++;
                        var req = client.request(options, function (res) {
                            var size = res.headers['content-length'];
                            var instream = size ? new io_1.ByteStream(parseInt(size, 10)) : new io_1.ByteStream();
                            res.on('data', function (chunk) {
                                instream.write(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.length));
                            });
                            res.on('end', function () {
                                delete _this.requests[index];
                                httpContext.httpStatusCode = res.statusCode;
                                httpContext.httpStatusText = res.statusMessage;
                                if (res.statusCode) {
                                    if (res.statusCode >= 200 && res.statusCode < 300) {
                                        httpContext.httpResponseHeaders = res.headers;
                                        rpc_core_1.setCookie(res.headers, options.host);
                                        resolve(instream.takeBytes());
                                    }
                                    else {
                                        reject(new Error(res.statusCode + ':' + res.statusMessage));
                                        req.socket.end();
                                    }
                                }
                                else {
                                    reject(new Error(instream.toString()));
                                    req.socket.end();
                                }
                            });
                            res.on('error', function (err) {
                                delete _this.requests[index];
                                reject(err);
                            });
                        });
                        _this.requests[index] = req;
                        req.shouldKeepAlive = _this.keepAlive;
                        req.setTimeout(context.timeout, function () {
                            delete _this.requests[index];
                            reject(new rpc_core_1.TimeoutError());
                            req.abort();
                        });
                        req.on('error', function (err) {
                            delete _this.requests[index];
                            reject(err);
                        });
                        req.on('abort', function () {
                            delete _this.requests[index];
                            reject(new Error('transport abort'));
                        });
                        req.end(Buffer.from(request.buffer, 0, request.length));
                    })];
            });
        });
    };
    HttpTransport.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () {
            var index, request;
            return __generator(this, function (_a) {
                for (index in this.requests) {
                    request = this.requests[index];
                    delete this.requests[index];
                    if (request) {
                        request.abort();
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    HttpTransport.schemes = ['http', 'https'];
    return HttpTransport;
}());
exports.HttpTransport = HttpTransport;
rpc_core_1.Client.register('http', HttpTransport);
//# sourceMappingURL=HttpTransport.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/SocketHandler.js":
/*!************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/SocketHandler.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| SocketHandler.ts                                         |
|                                                          |
| SocketHandler for TypeScript.                            |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var net = __importStar(__webpack_require__(/*! net */ "net"));
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var SocketHandler = /** @class */ (function () {
    function SocketHandler(service) {
        var _this = this;
        this.service = service;
        this.handler = function (socket) {
            socket.unref();
            try {
                if (_this.onaccept)
                    _this.onaccept(socket);
            }
            catch (e) {
                socket.destroy(e);
                return;
            }
            socket.on('close', function () {
                if (_this.onclose)
                    _this.onclose(socket);
            });
            socket.on('error', function (error) {
                if (_this.onerror)
                    _this.onerror(error);
            });
            _this.receive(socket);
        };
    }
    SocketHandler.prototype.bind = function (server) {
        var _this = this;
        server.on('connection', this.handler);
        server.on('error', function (error) {
            if (_this.onerror)
                _this.onerror(error);
        });
    };
    SocketHandler.prototype.send = function (socket, response, index) {
        var n = response.length;
        var header = Buffer.allocUnsafe(12);
        header.writeInt32BE(n | 0x80000000, 4);
        header.writeInt32BE(index, 8);
        var crc = rpc_core_1.crc32(header.subarray(4, 12));
        header.writeInt32BE(crc, 0);
        socket.write(header);
        socket.write(Buffer.from(response.buffer, response.byteOffset, response.length));
    };
    SocketHandler.prototype.run = function (socket, request, index) {
        return __awaiter(this, void 0, void 0, function () {
            var context, response, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context = new rpc_core_1.ServiceContext(this.service);
                        context.socket = socket;
                        context.remoteAddress = {
                            'family': socket.remoteFamily,
                            'address': socket.remoteAddress,
                            'port': socket.remotePort
                        };
                        context.localAddress = {
                            'family': net.isIPv6(socket.localAddress) ? 'IPv6' : 'IPv4',
                            'address': socket.localAddress,
                            'port': socket.localPort
                        };
                        context.handler = this;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.service.handle(request, context)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        index |= 0x80000000;
                        response = (new io_1.ByteStream(e_1.message)).bytes;
                        return [3 /*break*/, 4];
                    case 4:
                        this.send(socket, response, index);
                        return [2 /*return*/];
                }
            });
        });
    };
    SocketHandler.prototype.receive = function (socket) {
        var _this = this;
        var instream = new io_1.ByteStream();
        var headerLength = 12;
        var bodyLength = -1;
        var index = 0;
        var ondata = function (data) {
            var chunk = new Uint8Array(data.buffer, data.byteOffset, data.length);
            instream.write(chunk);
            while (true) {
                if ((bodyLength < 0) && (instream.length >= headerLength)) {
                    var crc = instream.readInt32BE();
                    instream.mark();
                    var header = instream.read(8);
                    if (rpc_core_1.crc32(header) !== crc || (header[0] & 0x80) === 0 || (header[4] & 0x80) !== 0) {
                        socket.removeListener('data', ondata);
                        socket.destroy(new Error('Invalid request'));
                        return;
                    }
                    instream.reset();
                    bodyLength = instream.readInt32BE() & 0x7FFFFFFF;
                    index = instream.readInt32BE();
                    if (bodyLength > _this.service.maxRequestLength) {
                        socket.removeListener('data', ondata);
                        _this.send(socket, (new io_1.ByteStream('Request entity too large')).bytes, index | 0x80000000);
                        socket.end();
                        return;
                    }
                }
                if ((bodyLength >= 0) && ((instream.length - headerLength) >= bodyLength)) {
                    var request = instream.read(bodyLength);
                    instream.trunc();
                    bodyLength = -1;
                    _this.run(socket, request, index);
                }
                else {
                    break;
                }
            }
        };
        socket.on('data', ondata);
    };
    SocketHandler.serverTypes = [net.Server];
    return SocketHandler;
}());
exports.SocketHandler = SocketHandler;
rpc_core_1.Service.register('socket', SocketHandler);
//# sourceMappingURL=SocketHandler.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/SocketTransport.js":
/*!**************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/SocketTransport.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| SocketTransport.ts                                       |
|                                                          |
| SocketTransport for TypeScript.                          |
|                                                          |
| LastModified: Dec 18, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var net = __importStar(__webpack_require__(/*! net */ "net"));
var tls = __importStar(__webpack_require__(/*! tls */ "tls"));
var url_1 = __webpack_require__(/*! url */ "url");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var SocketTransport = /** @class */ (function () {
    function SocketTransport() {
        this.counter = 0;
        this.results = new Map();
        this.sockets = Object.create(null);
        this.noDelay = true;
        this.keepAlive = true;
        this.options = Object.create(null);
    }
    SocketTransport.prototype.connect = function (uri) {
        var _a;
        var parser = url_1.parse(uri);
        var protocol = parser.protocol;
        switch (protocol) {
            case 'tcp:':
            case 'tcp4:':
            case 'tcp6:':
            case 'tls:':
            case 'tls4:':
            case 'tls6:':
            case 'ssl:':
            case 'ssl4:':
            case 'ssl6:': {
                var options = Object.create(null);
                options.host = (_a = parser.hostname, (_a !== null && _a !== void 0 ? _a : undefined));
                options.port = parser.port ? parseInt(parser.port, 10) : 8412;
                switch (protocol) {
                    case 'tcp4:':
                    case 'tls4:':
                    case 'ssl4:': {
                        options.family = 4;
                        break;
                    }
                    case 'tcp6:':
                    case 'tls6:':
                    case 'ssl6:': {
                        options.family = 6;
                        break;
                    }
                }
                switch (protocol) {
                    case 'tcp:':
                    case 'tcp4:':
                    case 'tcp6:': {
                        return net.connect(options);
                    }
                    default: {
                        var tlsOptions = options;
                        for (var key in this.options) {
                            if (!this.options.hasOwnProperty || this.options.hasOwnProperty(key)) {
                                tlsOptions[key] = this.options[key];
                            }
                        }
                        return tls.connect(tlsOptions);
                    }
                }
            }
            case 'unix:': {
                var options = Object.create(null);
                if (parser.path) {
                    options.path = parser.path;
                }
                else {
                    throw new Error('invalid unix path');
                }
                return net.connect(options);
            }
            default:
                throw new Error('unsupported ' + protocol + ' protocol');
        }
    };
    SocketTransport.prototype.receive = function (uri, socket) {
        var _this = this;
        var instream = new io_1.ByteStream();
        var headerLength = 12;
        var bodyLength = -1;
        var index = 0;
        var ondata = function (data) {
            var chunk = new Uint8Array(data.buffer, data.byteOffset, data.length);
            instream.write(chunk);
            while (true) {
                if ((bodyLength < 0) && (instream.length >= headerLength)) {
                    var crc = instream.readInt32BE();
                    instream.mark();
                    var header = instream.read(8);
                    if (rpc_core_1.crc32(header) !== crc || (header[0] & 0x80) === 0) {
                        socket.removeListener('data', ondata);
                        socket.destroy(new Error('invalid response'));
                        return;
                    }
                    instream.reset();
                    bodyLength = instream.readInt32BE() & 0x7FFFFFFF;
                    index = instream.readInt32BE();
                }
                if ((bodyLength >= 0) && ((instream.length - headerLength) >= bodyLength)) {
                    var response = instream.read(bodyLength);
                    instream.trunc();
                    bodyLength = -1;
                    var has_error = (index & 0x80000000) !== 0;
                    index &= 0x7FFFFFFF;
                    var results = _this.results.get(socket);
                    if (results) {
                        var result = results[index];
                        delete results[index];
                        if (has_error) {
                            if (result) {
                                result.reject(new Error(io_1.fromUint8Array(response)));
                            }
                            socket.removeListener('data', ondata);
                            socket.end();
                            return;
                        }
                        else if (result) {
                            result.resolve(response);
                        }
                    }
                }
                else {
                    break;
                }
            }
        };
        socket.on('data', ondata);
    };
    SocketTransport.prototype.getSocket = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var socket, conn, onerror;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.sockets[uri]];
                    case 1:
                        socket = _a.sent();
                        if (socket !== undefined && !socket.destroyed) {
                            return [2 /*return*/, socket];
                        }
                        conn = rpc_core_1.defer();
                        socket = this.connect(uri);
                        socket.unref();
                        socket.setNoDelay(this.noDelay);
                        socket.setKeepAlive(this.keepAlive);
                        socket.on('connect', function () {
                            conn.resolve(socket);
                        });
                        this.receive(uri, socket);
                        onerror = function (error) { return __awaiter(_this, void 0, void 0, function () {
                            var results, index, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        results = this.results.get(socket);
                                        if (results) {
                                            for (index in results) {
                                                result = results[index];
                                                result.reject(error);
                                                delete results[index];
                                            }
                                        }
                                        return [4 /*yield*/, this.sockets[uri]];
                                    case 1:
                                        if (!((_a.sent()) === socket)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, this.sockets[uri]];
                                    case 2:
                                        (_a.sent()).destroy();
                                        delete this.sockets[uri];
                                        _a.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); };
                        socket.on('error', onerror);
                        socket.on('close', function (had_error) {
                            if (had_error)
                                return;
                            onerror(new Error('connection closed'));
                        });
                        this.sockets[uri] = conn.promise;
                        return [2 /*return*/, conn.promise];
                }
            });
        });
    };
    SocketTransport.prototype.transport = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, index, result, socket, results, timeoutId_1, n, header, crc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uri = context.uri;
                        index = (this.counter < 0x7FFFFFFF) ? ++this.counter : this.counter = 0;
                        result = rpc_core_1.defer();
                        return [4 /*yield*/, this.getSocket(uri)];
                    case 1:
                        socket = _a.sent();
                        if (this.results.get(socket) === undefined) {
                            this.results.set(socket, Object.create(null));
                        }
                        results = this.results.get(socket);
                        results[index] = result;
                        if (context.timeout > 0) {
                            timeoutId_1 = setTimeout(function () {
                                delete results[index];
                                result.reject(new rpc_core_1.TimeoutError());
                            }, context.timeout);
                            result.promise.then(function () {
                                clearTimeout(timeoutId_1);
                            }, function () {
                                clearTimeout(timeoutId_1);
                            });
                        }
                        n = request.length;
                        header = Buffer.allocUnsafe(12);
                        header.writeInt32BE(n | 0x80000000, 4);
                        header.writeInt32BE(index, 8);
                        crc = rpc_core_1.crc32(header.subarray(4, 12));
                        header.writeInt32BE(crc, 0);
                        socket.write(header);
                        socket.write(Buffer.from(request.buffer, request.byteOffset, request.length));
                        return [2 /*return*/, result.promise];
                }
            });
        });
    };
    SocketTransport.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, uri, socket;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in this.sockets)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        uri = _a[_i];
                        socket = this.sockets[uri];
                        delete this.sockets[uri];
                        if (!socket) return [3 /*break*/, 3];
                        return [4 /*yield*/, socket];
                    case 2:
                        (_c.sent()).end();
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    SocketTransport.schemes = ['tcp', 'tcp4', 'tcp6', 'tls', 'tls4', 'tls6', 'ssl', 'ssl4', 'ssl6', 'unix'];
    return SocketTransport;
}());
exports.SocketTransport = SocketTransport;
rpc_core_1.Client.register('socket', SocketTransport);
//# sourceMappingURL=SocketTransport.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/UdpHandler.js":
/*!*********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/UdpHandler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| UdpHandler.ts                                            |
|                                                          |
| UdpHandler for TypeScript.                               |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var dgram = __importStar(__webpack_require__(/*! dgram */ "dgram"));
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var UdpHandler = /** @class */ (function () {
    function UdpHandler(service) {
        var _this = this;
        this.service = service;
        this.handler = function (socket) {
            socket.on('message', function (msg, rinfo) { return __awaiter(_this, void 0, void 0, function () {
                var crc, header, bodyLength, index, request, context, response, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            crc = msg.readInt32BE(0);
                            header = msg.subarray(4, 8);
                            if (rpc_core_1.crc32(header) !== crc)
                                return [2 /*return*/];
                            bodyLength = msg.readUInt16BE(4);
                            index = msg.readUInt16BE(6);
                            if (bodyLength !== msg.length - 8 || (index & 0x8000) !== 0)
                                return [2 /*return*/];
                            if (bodyLength > this.service.maxRequestLength) {
                                this.send(socket, Buffer.from('Request entity too large'), index | 0x8000, rinfo);
                                return [2 /*return*/];
                            }
                            request = new Uint8Array(msg.buffer, msg.byteOffset + 8, bodyLength);
                            context = new rpc_core_1.ServiceContext(this.service);
                            context.socket = socket;
                            context.remoteAddress = {
                                'family': rinfo.family,
                                'address': rinfo.address,
                                'port': rinfo.port
                            };
                            context.localAddress = socket.address();
                            context.handler = this;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.service.handle(request, context)];
                        case 2:
                            response = _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            index |= 0x8000;
                            response = (new io_1.ByteStream(e_1.message)).bytes;
                            return [3 /*break*/, 4];
                        case 4:
                            this.send(socket, Buffer.from(response.buffer, response.byteOffset, response.length), index, rinfo);
                            return [2 /*return*/];
                    }
                });
            }); });
            socket.on('close', function () {
                if (_this.onclose)
                    _this.onclose(socket);
            });
            socket.on('error', function (error) {
                if (_this.onerror)
                    _this.onerror(error);
            });
        };
    }
    UdpHandler.prototype.send = function (socket, body, index, rinfo) {
        var _this = this;
        var n = body.length;
        var header = Buffer.allocUnsafe(8);
        header.writeUInt16BE(n, 4);
        header.writeUInt16BE(index, 6);
        var crc = rpc_core_1.crc32(new Uint8Array(header.buffer, header.byteOffset + 4, 4));
        header.writeInt32BE(crc, 0);
        socket.send([header, body], rinfo.port, rinfo.address, function (error) {
            if (error && _this.onerror)
                _this.onerror(error);
        });
    };
    UdpHandler.prototype.bind = function (socket) {
        this.handler(socket);
    };
    UdpHandler.serverTypes = [dgram.Socket];
    return UdpHandler;
}());
exports.UdpHandler = UdpHandler;
rpc_core_1.Service.register('udp', UdpHandler);
//# sourceMappingURL=UdpHandler.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/UdpTransport.js":
/*!***********************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/UdpTransport.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| UdpTransport.ts                                          |
|                                                          |
| UdpTransport for TypeScript.                             |
|                                                          |
| LastModified: Dec 18, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var dgram = __importStar(__webpack_require__(/*! dgram */ "dgram"));
var url_1 = __webpack_require__(/*! url */ "url");
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var UdpTransport = /** @class */ (function () {
    function UdpTransport() {
        this.counter = 0;
        this.results = new Map();
        this.sockets = Object.create(null);
    }
    UdpTransport.prototype.getSocket = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var socket, udp, parser, protocol, type, onerror;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.sockets[uri]];
                    case 1:
                        socket = _a.sent();
                        if (socket !== undefined) {
                            return [2 /*return*/, socket];
                        }
                        udp = rpc_core_1.defer();
                        parser = url_1.parse(uri);
                        protocol = parser.protocol;
                        type = 'udp4';
                        switch (protocol) {
                            case 'udp:':
                            case 'udp4:':
                                break;
                            case 'udp6:':
                                type = 'udp6';
                                break;
                            default:
                                throw new Error('unsupported ' + protocol + ' protocol');
                        }
                        socket = dgram.createSocket(type);
                        socket.unref();
                        socket.on('listening', function () {
                            udp.resolve(socket);
                        });
                        socket.on('message', function (msg) { return __awaiter(_this, void 0, void 0, function () {
                            var crc, header, bodyLength, index, has_error, response, results, result;
                            return __generator(this, function (_a) {
                                crc = msg.readInt32BE(0);
                                header = msg.subarray(4, 8);
                                if (rpc_core_1.crc32(header) !== crc)
                                    return [2 /*return*/];
                                bodyLength = msg.readUInt16BE(4);
                                if (bodyLength !== msg.length - 8)
                                    return [2 /*return*/];
                                index = msg.readUInt16BE(6);
                                has_error = (index & 0x8000) !== 0;
                                index &= 0x7FFF;
                                response = new Uint8Array(msg.buffer, msg.byteOffset + 8, bodyLength);
                                results = this.results.get(socket);
                                if (results) {
                                    result = results[index];
                                    delete results[index];
                                    if (result) {
                                        if (has_error) {
                                            result.reject(new Error(io_1.fromUint8Array(response)));
                                        }
                                        else {
                                            result.resolve(response);
                                        }
                                    }
                                }
                                return [2 /*return*/];
                            });
                        }); });
                        onerror = function (error) { return __awaiter(_this, void 0, void 0, function () {
                            var results, index, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        results = this.results.get(socket);
                                        if (results) {
                                            for (index in results) {
                                                result = results[index];
                                                result.reject(error);
                                                delete results[index];
                                            }
                                        }
                                        return [4 /*yield*/, this.sockets[uri]];
                                    case 1:
                                        if ((_a.sent()) === socket) {
                                            delete this.sockets[uri];
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        socket.on('error', onerror);
                        socket.on('close', function () { return onerror(new Error('closed')); });
                        socket.bind();
                        this.sockets[uri] = udp.promise;
                        return [2 /*return*/, udp.promise];
                }
            });
        });
    };
    UdpTransport.prototype.transport = function (request, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var uri, index, result, socket, results, timeoutId_1, parser, n, header, crc, body;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (request.length > 65499) {
                            throw new Error('request too large');
                        }
                        uri = context.uri;
                        index = (this.counter < 0x7FFF) ? ++this.counter : this.counter = 0;
                        result = rpc_core_1.defer();
                        return [4 /*yield*/, this.getSocket(uri)];
                    case 1:
                        socket = _b.sent();
                        if (this.results.get(socket) === undefined) {
                            this.results.set(socket, Object.create(null));
                        }
                        results = this.results.get(socket);
                        results[index] = result;
                        if (context.timeout > 0) {
                            timeoutId_1 = setTimeout(function () {
                                delete results[index];
                                result.reject(new rpc_core_1.TimeoutError());
                            }, context.timeout);
                            result.promise.then(function () {
                                clearTimeout(timeoutId_1);
                            }, function () {
                                clearTimeout(timeoutId_1);
                            });
                        }
                        parser = url_1.parse(uri);
                        n = request.length;
                        header = Buffer.allocUnsafe(8);
                        header.writeUInt16BE(n, 4);
                        header.writeUInt16BE(index, 6);
                        crc = rpc_core_1.crc32(new Uint8Array(header.buffer, header.byteOffset + 4, 4));
                        header.writeInt32BE(crc, 0);
                        body = Buffer.from(request.buffer, request.byteOffset, request.length);
                        socket.send([header, body], parser.port ? parseInt(parser.port, 10) : 8412, (_a = parser.hostname, (_a !== null && _a !== void 0 ? _a : undefined)), function (error) {
                            if (error) {
                                delete results[index];
                                result.reject(error);
                            }
                        });
                        return [2 /*return*/, result.promise];
                }
            });
        });
    };
    UdpTransport.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, uri, socket;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in this.sockets)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        uri = _a[_i];
                        socket = this.sockets[uri];
                        delete this.sockets[uri];
                        if (!socket) return [3 /*break*/, 3];
                        return [4 /*yield*/, socket];
                    case 2:
                        (_c.sent()).close();
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    UdpTransport.schemes = ['udp', 'udp4', 'udp6'];
    return UdpTransport;
}());
exports.UdpTransport = UdpTransport;
rpc_core_1.Client.register('udp', UdpTransport);
//# sourceMappingURL=UdpTransport.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/WebSocketHandler.js":
/*!***************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/WebSocketHandler.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| WebSocketHandler.ts                                      |
|                                                          |
| WebSocketHandler for TypeScript.                         |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ws_1 = __importDefault(__webpack_require__(/*! ws */ "ws"));
var http = __importStar(__webpack_require__(/*! http */ "http"));
var https = __importStar(__webpack_require__(/*! https */ "https"));
var net_1 = __webpack_require__(/*! net */ "net");
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var WebSocketHandler = /** @class */ (function () {
    function WebSocketHandler(service) {
        var _this = this;
        this.service = service;
        this.compress = false;
        this.handler = function (websocket, request) {
            try {
                websocket.protocol = 'hprose';
                websocket.binaryType = 'arraybuffer';
                if (_this.onaccept)
                    _this.onaccept(websocket);
            }
            catch (_a) {
                websocket.terminate();
                return;
            }
            websocket.on('close', function () {
                if (_this.onclose)
                    _this.onclose(websocket);
            });
            websocket.on('error', function (error) {
                if (_this.onerror)
                    _this.onerror(error);
            });
            websocket.on('message', function (data) { return __awaiter(_this, void 0, void 0, function () {
                var instream, index, context, response, e_1, header;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            instream = new io_1.ByteStream(data);
                            index = instream.readInt32BE();
                            context = new rpc_core_1.ServiceContext(this.service);
                            context.websocket = websocket;
                            context.request = request;
                            context.remoteAddress = {
                                'family': request.socket.remoteFamily,
                                'address': request.socket.remoteAddress,
                                'port': request.socket.remotePort
                            };
                            context.localAddress = {
                                'family': net_1.isIPv6(request.socket.localAddress) ? 'IPv6' : 'IPv4',
                                'address': request.socket.localAddress,
                                'port': request.socket.localPort
                            };
                            context.handler = this;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.service.handle(instream.remains, context)];
                        case 2:
                            response = _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            index |= 0x80000000;
                            response = (new io_1.ByteStream(e_1.message)).bytes;
                            return [3 /*break*/, 4];
                        case 4:
                            header = new Uint8Array(4);
                            io_1.writeInt32BE(header, 0, index);
                            websocket.send(header, {
                                binary: true,
                                compress: this.compress,
                                fin: false
                            }, function (error) {
                                if (error) {
                                    if (_this.onerror)
                                        _this.onerror(error);
                                }
                            });
                            websocket.send(response, {
                                binary: true,
                                compress: this.compress,
                            }, function (error) {
                                if (error) {
                                    if (_this.onerror)
                                        _this.onerror(error);
                                }
                            });
                            return [2 /*return*/];
                    }
                });
            }); });
        };
    }
    WebSocketHandler.prototype.bind = function (server) {
        var _this = this;
        if (server instanceof http.Server || server instanceof https.Server) {
            server = new ws_1.default.Server({ server: server });
        }
        server.options.perMessageDeflate = false;
        server.options.maxPayload = this.service.maxRequestLength + 4;
        server.on('connection', this.handler);
        server.on('error', function (error) {
            if (_this.onerror)
                _this.onerror(error);
        });
    };
    WebSocketHandler.serverTypes = [http.Server, https.Server, ws_1.default.Server];
    return WebSocketHandler;
}());
exports.WebSocketHandler = WebSocketHandler;
rpc_core_1.Service.register('websocket', WebSocketHandler);
//# sourceMappingURL=WebSocketHandler.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/WebSocketTransport.js":
/*!*****************************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/WebSocketTransport.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| WebSocketTransport.ts                                    |
|                                                          |
| WebSocketTransport for TypeScript.                       |
|                                                          |
| LastModified: Dec 17, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = __importStar(__webpack_require__(/*! http */ "http"));
var https = __importStar(__webpack_require__(/*! https */ "https"));
var ws_1 = __importDefault(__webpack_require__(/*! ws */ "ws"));
var rpc_core_1 = __webpack_require__(/*! @hprose/rpc-core */ "./real-server/node_modules/@hprose/rpc-core/lib/index.js");
var io_1 = __webpack_require__(/*! @hprose/io */ "./real-server/node_modules/@hprose/io/lib/index.js");
var WebSocketTransport = /** @class */ (function () {
    function WebSocketTransport() {
        this.counter = 0;
        this.results = new Map();
        this.websockets = Object.create(null);
        this.httpAgent = new http.Agent({ keepAlive: true });
        this.httpsAgent = new https.Agent({ keepAlive: true });
        this.options = Object.create(null);
        this.compress = false;
    }
    WebSocketTransport.prototype.connect = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var websocket, ws, onerror;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.websockets[uri]];
                    case 1:
                        websocket = _a.sent();
                        if (websocket !== undefined
                            && websocket.readyState !== ws_1.default.CLOSING
                            && websocket.readyState !== ws_1.default.CLOSED) {
                            return [2 /*return*/, websocket];
                        }
                        ws = rpc_core_1.defer();
                        this.options.perMessageDeflate = false;
                        this.options.protocol = 'hprose';
                        if (this.options.agent === undefined) {
                            if (uri.toLowerCase().startsWith('https://')) {
                                this.options.agent = this.httpsAgent;
                            }
                            else {
                                this.options.agent = this.httpAgent;
                            }
                        }
                        websocket = new ws_1.default(uri, this.options);
                        websocket.binaryType = 'arraybuffer';
                        websocket.on('open', function () {
                            ws.resolve(websocket);
                        });
                        websocket.on('message', function (data) { return __awaiter(_this, void 0, void 0, function () {
                            var instream, index, response, has_error, results, result;
                            return __generator(this, function (_a) {
                                instream = new io_1.ByteStream(data);
                                index = instream.readInt32BE();
                                response = instream.remains;
                                has_error = (index & 0x80000000) !== 0;
                                index &= 0x7FFFFFFF;
                                results = this.results.get(websocket);
                                if (results) {
                                    result = results[index];
                                    delete results[index];
                                    if (has_error) {
                                        if (result) {
                                            result.reject(new Error(io_1.fromUint8Array(response)));
                                        }
                                        websocket.close();
                                    }
                                    else if (result) {
                                        result.resolve(response);
                                    }
                                }
                                return [2 /*return*/];
                            });
                        }); });
                        onerror = function (error) { return __awaiter(_this, void 0, void 0, function () {
                            var results, index, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        results = this.results.get(websocket);
                                        if (results) {
                                            for (index in results) {
                                                result = results[index];
                                                result.reject(error);
                                                delete results[index];
                                            }
                                        }
                                        return [4 /*yield*/, this.websockets[uri]];
                                    case 1:
                                        if ((_a.sent()) === websocket) {
                                            delete this.websockets[uri];
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        websocket.on('error', onerror);
                        websocket.on('close', function (code, reason) {
                            if (reason) {
                                onerror(new Error(code + ":" + reason));
                            }
                            else {
                                onerror(new Error("" + code));
                            }
                        });
                        this.websockets[uri] = ws.promise;
                        return [2 /*return*/, ws.promise];
                }
            });
        });
    };
    WebSocketTransport.prototype.transport = function (request, context) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, index, result, websocket, results, timeoutId_1, header;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uri = context.uri;
                        index = (this.counter < 0x7FFFFFFF) ? ++this.counter : this.counter = 0;
                        result = rpc_core_1.defer();
                        return [4 /*yield*/, this.connect(uri)];
                    case 1:
                        websocket = _a.sent();
                        if (this.results.get(websocket) === undefined) {
                            this.results.set(websocket, Object.create(null));
                        }
                        results = this.results.get(websocket);
                        results[index] = result;
                        if (context.timeout > 0) {
                            timeoutId_1 = setTimeout(function () {
                                delete results[index];
                                result.reject(new rpc_core_1.TimeoutError());
                            }, context.timeout);
                            result.promise.then(function () {
                                clearTimeout(timeoutId_1);
                            }, function () {
                                clearTimeout(timeoutId_1);
                            });
                        }
                        header = new Uint8Array(4);
                        io_1.writeInt32BE(header, 0, index);
                        websocket.send(header, {
                            binary: true,
                            compress: this.compress,
                            fin: false,
                        }, function (error) {
                            if (error) {
                                result.reject(error);
                                delete results[index];
                            }
                        });
                        websocket.send(request, {
                            binary: true,
                            compress: this.compress
                        }, function (error) {
                            if (error) {
                                result.reject(error);
                                delete results[index];
                            }
                        });
                        return [2 /*return*/, result.promise];
                }
            });
        });
    };
    WebSocketTransport.prototype.abort = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, uri, websocket;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in this.websockets)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        uri = _a[_i];
                        websocket = this.websockets[uri];
                        delete this.websockets[uri];
                        if (!websocket) return [3 /*break*/, 3];
                        return [4 /*yield*/, websocket];
                    case 2:
                        (_c.sent()).close(1000);
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    WebSocketTransport.schemes = ['ws', 'wss'];
    return WebSocketTransport;
}());
exports.WebSocketTransport = WebSocketTransport;
rpc_core_1.Client.register('websocket', WebSocketTransport);
//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ "./real-server/node_modules/@hprose/rpc-node/lib/index.js":
/*!****************************************************************!*\
  !*** ./real-server/node_modules/@hprose/rpc-node/lib/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| index.ts                                                 |
|                                                          |
| @hprose/rpc-node for TypeScript.                         |
|                                                          |
| LastModified: Feb 27, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var HttpTransport_1 = __webpack_require__(/*! ./HttpTransport */ "./real-server/node_modules/@hprose/rpc-node/lib/HttpTransport.js");
exports.HttpTransport = HttpTransport_1.HttpTransport;
var WebSocketTransport_1 = __webpack_require__(/*! ./WebSocketTransport */ "./real-server/node_modules/@hprose/rpc-node/lib/WebSocketTransport.js");
exports.WebSocketTransport = WebSocketTransport_1.WebSocketTransport;
var SocketTransport_1 = __webpack_require__(/*! ./SocketTransport */ "./real-server/node_modules/@hprose/rpc-node/lib/SocketTransport.js");
exports.SocketTransport = SocketTransport_1.SocketTransport;
var UdpTransport_1 = __webpack_require__(/*! ./UdpTransport */ "./real-server/node_modules/@hprose/rpc-node/lib/UdpTransport.js");
exports.UdpTransport = UdpTransport_1.UdpTransport;
var HttpHandler_1 = __webpack_require__(/*! ./HttpHandler */ "./real-server/node_modules/@hprose/rpc-node/lib/HttpHandler.js");
exports.HttpHandler = HttpHandler_1.HttpHandler;
var WebSocketHandler_1 = __webpack_require__(/*! ./WebSocketHandler */ "./real-server/node_modules/@hprose/rpc-node/lib/WebSocketHandler.js");
exports.WebSocketHandler = WebSocketHandler_1.WebSocketHandler;
var SocketHandler_1 = __webpack_require__(/*! ./SocketHandler */ "./real-server/node_modules/@hprose/rpc-node/lib/SocketHandler.js");
exports.SocketHandler = SocketHandler_1.SocketHandler;
var UdpHandler_1 = __webpack_require__(/*! ./UdpHandler */ "./real-server/node_modules/@hprose/rpc-node/lib/UdpHandler.js");
exports.UdpHandler = UdpHandler_1.UdpHandler;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./real-server/node_modules/lodash/core.js":
/*!*************************************************!*\
  !*** ./real-server/node_modules/lodash/core.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash core -o ./dist/lodash.core.js`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_PARTIAL_FLAG = 32;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';

  /** Used to match HTML entities and HTML characters. */
  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /*--------------------------------------------------------------------------*/

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    array.push.apply(array, values);
    return array;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return baseMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to restore the original `_` reference in `_.noConflict`. */
  var oldDash = root._;

  /** Built-in value references. */
  var objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsFinite = root.isFinite,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    return value instanceof LodashWrapper
      ? value
      : new LodashWrapper(value);
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable explicit method chain sequences.
   */
  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
  }

  LodashWrapper.prototype = baseCreate(lodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;

  /*------------------------------------------------------------------------*/

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    object[key] = value;
  }

  /**
   * The base implementation of `_.delay` and `_.defer` which accepts `args`
   * to provide to `func`.
   *
   * @private
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay invocation.
   * @param {Array} args The arguments to provide to `func`.
   * @returns {number|Object} Returns the timer id or timeout object.
   */
  function baseDelay(func, wait, args) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !false)
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.functions` which creates an array of
   * `object` function property names filtered from `props`.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The property names to filter.
   * @returns {Array} Returns the function names.
   */
  function baseFunctions(object, props) {
    return baseFilter(props, function(key) {
      return isFunction(object[key]);
    });
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    return objectToString(value);
  }

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  var baseIsArguments = noop;

  /**
   * The base implementation of `_.isDate` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   */
  function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : baseGetTag(object),
        othTag = othIsArr ? arrayTag : baseGetTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    stack || (stack = []);
    var objStack = find(stack, function(entry) {
      return entry[0] == object;
    });
    var othStack = find(stack, function(entry) {
      return entry[0] == other;
    });
    if (objStack && othStack) {
      return objStack[1] == other;
    }
    stack.push([object, other]);
    stack.push([other, object]);
    if (isSameTag && !objIsObj) {
      var result = (objIsArr)
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      stack.pop();
      return result;
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        var result = equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        stack.pop();
        return result;
      }
    }
    if (!isSameTag) {
      return false;
    }
    var result = equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    stack.pop();
    return result;
  }

  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */
  function baseIsRegExp(value) {
    return isObjectLike(value) && baseGetTag(value) == regexpTag;
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(func) {
    if (typeof func == 'function') {
      return func;
    }
    if (func == null) {
      return identity;
    }
    return (typeof func == 'object' ? baseMatches : baseProperty)(func);
  }

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var props = nativeKeys(source);
    return function(object) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length];
        if (!(key in object &&
              baseIsEqual(source[key], object[key], COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
            )) {
          return false;
        }
      }
      return true;
    };
  }

  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */
  function basePick(object, props) {
    object = Object(object);
    return reduce(props, function(result, key) {
      if (key in object) {
        result[key] = object[key];
      }
      return result;
    }, {});
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source) {
    return baseSlice(source, 0, source.length);
  }

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  /**
   * The base implementation of `wrapperValue` which returns the result of
   * performing a sequence of actions on the unwrapped `value`, where each
   * successive action is supplied the return value of the previous.
   *
   * @private
   * @param {*} value The unwrapped value.
   * @param {Array} actions Actions to perform to resolve the unwrapped value.
   * @returns {*} Returns the resolved value.
   */
  function baseWrapperValue(value, actions) {
    var result = value;
    return reduce(actions, function(result, action) {
      return action.func.apply(action.thisArg, arrayPush([result], action.args));
    }, result);
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = false;

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = false;

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtor(Ctor) {
    return function() {
      // Use a `switch` statement to work with class constructors. See
      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
      // for more details.
      var args = arguments;
      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, args);

      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject(result) ? result : thisBinding;
    };
  }

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  /**
   * Creates a function that wraps `func` to invoke it with the `this` binding
   * of `thisArg` and `partials` prepended to the arguments it receives.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to
   *  the new function.
   * @returns {Function} Returns the new wrapped function.
   */
  function createPartial(func, bitmask, thisArg, partials) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var isBind = bitmask & WRAP_BIND_FLAG,
        Ctor = createCtor(func);

    function wrapper() {
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(leftLength + argsLength),
          fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      return fn.apply(isBind ? thisArg : this, args);
    }
    return wrapper;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? [] : undefined;

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      var compared;
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!baseSome(other, function(othValue, othIndex) {
              if (!indexOf(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var result = true;

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      var compared;
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value);
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return func.apply(this, otherArgs);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = identity;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    return baseFilter(array, Boolean);
  }

  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */
  function concat() {
    var length = arguments.length;
    if (!length) {
      return [];
    }
    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }
    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index);
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  /**
   * Recursively flattens `array`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flattenDeep([1, [2, [3, [4]], 5]]);
   * // => [1, 2, 3, 4, 5]
   */
  function flattenDeep(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, INFINITY) : [];
  }

  /**
   * Gets the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias first
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the first element of `array`.
   * @example
   *
   * _.head([1, 2, 3]);
   * // => 1
   *
   * _.head([]);
   * // => undefined
   */
  function head(array) {
    return (array && array.length) ? array[0] : undefined;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. If `fromIndex` is negative, it's used as the
   * offset from the end of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // Search from the `fromIndex`.
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   */
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (typeof fromIndex == 'number') {
      fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
    } else {
      fromIndex = 0;
    }
    var index = (fromIndex || 0) - 1,
        isReflexive = value === value;

    while (++index < length) {
      var other = array[index];
      if ((isReflexive ? other === value : other !== other)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  /**
   * Creates a slice of `array` from `start` up to, but not including, `end`.
   *
   * **Note:** This method is used instead of
   * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
   * returned.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    start = start == null ? 0 : +start;
    end = end === undefined ? length : +end;
    return length ? baseSlice(array, start, end) : [];
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` wrapper instance that wraps `value` with explicit method
   * chain sequences enabled. The result of such sequences must be unwrapped
   * with `_#value`.
   *
   * @static
   * @memberOf _
   * @since 1.3.0
   * @category Seq
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36 },
   *   { 'user': 'fred',    'age': 40 },
   *   { 'user': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _
   *   .chain(users)
   *   .sortBy('age')
   *   .map(function(o) {
   *     return o.user + ' is ' + o.age;
   *   })
   *   .head()
   *   .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
  }

  /**
   * This method invokes `interceptor` and returns `value`. The interceptor
   * is invoked with one argument; (value). The purpose of this method is to
   * "tap into" a method chain sequence in order to modify intermediate results.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3])
   *  .tap(function(array) {
   *    // Mutate input array.
   *    array.pop();
   *  })
   *  .reverse()
   *  .value();
   * // => [2, 1]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * This method is like `_.tap` except that it returns the result of `interceptor`.
   * The purpose of this method is to "pass thru" values replacing intermediate
   * results in a method chain sequence.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns the result of `interceptor`.
   * @example
   *
   * _('  abc  ')
   *  .chain()
   *  .trim()
   *  .thru(function(value) {
   *    return [value];
   *  })
   *  .value();
   * // => ['abc']
   */
  function thru(value, interceptor) {
    return interceptor(value);
  }

  /**
   * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
   *
   * @name chain
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 }
   * ];
   *
   * // A sequence without explicit chaining.
   * _(users).head();
   * // => { 'user': 'barney', 'age': 36 }
   *
   * // A sequence with explicit chaining.
   * _(users)
   *   .chain()
   *   .head()
   *   .pick('user')
   *   .value();
   * // => { 'user': 'barney' }
   */
  function wrapperChain() {
    return chain(this);
  }

  /**
   * Executes the chain sequence to resolve the unwrapped value.
   *
   * @name value
   * @memberOf _
   * @since 0.1.0
   * @alias toJSON, valueOf
   * @category Seq
   * @returns {*} Returns the resolved unwrapped value.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */
  function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    predicate = guard ? undefined : predicate;
    return baseEvery(collection, baseIteratee(predicate));
  }

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    return baseFilter(collection, baseIteratee(predicate));
  }

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    return baseEach(collection, baseIteratee(iteratee));
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    return baseMap(collection, baseIteratee(iteratee));
  }

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator) {
    return baseReduce(collection, baseIteratee(iteratee), accumulator, arguments.length < 3, baseEach);
  }

  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    collection = isArrayLike(collection) ? collection : nativeKeys(collection);
    return collection.length;
  }

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    predicate = guard ? undefined : predicate;
    return baseSome(collection, baseIteratee(predicate));
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */
  function sortBy(collection, iteratee) {
    var index = 0;
    iteratee = baseIteratee(iteratee);

    return baseMap(baseMap(collection, function(value, key, collection) {
      return { 'value': value, 'index': index++, 'criteria': iteratee(value, key, collection) };
    }).sort(function(object, other) {
      return compareAscending(object.criteria, other.criteria) || (object.index - other.index);
    }), baseProperty('value'));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that invokes `func`, with the `this` binding and arguments
   * of the created function, while it's called less than `n` times. Subsequent
   * calls to the created function return the result of the last `func` invocation.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {number} n The number of calls at which `func` is no longer invoked.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * jQuery(element).on('click', _.before(5, addContactToList));
   * // => Allows adding up to 4 contacts to the list.
   */
  function before(n, func) {
    var result;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }

  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and `partials` prepended to the arguments it receives.
   *
   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
   * may be used as a placeholder for partially applied arguments.
   *
   * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
   * property of bound functions.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {...*} [partials] The arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * function greet(greeting, punctuation) {
   *   return greeting + ' ' + this.user + punctuation;
   * }
   *
   * var object = { 'user': 'fred' };
   *
   * var bound = _.bind(greet, object, 'hi');
   * bound('!');
   * // => 'hi fred!'
   *
   * // Bound with placeholders.
   * var bound = _.bind(greet, object, _, '!');
   * bound('hi');
   * // => 'hi fred!'
   */
  var bind = baseRest(function(func, thisArg, partials) {
    return createPartial(func, WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG, thisArg, partials);
  });

  /**
   * Defers invoking the `func` until the current call stack has cleared. Any
   * additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to defer.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.defer(function(text) {
   *   console.log(text);
   * }, 'deferred');
   * // => Logs 'deferred' after one millisecond.
   */
  var defer = baseRest(function(func, args) {
    return baseDelay(func, 1, args);
  });

  /**
   * Invokes `func` after `wait` milliseconds. Any additional arguments are
   * provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay invocation.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.delay(function(text) {
   *   console.log(text);
   * }, 1000, 'later');
   * // => Logs 'later' after one second.
   */
  var delay = baseRest(function(func, wait, args) {
    return baseDelay(func, toNumber(wait) || 0, args);
  });

  /**
   * Creates a function that negates the result of the predicate `func`. The
   * `func` predicate is invoked with the `this` binding and arguments of the
   * created function.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {Function} predicate The predicate to negate.
   * @returns {Function} Returns the new negated function.
   * @example
   *
   * function isEven(n) {
   *   return n % 2 == 0;
   * }
   *
   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
   * // => [1, 3, 5]
   */
  function negate(predicate) {
    if (typeof predicate != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return function() {
      var args = arguments;
      return !predicate.apply(this, args);
    };
  }

  /**
   * Creates a function that is restricted to invoking `func` once. Repeat calls
   * to the function return the value of the first invocation. The `func` is
   * invoked with the `this` binding and arguments of the created function.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // => `createApplication` is invoked once
   */
  function once(func) {
    return before(2, func);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    if (!isObject(value)) {
      return value;
    }
    return isArray(value) ? copyArray(value) : copyObject(value, nativeKeys(value));
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      (isObjectLike(value) && baseGetTag(value) == boolTag);
  }

  /**
   * Checks if `value` is classified as a `Date` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   *
   * _.isDate('Mon April 23 2012');
   * // => false
   */
  var isDate = baseIsDate;

  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */
  function isEmpty(value) {
    if (isArrayLike(value) &&
        (isArray(value) || isString(value) ||
          isFunction(value.splice) || isArguments(value))) {
      return !value.length;
    }
    return !nativeKeys(value).length;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */
  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber(value) && value != +value;
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      (isObjectLike(value) && baseGetTag(value) == numberTag);
  }

  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */
  var isRegExp = baseIsRegExp;

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */
  function isUndefined(value) {
    return value === undefined;
  }

  /**
   * Converts `value` to an array.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Array} Returns the converted array.
   * @example
   *
   * _.toArray({ 'a': 1, 'b': 2 });
   * // => [1, 2]
   *
   * _.toArray('abc');
   * // => ['a', 'b', 'c']
   *
   * _.toArray(1);
   * // => []
   *
   * _.toArray(null);
   * // => []
   */
  function toArray(value) {
    if (!isArrayLike(value)) {
      return values(value);
    }
    return value.length ? copyArray(value) : [];
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  var toInteger = Number;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  var toNumber = Number;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */
  var assign = createAssigner(function(object, source) {
    copyObject(source, nativeKeys(source), object);
  });

  /**
   * This method is like `_.assign` except that it iterates over own and
   * inherited source properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assign
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assignIn({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
   */
  var assignIn = createAssigner(function(object, source) {
    copyObject(source, nativeKeysIn(source), object);
  });

  /**
   * Creates an object that inherits from the `prototype` object. If a
   * `properties` object is given, its own enumerable string keyed properties
   * are assigned to the created object.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Object
   * @param {Object} prototype The object to inherit from.
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * function Circle() {
   *   Shape.call(this);
   * }
   *
   * Circle.prototype = _.create(Shape.prototype, {
   *   'constructor': Circle
   * });
   *
   * var circle = new Circle;
   * circle instanceof Circle;
   * // => true
   *
   * circle instanceof Shape;
   * // => true
   */
  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties == null ? result : assign(result, properties);
  }

  /**
   * Assigns own and inherited enumerable string keyed properties of source
   * objects to the destination object for all destination properties that
   * resolve to `undefined`. Source objects are applied from left to right.
   * Once a property is set, additional values of the same property are ignored.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.defaultsDeep
   * @example
   *
   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */
  var defaults = baseRest(function(object, sources) {
    object = Object(object);

    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }

    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;

      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];

        if (value === undefined ||
            (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
          object[key] = source[key];
        }
      }
    }

    return object;
  });

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */
  function has(object, path) {
    return object != null && hasOwnProperty.call(object, path);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  var keys = nativeKeys;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  var keysIn = nativeKeysIn;

  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */
  var pick = flatRest(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
  });

  /**
   * This method is like `_.get` except that if the resolved value is a
   * function it's invoked with the `this` binding of its parent object and
   * its result is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to resolve.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
   *
   * _.result(object, 'a[0].b.c1');
   * // => 3
   *
   * _.result(object, 'a[0].b.c2');
   * // => 4
   *
   * _.result(object, 'a[0].b.c3', 'default');
   * // => 'default'
   *
   * _.result(object, 'a[0].b.c3', _.constant('default'));
   * // => 'default'
   */
  function result(object, path, defaultValue) {
    var value = object == null ? undefined : object[path];
    if (value === undefined) {
      value = defaultValue;
    }
    return isFunction(value) ? value.call(object) : value;
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */
  function escape(string) {
    string = toString(string);
    return (string && reHasUnescapedHtml.test(string))
      ? string.replace(reUnescapedHtml, escapeHtmlChar)
      : string;
  }

  /*------------------------------------------------------------------------*/

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  var iteratee = baseIteratee;

  /**
   * Creates a function that performs a partial deep comparison between a given
   * object and `source`, returning `true` if the given object has equivalent
   * property values, else `false`.
   *
   * **Note:** The created function is equivalent to `_.isMatch` with `source`
   * partially applied.
   *
   * Partial comparisons will match empty array and empty object `source`
   * values against any array or object value, respectively. See `_.isEqual`
   * for a list of supported value comparisons.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   * @example
   *
   * var objects = [
   *   { 'a': 1, 'b': 2, 'c': 3 },
   *   { 'a': 4, 'b': 5, 'c': 6 }
   * ];
   *
   * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
   * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
   */
  function matches(source) {
    return baseMatches(assign({}, source));
  }

  /**
   * Adds all own enumerable string keyed function properties of a source
   * object to the destination object. If `object` is a function, then methods
   * are added to its prototype as well.
   *
   * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
   * avoid conflicts caused by modifying the original.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {Function|Object} [object=lodash] The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
   * @returns {Function|Object} Returns `object`.
   * @example
   *
   * function vowels(string) {
   *   return _.filter(string, function(v) {
   *     return /[aeiou]/i.test(v);
   *   });
   * }
   *
   * _.mixin({ 'vowels': vowels });
   * _.vowels('fred');
   * // => ['e']
   *
   * _('fred').vowels().value();
   * // => ['e']
   *
   * _.mixin({ 'vowels': vowels }, { 'chain': false });
   * _('fred').vowels();
   * // => ['e']
   */
  function mixin(object, source, options) {
    var props = keys(source),
        methodNames = baseFunctions(source, props);

    if (options == null &&
        !(isObject(source) && (methodNames.length || !props.length))) {
      options = source;
      source = object;
      object = this;
      methodNames = baseFunctions(source, keys(source));
    }
    var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
        isFunc = isFunction(object);

    baseEach(methodNames, function(methodName) {
      var func = source[methodName];
      object[methodName] = func;
      if (isFunc) {
        object.prototype[methodName] = function() {
          var chainAll = this.__chain__;
          if (chain || chainAll) {
            var result = object(this.__wrapped__),
                actions = result.__actions__ = copyArray(this.__actions__);

            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
            result.__chain__ = chainAll;
            return result;
          }
          return func.apply(object, arrayPush([this.value()], arguments));
        };
      }
    });

    return object;
  }

  /**
   * Reverts the `_` variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    if (root._ === this) {
      root._ = oldDash;
    }
    return this;
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseGt)
      : undefined;
  }

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseLt)
      : undefined;
  }

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.assignIn = assignIn;
  lodash.before = before;
  lodash.bind = bind;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.concat = concat;
  lodash.create = create;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.flattenDeep = flattenDeep;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.map = map;
  lodash.matches = matches;
  lodash.mixin = mixin;
  lodash.negate = negate;
  lodash.once = once;
  lodash.pick = pick;
  lodash.slice = slice;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.thru = thru;
  lodash.toArray = toArray;
  lodash.values = values;

  // Add aliases.
  lodash.extend = assignIn;

  // Add methods to `lodash.prototype`.
  mixin(lodash, lodash);

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.clone = clone;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.forEach = forEach;
  lodash.has = has;
  lodash.head = head;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.last = last;
  lodash.max = max;
  lodash.min = min;
  lodash.noConflict = noConflict;
  lodash.noop = noop;
  lodash.reduce = reduce;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.uniqueId = uniqueId;

  // Add aliases.
  lodash.each = forEach;
  lodash.first = head;

  mixin(lodash, (function() {
    var source = {};
    baseForOwn(lodash, function(func, methodName) {
      if (!hasOwnProperty.call(lodash.prototype, methodName)) {
        source[methodName] = func;
      }
    });
    return source;
  }()), { 'chain': false });

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  // Add `Array` methods to `lodash.prototype`.
  baseEach(['pop', 'join', 'replace', 'reverse', 'split', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
    var func = (/^(?:replace|split)$/.test(methodName) ? String.prototype : arrayProto)[methodName],
        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
        retUnwrapped = /^(?:pop|join|replace|shift)$/.test(methodName);

    lodash.prototype[methodName] = function() {
      var args = arguments;
      if (retUnwrapped && !this.__chain__) {
        var value = this.value();
        return func.apply(isArray(value) ? value : [], args);
      }
      return this[chainName](function(value) {
        return func.apply(isArray(value) ? value : [], args);
      });
    };
  });

  // Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return lodash;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "dgram":
/*!************************!*\
  !*** external "dgram" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dgram");

/***/ }),

/***/ "fcnode":
/*!*************************!*\
  !*** external "fcnode" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fcnode");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "guid-typescript":
/*!**********************************!*\
  !*** external "guid-typescript" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("guid-typescript");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "request":
/*!**************************!*\
  !*** external "request" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("request");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "ws":
/*!*********************!*\
  !*** external "ws" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ws");

/***/ })

/******/ })));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLi9jb25maWcuanNvblwiIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvYXBwLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL2Jpbi93d3cuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvY29tbXVuaWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbGliL2RhdGEtc291cmNlLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL2xpYi9zb3VyY2UvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9saWIvc291cmNlL2VmNS5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9saWIvc291cmNlL2ZjNy5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9saWIvc291cmNlL3BzNi5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvQnl0ZVN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvRGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9Gb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL1JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvUmVmZXJlbmNlUmVhZGVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9TZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9UeXBlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvVmFsdWVSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL1ZhbHVlV3JpdGVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9Xcml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvQXJyYXlEZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvQmFzZURlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9CaWdJbnRBcnJheURlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9CaWdJbnREZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvQm9vbGVhbkRlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9CeXRlU3RyZWFtRGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9kZXNlcmlhbGl6ZXJzL0RhdGVEZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvRGVmYXVsdERlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9FcnJvckRlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9GdW5jdGlvbkRlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9HdWlkRGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9kZXNlcmlhbGl6ZXJzL0ludERlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9NYXBEZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvTnVsbERlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9OdW1iZXJEZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL2Rlc2VyaWFsaXplcnMvU2V0RGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9kZXNlcmlhbGl6ZXJzL1N0cmluZ0Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvZGVzZXJpYWxpemVycy9UeXBlZEFycmF5RGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvc2VyaWFsaXplcnMvQXJyYXlTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9zZXJpYWxpemVycy9CYXNlU2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvc2VyaWFsaXplcnMvQmlnSW50QXJyYXlTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9zZXJpYWxpemVycy9CaWdJbnRTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9zZXJpYWxpemVycy9Cb29sZWFuU2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvc2VyaWFsaXplcnMvQnl0ZXNTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL2lvL2xpYi9zZXJpYWxpemVycy9EYXRlU2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvc2VyaWFsaXplcnMvRGljdGlvbmFyeVNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL0Vycm9yU2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9pby9saWIvc2VyaWFsaXplcnMvR3VpZFNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL01hcFNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL051bWJlclNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL09iamVjdFNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL1JlZmVyZW5jZVNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL1NldFNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL1N0cmluZ1NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvaW8vbGliL3NlcmlhbGl6ZXJzL1R5cGVkQXJyYXlTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9DbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL0NsaWVudENvZGVjLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9DbGllbnRDb250ZXh0LmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9Db250ZXh0LmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9Db29raWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9EZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtY29yZS9saWIvSU9NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9JbnZva2VNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1jb3JlL2xpYi9NZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL01ldGhvZE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL01vY2tBZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtY29yZS9saWIvTW9ja0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL01vY2tUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL1BsdWdpbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL1NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL1NlcnZpY2VDb2RlYy5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtY29yZS9saWIvU2VydmljZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL1RpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtY29yZS9saWIvVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLWNvcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1ub2RlL2xpYi9IdHRwSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtbm9kZS9saWIvSHR0cFRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtbm9kZS9saWIvU29ja2V0SGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtbm9kZS9saWIvU29ja2V0VHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1ub2RlL2xpYi9VZHBIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3JlYWwtc2VydmVyL25vZGVfbW9kdWxlcy9AaHByb3NlL3JwYy1ub2RlL2xpYi9VZHBUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLW5vZGUvbGliL1dlYlNvY2tldEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL0BocHJvc2UvcnBjLW5vZGUvbGliL1dlYlNvY2tldFRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9yZWFsLXNlcnZlci9ub2RlX21vZHVsZXMvQGhwcm9zZS9ycGMtbm9kZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcmVhbC1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb3JlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImRncmFtXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZmNub2RlXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJndWlkLXR5cGVzY3JpcHRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZXF1ZXN0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidGxzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXJsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwid3NcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7Ozs7QUN4SWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQ3pIYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEOzs7Ozs7Ozs7Ozs7QUM5UWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFFQUFVO0FBQ2pDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFFQUFVO0FBQ2pDO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsK0VBQWU7QUFDdEQ7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyw2RUFBYztBQUNwRDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLGlGQUFnQjtBQUN4RDtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLDJFQUFhO0FBQ2xEO0FBQ0EsbUNBQW1DLG1CQUFPLENBQUMsdUZBQW1CO0FBQzlEO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsK0VBQWU7QUFDdEQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQywrRUFBZTtBQUN0RDtBQUNBLGlDOzs7Ozs7Ozs7Ozs7QUMvQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJDOzs7Ozs7Ozs7Ozs7QUNuRGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVELDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1QjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRDs7Ozs7Ozs7Ozs7O0FDekRhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGdGQUFnQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBa0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUM3Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUN6Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDakRhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVELDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1QjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDOzs7Ozs7Ozs7Ozs7QUM1Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0Q7Ozs7Ozs7Ozs7OztBQ25FYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDL0NhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVELDRCQUE0QixtQkFBTyxDQUFDLDJHQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEM7Ozs7Ozs7Ozs7OztBQzlDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ3BEYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBa0I7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUNoRGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLGdGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUNsRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQzdDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ2pEYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsY0FBYztBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBdUI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUM1RGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsNEJBQTRCLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnRDs7Ozs7Ozs7Ozs7O0FDckRhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQixFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQsZ0RBQWdELDhDQUE4QyxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEIsRUFBRTtBQUM3RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QyxpQ0FBaUMsK0NBQStDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0M7Ozs7Ozs7Ozs7OztBQzdWYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxXQUFXLG1CQUFPLENBQUMsc0VBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHVDOzs7Ozs7Ozs7Ozs7QUNqRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUN2RGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQzFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQzdGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUN6QmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3Q0FBd0M7QUFDcEY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUN6Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQ0FBMkM7QUFDMUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUN6Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtDOzs7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsZUFBZSxtQkFBTyxDQUFDLDJFQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDNU1hO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUM3RWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFBWSxhQUFhLE9BQU8sRUFBRSxVQUFVLFdBQVc7QUFDaEUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQzVGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsZUFBZSxtQkFBTyxDQUFDLDJFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBWTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw0RkFBNEYsOEJBQThCLEVBQUUscUJBQXFCLDhCQUE4QixFQUFFO0FBQ2pMO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUMzRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ2xFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCx3Q0FBd0MsUUFBUTtBQUNoRCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywyRUFBVTtBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQixFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1DOzs7Ozs7Ozs7Ozs7QUNoUmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsV0FBVyxtQkFBTyxDQUFDLHNFQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3Qzs7Ozs7Ozs7Ozs7O0FDdElhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVELGdCQUFnQixtQkFBTyxDQUFDLDZFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDeENhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ25KYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxlQUFlLG1CQUFPLENBQUMsMkVBQVU7QUFDakM7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQztBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjtBQUMvQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFXO0FBQ25DO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBWTtBQUNyQztBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjtBQUMvQztBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjtBQUMvQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDJFQUFVO0FBQ2pDO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzdDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHlFQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkM7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDN0M7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBa0I7QUFDakQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQztBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3pEYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx3QkFBd0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUN0Qyx5QkFBeUIsbUJBQU8sQ0FBQyxvQkFBTztBQUN4QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsc0JBQXNCLG1CQUFPLENBQUMsY0FBSTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNFQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCLEVBQUUsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsYUFBYTtBQUNiLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7Ozs7QUNuVWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFBWSxhQUFhLE9BQU8sRUFBRSxVQUFVLFdBQVc7QUFDaEUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLHdCQUF3QixtQkFBTyxDQUFDLGtCQUFNO0FBQ3RDLHlCQUF5QixtQkFBTyxDQUFDLG9CQUFPO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFrQjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsc0VBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0QsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ2hNYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyxnQkFBSztBQUNwQyxXQUFXLG1CQUFPLENBQUMsc0VBQVk7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDOUxhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLGdCQUFLO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLGdCQUFLO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixXQUFXLG1CQUFPLENBQUMsc0VBQVk7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDJDOzs7Ozs7Ozs7Ozs7QUNqVWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFBWSxhQUFhLE9BQU8sRUFBRSxVQUFVLFdBQVc7QUFDaEUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMsb0JBQU87QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxzRUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLEVBQUUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7OztBQy9JYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx5QkFBeUIsbUJBQU8sQ0FBQyxvQkFBTztBQUN4QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxzRUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUIsRUFBRSxFQUFFO0FBQzdCLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUIsRUFBRTtBQUMzQjtBQUNBLHdEQUF3RCxxQ0FBcUMsRUFBRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUN0UGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFBWSxhQUFhLE9BQU8sRUFBRSxVQUFVLFdBQVc7QUFDaEUsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCwyQkFBMkIsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLGtCQUFNO0FBQ3RDLHlCQUF5QixtQkFBTyxDQUFDLG9CQUFPO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNFQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxFQUFFLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw0Qzs7Ozs7Ozs7Ozs7O0FDNUthO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsd0JBQXdCLG1CQUFPLENBQUMsa0JBQU07QUFDdEMseUJBQXlCLG1CQUFPLENBQUMsb0JBQU87QUFDeEMsMkJBQTJCLG1CQUFPLENBQUMsY0FBSTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNFQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNELDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCLEVBQUUsRUFBRTtBQUM3QixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDalFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjtBQUMvQztBQUNBLDJCQUEyQixtQkFBTyxDQUFDLG1HQUFzQjtBQUN6RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFtQjtBQUNuRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM3QztBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFlO0FBQzNDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3JEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWM7QUFDekM7QUFDQSxpQzs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEtBQTBCOztBQUU5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTtBQUNuQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QixFQUFFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QixlQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsTUFBTTtBQUNuQixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsRUFBRTtBQUNmLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU8sV0FBVztBQUMvQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUErQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0IsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxJQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzd3SEQsa0M7Ozs7Ozs7Ozs7O0FDQUEsbUM7Ozs7Ozs7Ozs7O0FDQUEsK0I7Ozs7Ozs7Ozs7O0FDQUEsNEM7Ozs7Ozs7Ozs7O0FDQUEsaUM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsb0M7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsK0IiLCJmaWxlIjoicmVhbC1zZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3JlYWwtc2VydmVyL2Jpbi93d3cuanNcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2NvbmZpZy5qc29uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsImNvbnN0IHsgU2VydmljZSB9ID0gcmVxdWlyZSgnQGhwcm9zZS9ycGMtY29yZScpO1xyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xyXG5jb25zdCBycGNOb2RlID0gcmVxdWlyZSgnQGhwcm9zZS9ycGMtbm9kZScpO1xyXG5jb25zdCBkYXRhU291cmNlID0gcmVxdWlyZSgnLi9saWIvZGF0YS1zb3VyY2UnKTtcclxuY29uc3QgY29tbXVuaWNhdGUgPSByZXF1aXJlKCcuL2NvbW11bmljYXRlJyk7XHJcblxyXG4vL+aPkOS+m+aVsOaNruaOpeWPo+WumuS5iVxyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHJlYWxTZXJ2ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5ydW4oKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuWQr+WKqOWHveaVsFxyXG4gICAgKi9cclxuICAgIHJ1bigpIHtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g5ZCv5Yqo5pyN5YqhOiAke3RoaXMuY29uZmlnLm5hbWV9IOerr+WPozoke3RoaXMuY29uZmlnLnVzZWRQb3J0fWApO1xyXG4gICAgICAgIC8v5Yid5aeL5YyWcnBjXHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNlcnZpY2UoKTtcclxuICAgICAgICB0aGlzLnNlcnZpY2UuYmluZChuZXcgV2ViU29ja2V0LlNlcnZlcih7IHBvcnQ6IHRoaXMuY29uZmlnLnVzZWRQb3J0IH0sIGFzeW5jIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZpY2Uud2Vic29ja2V0LmNvbXByZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy/nnJ/mraPnmoTku6PnkIbpgILphY3lmahcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dIOW8gOWni+WIm+W7uuW3peS9nOaooeWdl2ApO1xyXG4gICAgICAgICAgICB0aGlzLmFnZW50QWRhcHRlciA9IG5ldyBkYXRhU291cmNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dIOW8gOWni3JwY+acjeWKoeazqOWGjGApO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUnBjU2VydmljZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0gcnBj5pyN5Yqh5rOo5YaM5oiQ5YqfYCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWdlbnRBZGFwdGVyLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dIOWIm+W7uuW3peS9nOaooeWdl+aIkOWKnyzmnI3liqHlkK/liqjmiJDlip9gKTtcclxuICAgICAgICAgICAgLy/lkJFkYWVtb27miqXlkYrnmbvlvZXmiJDlip9cclxuICAgICAgICAgICAgYXdhaXQgY29tbXVuaWNhdGUucmVwb3J0KHRoaXMuY29uZmlnLnVzZWRQb3J0LCB0aGlzLmNvbmZpZy5uYW1lKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJScGNTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMuc2VydmljZS53ZWJzb2NrZXQub25hY2NlcHQgPSB0aGlzLm9uQWNjZXB0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlLndlYnNvY2tldC5vbmNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFkZCh7IG1ldGhvZDogdGhpcy5hZ2VudEFkYXB0ZXIuc3ViUmVhbERhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnc3ViUmVhbERhdGEnLCBwYXNzQ29udGV4dDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnNlcnZpY2UuYWRkKHsgbWV0aG9kOiB0aGlzLmFnZW50QWRhcHRlci5nZXRSZWFsRGF0YS5iaW5kKHRoaXMuYWdlbnRBZGFwdGVyKSwgZnVsbG5hbWU6ICdnZXRSZWFsRGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLnVuU3ViUmVhbERhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAndW5TdWJSZWFsRGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLmdldFRhZ0RhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnZ2V0VGFnRGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLmdldEhpc0RhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnZ2V0SGlzRGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLmdldEFsbURhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnZ2V0QWxtRGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLmdldFRhZ0luZm8uYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnZ2V0VGFnSW5mbycsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLmdldERhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnZ2V0RGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuYWdlbnRBZGFwdGVyLnNldERhdGEuYmluZCh0aGlzLmFnZW50QWRhcHRlciksIGZ1bGxuYW1lOiAnc2V0RGF0YScsIHBhc3NDb250ZXh0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5hZGQoeyBtZXRob2Q6IHRoaXMuaXNDb25uZWN0ZWQsIGZ1bGxuYW1lOiAnaXNDb25uZWN0ZWQnLCBwYXNzQ29udGV4dDogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIC8v5pyN5Yqh566h55CG5bel5YW36LCD55So55qE5o6l5Y+j44CC5Y+q6KaB5q2k5pyN5Yqh5ZCv5Yqo5LqG5bCx6L+U5ZuedHJ1ZeOAguS4juaVsOaNrua6kOaYr+WQpumTvuaOpeaXoOWFs1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy/mlrDov57mjqXlpITnkIZcclxuICAgIG9uQWNjZXB0KHdzKSB7XHJcbiAgICAgICAgLy/lrqLmiLfnq69baXA6cG9ydF3kvZzkuLrov57mjqXnmoRrZXnlgLxcclxuICAgICAgICBsZXQgY2xpZW50S2V5ID0gKHdzLl9zb2NrZXQucmVtb3RlQWRkcmVzcyArIFwiOlwiICsgd3MuX3NvY2tldC5yZW1vdGVQb3J0KS5zbGljZSg3KVxyXG4gICAgICAgIHRoaXMuYWdlbnRBZGFwdGVyLmFkZENsaWVudChjbGllbnRLZXkpO1xyXG4gICAgfVxyXG4gICAgLy/ov57mjqXmlq3lvIBcclxuICAgIG9uQ2xvc2Uod3MpIHtcclxuICAgICAgICAvL+WuouaIt+err1tpcDpwb3J0XeS9nOS4uui/nuaOpeeahGtleeWAvFxyXG4gICAgICAgIGxldCBjbGllbnRLZXkgPSAod3MuX3NvY2tldC5yZW1vdGVBZGRyZXNzICsgXCI6XCIgKyB3cy5fc29ja2V0LnJlbW90ZVBvcnQpLnNsaWNlKDcpXHJcbiAgICAgICAgdGhpcy5hZ2VudEFkYXB0ZXIuZGVsQ2xpZW50KGNsaWVudEtleSk7XHJcbiAgICB9XHJcbn0iLCIvL2RhZW1vbuWFqOWxgOmFjee9rlxyXG5nbG9iYWwuZGFlbW9uQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vZGFlbW9uL2NvbmZpZy9kZWZhdWx0LWNvbmZpZy5qc29uJyk7XHJcbi8vZGVidWdcclxuZ2xvYmFsLl9fZGVidWcgPSBmYWxzZTtcclxuY29uc3QgcmVhbFNlcnZlciA9IHJlcXVpcmUoXCIuLi9hcHAuanNcIik7XHJcbmNvbnN0IGNvbW11bmljYXRlID0gcmVxdWlyZSgnLi4vY29tbXVuaWNhdGUnKTtcclxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XHJcblxyXG4vL3JlYWwtc2VydmVy6Ieq5bex55qE6YWN572uXHJcbmdsb2JhbC5jb25maWdKc29uID0ge307XHJcbmlmIChwcm9jZXNzLmFyZ3ZbMl0gJiYgcHJvY2Vzcy5hcmd2WzJdID09PSBcImRlYnVnXCIpIHtcclxuICAgIGNvbmZpZ0pzb24gPSByZXF1aXJlKCcuLi9jb25maWcvZGVmYXVsdC1jb25maWcuanNvbicpO1xyXG4gICAgY29uZmlnSnNvbi51c2VkUG9ydCA9IHByb2Nlc3MuYXJndlszXSA/IHByb2Nlc3MuYXJndlszXSA6IDMwMDE7XHJcbiAgICBfX2RlYnVnID0gdHJ1ZTtcclxufSBlbHNlIHtcclxuICAgIGlmIChwcm9jZXNzLmFyZ3ZbMl0pIHtcclxuICAgICAgICB2YXIganNvblN0ciA9IG5ldyBCdWZmZXIuZnJvbShwcm9jZXNzLmFyZ3ZbMl0sICdiYXNlNjQnKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0pzb24gPSBKU09OLnBhcnNlKGpzb25TdHIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLplJnor6/nmoTphY3nva7lj4LmlbBcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24g5qOA5rWL5Y+v55So56uv5Y+j77yM5bm25ZCv5Yqoc2VydmVyXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnIOmFjee9rlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQb3J0QW5kU3RhcnQoY29uZmlnKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8v56uv5Y+jXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9ydCA9IGF3YWl0IGNvbW11bmljYXRlLmdldFBvcnQoKTtcclxuICAgICAgICBpZiAoc3RhcnRQb3J0ICYmIHN0YXJ0UG9ydC5wb3J0KSB7XHJcbiAgICAgICAgICAgIGxldCB1c2VkUG9ydCA9IGF3YWl0IGNoa0NhblVzZWRQb3J0KHN0YXJ0UG9ydC5wb3J0LCAwKTtcclxuICAgICAgICAgICAgLy9yZWFsLXNlcnZlcuS9v+eUqOerr+WPo1xyXG4gICAgICAgICAgICBjb25maWcudXNlZFBvcnQgPSB1c2VkUG9ydDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dIOW9k+WJjeS9v+eUqOerr+WPoyR7dXNlZFBvcnR9YCk7XHJcbiAgICAgICAgICAgIC8v5ZCv5YqoXHJcbiAgICAgICAgICAgIG5ldyByZWFsU2VydmVyKGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUl0g5pyq5om+5Yiw5Li75pyN5Yqh55qE6ZO+5o6l56uv5Y+jLDXnp5LlkI7ph43or5VgKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGVja1BvcnRBbmRTdGFydChjb25maWcpO1xyXG4gICAgICAgICAgICB9LCA1MDAwKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSAke2Vycm9yfWApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog5qOA5rWL5Y+v5Lul5L2/55So55qE56uv5Y+jXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0IOimgeajgOa1i+eahOerr+WPo1xyXG4gKiBAcGFyYW0ge251bWJlcn0gY3VyQ2hrVGltZSDlt7Lnu4/mo4DmtYvnmoTmrKHmlbDvvIzmnIDlpKflgLzmmK81MDBcclxuICovXHJcbmZ1bmN0aW9uIGNoa0NhblVzZWRQb3J0KHBvcnQsIGN1ckNoa1RpbWUpIHtcclxuICAgIGxldCBzZXJ2ZXIgPSBuZXQuY3JlYXRlU2VydmVyKCkubGlzdGVuKHBvcnQpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvL+ajgOa1i+asoeaVsOacgOWkp+WAvFxyXG4gICAgICAgIGNvbnN0IE1BWF9DSEtfVElNRVMgPSA1MDA7XHJcbiAgICAgICAgLy/nm5HlkKzliLBsaXN0ZW7kuovku7bvvIzor7TmmI7lvZPliY3nq6/lj6Plj6/nlKhcclxuICAgICAgICBzZXJ2ZXIub24oXCJsaXN0ZW5pbmdcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgcmVzb2x2ZShwb3J0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXJ2ZXIub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIC8v56uv5Y+j5Y2g55So6ZSZ6K+v77yM5LiA55u06YCS5b2S5Yiw5Y+v5Lul5L2/55So55qE56uv5Y+jXHJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRUFERFJJTlVTRScgJiYgY3VyQ2hrVGltZSA8PSBNQVhfQ0hLX1RJTUVTKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNoa0NhblVzZWRQb3J0KHBvcnQgKyAxLCBjdXJDaGtUaW1lICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRUFERFJJTlVTRScgJiYgY3VyQ2hrVGltZSA+IE1BWF9DSEtfVElNRVMpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gYOW3sue7j+i+vuWIsOacgOWkp+err+WPo+ajgOa1i+asoeaVsGA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcbn1cclxuXHJcbi8v5ZCv5YqocmVhbHNlcnZlclxyXG5jaGVja1BvcnRBbmRTdGFydChjb25maWdKc29uKTtcclxuIiwiLyoqXHJcbiAqIOS4jmRhZW1vbumAmuiur+eahGFwaVxyXG4gKi9cclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ3JlcXVlc3QnKTtcclxuXHJcbmNsYXNzIENvbW11bmljYXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaXAgPSAnMTI3LjAuMC4xJztcclxuICAgICAgICB0aGlzLnBvcnQgPSBkYWVtb25Db25maWcucG9ydDtcclxuICAgICAgICAvL+ivt+axgui3r+W+hOWJjee8gFxyXG4gICAgICAgIHRoaXMucHJlZml4ID0gJy9zZXJ2aWNlJztcclxuICAgIH1cclxuXHJcbiAgICByZXF1ZXN0R2V0KHVybCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXF1ZXN0LmdldCh7IHVybCwganNvbjogdHJ1ZSB9LCAoZXJyLCByZXNwb25jZSwgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uY2UgJiYgcmVzcG9uY2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBib2R5KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXF1ZXN0UG9zdCh1cmwsIHBhcmFtLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJlcXVlc3QucG9zdCh7IHVybCwganNvbjogdHJ1ZSwgYm9keTogcGFyYW0gfSwgKGVyciwgcmVzcG9uY2UsIGJvZHkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbmNlICYmIHJlc3BvbmNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGJvZHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluacjeWKoeimgeS9v+eUqOeahOWIneWni+err+WPo1xyXG4gICAgICovXHJcbiAgICBnZXRQb3J0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB1cmwgPSBgaHR0cDovLyR7dGhpcy5pcH06JHt0aGlzLnBvcnR9JHt0aGlzLnByZWZpeH0vcmVhbGA7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFBvc3QodXJsLCB7IFwidHlwZVwiOiBcImdldFBvcnRcIiwgXCJzZXJ2ZXJUeXBlXCI6IFwicmVhbFNlcnZlclwiIH0sIChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g6I635Y+W5pyN5Yqh6KaB5L2/55So55qE5Yid5aeL56uv5Y+jOiR7ZXJyfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55m75b2V5oiQ5Yqf5ZCRZGFlbW9u5oql5ZGK5pyN5Yqh5L2/55So55qE56uv5Y+jXHJcbiAgICAgKiBAcGFyYW0geyp9IGN1clVzZVBvcnQg5b2T5YmN5L2/55So55qE56uv5Y+jXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlcG9ydChjdXJVc2VQb3J0LCBzZXJ2ZXJOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHVybCA9IGBodHRwOi8vJHt0aGlzLmlwfToke3RoaXMucG9ydH0ke3RoaXMucHJlZml4fS9yZWFsYDtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UG9zdCh1cmwsIHsgXCJ0eXBlXCI6IFwicmVwb3J0XCIsIGN1clVzZVBvcnQsIFwic2VydmVyVHlwZVwiOiBcInJlYWxTZXJ2ZXJcIiwgc2VydmVyTmFtZSB9LCAoZXJyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLmnKrmib7liLBkYWVtb27mnI3liqHlmags6Iul5pys5qyh5pyq5ZCv5Yqo6LCD6K+V5ZCv5Yqo6K+35b+955Wl77yBXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG4vL+WNleS+i+aooeW8j1xyXG5sZXQgY29tbXVuaWNhdGUgPSBudWxsO1xyXG5pZiAoY29tbXVuaWNhdGUgPT09IG51bGwpIHtcclxuICAgIGNvbW11bmljYXRlID0gbmV3IENvbW11bmljYXRlKCk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBjb21tdW5pY2F0ZTsiLCJjb25zdCBkYXRhRkM3ID0gcmVxdWlyZSgnLi9zb3VyY2UvZmM3Jyk7XHJcbmNvbnN0IGRhdGFFRjUgPSByZXF1aXJlKCcuL3NvdXJjZS9lZjUnKTtcclxuY29uc3QgZGF0YVBTNiA9IHJlcXVpcmUoJy4vc291cmNlL3BzNicpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgc3dpdGNoKGNvbmZpZy50eXBlKXtcclxuICAgICAgICBjYXNlIFwiZWY1XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGF0YUVGNShjb25maWcpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJwczZcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBkYXRhUFM2KGNvbmZpZyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImZjN1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGRhdGFGQzcoY29uZmlnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+S4jeWtmOWcqOeahOaVsOaNrua6kOexu+WeizonICsgY29uZmlnLnR5cGUpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn0iLCJjb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcclxuY29uc3QgRlJ0ZGIgPSByZXF1aXJlKCdmY25vZGUnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBkYXRhU291cmNlQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvL+aJgOacieWuouaIt+err+i/nuaOpeS/oeaBr1xyXG4gICAgICAgIHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm8gPSB7fTtcclxuICAgICAgICAvL+WFqOWxgOi9ruivouivt+axgueCueWIl+ihqFxyXG4gICAgICAgIHRoaXMuR2xvYmFsUmVxdWVzdERhdGEgPSB7XHJcbiAgICAgICAgICAgIC8qICAgIFxyXG4gICAgICAgICAgICB0YWduYW1lK3Bhck5hbWU6e1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6MTEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyTmFtZToyMixcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VmFsdWU6e31cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTp7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25uZWN0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIC8v5Yid5aeL5YyWZmNub2RlXHJcbiAgICAgICAgdGhpcy5kYiA9IG5ldyBGUnRkYihcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuaXAsXHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnBvcnQsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGRpYWxlY3Q6IHRoaXMuY29uZmlnLnNvdXJjZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBkaWFsZWN0OiB0aGlzLmNvbmZpZy50eXBlLFxyXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMuY29uZmlnLnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuY29uZmlnLnBhc3N3b3JkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkQ2xpZW50KGNsaWVudEtleSkge1xyXG4gICAgICAgIC8v5a6i5oi356uv5LiN5a2Y5ZyoXHJcbiAgICAgICAgaWYgKHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50S2V5XSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldID0ge1xyXG4gICAgICAgICAgICAgICAgcmVnRGF0YToge30sXHJcbiAgICAgICAgICAgICAgICBzaGVsbFJlZ0RhdGE6IHt9LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlRGF0YTogW10sLy/ov5Tlm57nu5nlrqLmiLfnq6/lsZ7mgKdcclxuICAgICAgICAgICAgICAgIGxhc3RUaW1lOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dIOaWsOWinuWuouaIt+err+i/nuaOpToke2NsaWVudEtleX1gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g5a6i5oi356uv5bey5a2Y5ZyoOiR7Y2xpZW50S2V5fWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlbENsaWVudChjbGllbnRLZXkpIHtcclxuICAgICAgICAvL+WuouaIt+err+S4jeWtmOWcqFxyXG4gICAgICAgIGlmICghdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSDliKDpmaTlrqLmiLfnq6/lpLHotKU6JHtjbGllbnRLZXl9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy/ms6jplIDlrqLmiLfnq6/miYDmnInngrlcclxuICAgICAgICAgICAgXy5tYXAodGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldLnJlZ0RhdGEsICh0YWcsIHRhZ05hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIF8ubWFwKHRhZywgKHBhck9iaiwgcGFyTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1bmlxdWVrZXkgPSB0YWdOYW1lICsgXCIuXCIgKyBwYXJOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaW5kID0gdGhpcy5HbG9iYWxSZXF1ZXN0RGF0YVt1bmlxdWVrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmQucmVmQ291bnQgLT0gcGFyT2JqLnJlZkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W8leeUqOiuoeaVsOS4ujDml7bvvIzliKDpmaRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmQucmVmQ291bnQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuR2xvYmFsUmVxdWVzdERhdGFbdW5pcXVla2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudEtleV07XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSDmiJDlip/liKDpmaTlrqLmiLfnq686JHtjbGllbnRLZXl9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIGdldENsaWVudChjbGllbnRLZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50S2V5XSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g6I635Y+W5a6i5oi356uv5a+56LGh5aSx6LSlOiR7Y2xpZW50S2V5fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldXHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrms6jlhozngrlcclxuICAgICAgICDlj4LmlbA6Y2xpZW50S2V5OuazqOWGjOWIsOeahOi/nuaOpeagh+ekulxyXG4gICAgICAgICAgICBqc29uIDog5rOo5YaM55qE5L+h5oGvXHJcbiAgICAgICAgICAgIHJlZmVyZW5jZSA6IOaYr+WQpuazqOWGjOOAgmZhbHNl5qCH56S65Y+q5Y+W5b2T5YmN5YC85bm25LiN5rOo5YaMXHJcbiAgICAgICAg6L+U5Zue5YC8OuazqOWGjOeCueeahOW9k+WJjeWAvFxyXG4gICAgKi9cclxuICAgIGFzeW5jIHJlZ2lzdGVyKGNsaWVudEtleSwganNvbiwgcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgLy/mnKzlnLDmmK/lkKblhYjor7fmsYLkuIDmrKHvvIzojrflj5bliJ3lgLxcclxuICAgICAgICBsZXQgY3VycmVudFJlcXVlc3QgPSBbXTtcclxuICAgICAgICAvL+WkhOeQhuW9k+WJjei/nuaOpeW8leeUqOiuoeaVsFxyXG4gICAgICAgIGpzb24ubWFwKChyZXF1ZXN0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGFnSW5mbyA9IHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50S2V5XS5yZWdEYXRhW3JlcXVlc3REYXRhLnRhZ05hbWVdO1xyXG4gICAgICAgICAgICBpZiAodGFnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgLy/lvZPliY3ms6jlhozlsZ7mgKfoi6XlrZjlnKgrMe+8jOS4jeWtmOWcqOWIm+W7ulxyXG4gICAgICAgICAgICAgICAgbGV0IHBhck9iaiA9IHRhZ0luZm9bcmVxdWVzdERhdGEucGFyTmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJPYmoucmVmQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0luZm9bcmVxdWVzdERhdGEucGFyTmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAtOTk5OSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkNvdW50OiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/liJvlu7rngrnlr7nosaHku6Xlj4rlsZ7mgKdcclxuICAgICAgICAgICAgICAgIHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50S2V5XS5yZWdEYXRhW3JlcXVlc3REYXRhLnRhZ05hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFtyZXF1ZXN0RGF0YS5wYXJOYW1lXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogLTk5OTksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZDb3VudDogMVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvZPliY3or7fmsYLngrnkv6Hmga/vvIzmmK/lkKblnKjlhajlsYDliJfooajkuK3lrZjlnKgg5a2Y5Zyo5byV55SoKzFcclxuICAgICAgICAgICAgbGV0IHVuaXF1ZWtleSA9IHJlcXVlc3REYXRhLnRhZ05hbWUgKyBcIi5cIiArIChyZXF1ZXN0RGF0YS5wYXJOYW1lIHx8IFwicHZcIik7XHJcbiAgICAgICAgICAgIGxldCBmaW5kID0gdGhpcy5HbG9iYWxSZXF1ZXN0RGF0YVt1bmlxdWVrZXldO1xyXG4gICAgICAgICAgICBpZiAoZmluZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQucmVmQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8v5LiN5a2Y5Zyo6ZyA6KaB5Yqg5Yiw5YWo5bGA5YiX6KGo77yM562J5b6F5LiL5LiA5qyh57uf5LiA6K+35rGCXHJcbiAgICAgICAgICAgICAgICB0aGlzLkdsb2JhbFJlcXVlc3REYXRhW3VuaXF1ZWtleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogcmVxdWVzdERhdGEudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJOYW1lOiByZXF1ZXN0RGF0YS5wYXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dE5hbWU6IHJlcXVlc3REYXRhLmV4dE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmQ291bnQ6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVxdWVzdC5wdXNoKHJlcXVlc3REYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UmVxdWVzdDtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuazqOmUgOeCuVxyXG4gICAgICAgIOWPguaVsDpjbGllbnRLZXk66ZyA6KaB5rOo6ZSA55qE6L+e5o6l5qCH56S6XHJcbiAgICAgICAgICAgIGpzb24gOiDms6jplIDnmoTkv6Hmga9cclxuICAgICAgICAgICAgcmVmZXJlbmNlIDog5piv5ZCm5rOo6ZSA44CCZmFsc2XmoIfnpLrlj6rlj5blvZPliY3lgLzlubbkuI3ms6jplIBcclxuICAgICAgICDov5Tlm57lgLw65rOo5YaM54K555qE5b2T5YmN5YC8XHJcbiAgICAqL1xyXG4gICAgdW5SZWdpc3RlcihjbGllbnRLZXksIGpzb24sIHJlZmVyZW5jZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBcIlwiLFxyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WuouaIt+err+S4jeWtmOWcqFxyXG4gICAgICAgIGlmICghdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSBjbGllbnQgbm90IGV4aXN0LmNsaWVudGluZm86OiR7Y2xpZW50S2V5fWApO1xyXG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBcImNsaWVudCBub3QgZXhpc3RcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lpITnkIblvZPliY3ov57mjqXlvJXnlKjorqHmlbBcclxuICAgICAgICBqc29uLm1hcCgocmVxdWVzdERhdGEpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRhZ0luZm8gPSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudEtleV0ucmVnRGF0YVtyZXF1ZXN0RGF0YS50YWdOYW1lXTtcclxuICAgICAgICAgICAgaWYgKHRhZ0luZm8pIHtcclxuICAgICAgICAgICAgICAgIC8v5b2T5YmN5rOo6ZSA5bGe5oCn6Iul5a2Y5ZyoIOiuoeaVsC0x77yM6K6h5pWw5Li6MCDliKDpmaTlsZ7mgKdcclxuICAgICAgICAgICAgICAgIGxldCBwYXJPYmogPSB0YWdJbmZvW3JlcXVlc3REYXRhLnBhck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhck9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyT2JqLnJlZkNvdW50IC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8v6K6h5pWw5Li6MOaXtu+8jOWIoOmZpOWxnuaAp1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJPYmoucmVmQ291bnQgPT0gMCkgZGVsZXRlIHRhZ0luZm9bcmVxdWVzdERhdGEucGFyTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IFwiZXJyb3I6dGFnIHByb3Agbm90IGV4aXN0IGluIGNsaWVudCB3aGVuIHVuU3ViUmVhbERhdGEuY2xpZW50SW5mbzpcIjtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciArPSBjbGllbnRLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gXCIgdGFnaW5mbzogXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gcmVxdWVzdERhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtSRUFMLVNFUlZFUiAke2NvbmZpZ0pzb24ubmFtZX1dICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+eCueaJgOacieWxnuaAp+iuoeaVsOS4ujDml7bvvIzliKDpmaTngrlcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzRW1wdHkodGFnSW5mbykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1tjbGllbnRLZXldLnJlZ0RhdGFbcmVxdWVzdERhdGEudGFnTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBcImVycm9yOnRhZyBub3QgZXhpc3QgaW4gY2xpZW50IHdoZW4gdW5TdWJSZWFsRGF0YS5jbGllbnRJbmZvOlwiO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gY2xpZW50S2V5O1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gXCIgdGFnaW5mbzogXCI7XHJcbiAgICAgICAgICAgICAgICBlcnJvciArPSByZXF1ZXN0RGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5b2T5YmN6K+35rGC54K55L+h5oGv77yM5piv5ZCm5Zyo5YWo5bGA5YiX6KGo5Lit5a2Y5ZyoIOWtmOWcqOW8leeUqC0xXHJcbiAgICAgICAgICAgIGxldCB1bmlxdWVrZXkgPSByZXF1ZXN0RGF0YS50YWdOYW1lICsgXCIuXCIgKyAocmVxdWVzdERhdGEucGFyTmFtZSB8fCBcInB2XCIpO1xyXG4gICAgICAgICAgICBsZXQgZmluZCA9IHRoaXMuR2xvYmFsUmVxdWVzdERhdGFbdW5pcXVla2V5XTtcclxuICAgICAgICAgICAgaWYgKGZpbmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5kLnJlZkNvdW50LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+W8leeUqOiuoeaVsOS4ujDml7bvvIzliKDpmaRcclxuICAgICAgICAgICAgICAgIGlmIChmaW5kLnJlZkNvdW50ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5HbG9iYWxSZXF1ZXN0RGF0YVt1bmlxdWVrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gXCJlcnJvcjp0YWcgbm90IGV4aXN0IGluIGdsb2JhbCB3aGVuIHVuU3ViUmVhbERhdGEuY2xpZW50SW5mbzpcIjtcclxuICAgICAgICAgICAgICAgIGVycm9yICs9IGNsaWVudEtleTtcclxuICAgICAgICAgICAgICAgIGVycm9yICs9IFwiIHRhZ2luZm86IFwiO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gcmVxdWVzdERhdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0gJHtlcnJvcn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrliJ3lp4vljJbmlbDmja7mupDov57mjqVcclxuICAgICAgICDlj4LmlbA65pegXHJcbiAgICAgICAg6L+U5Zue5YC8OuaXoFxyXG4gICAgKi9cclxuICAgIGFzeW5jIGNvbm5lY3QoaXNSZUNvbm5lY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIC8v6L+e5o6l5a6e5pe25bqTXHJcbiAgICAgICAgaWYgKGlzUmVDb25uZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSDmlbDmja7mupDnrKwgJHt0aGlzLmNvbm5lY3RDb3VudH0g5qyh6YeN5paw6L+e5o6lYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXQgPSBhd2FpdCB0aGlzLmRiLmxvZ2luKCk7XHJcbiAgICAgICAgaWYgKHJldCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIC8v6L+e5o6l5oiQ5YqfLOWRqOacn+ivt+axguWunuaXtuaVsOaNrlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMucG9sbFJlcXVlc3QuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5tYW5hZ2VyQ2FjaGUuYmluZCh0aGlzKSwzNjAwMDAwKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQWxsVGFncygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8v6YeN5paw6L+e5o6lXHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdENvdW50Kys7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRydWUpO1xyXG4gICAgICAgICAgICB9LCAzMDAwMCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSDlrp7ml7blupM6JHt0aGlzLmNvbmZpZy5pcH0g57G75Z6LOiAke3RoaXMuY29uZmlnLnR5cGV9IOeKtuaAgTog562J5b6F6YeN5paw6L+e5o6lYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuWKoOi9veaVsOaNruW6k+eCueihqFxyXG4gICAgICAgIOWPguaVsDrml6BcclxuICAgICAgICDov5Tlm57lgLw65pegXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgbG9hZEFsbFRhZ3MoKSB7XHJcblxyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5omA5pyJ5bqU6K+35rGC54K5XHJcbiAgICAgICAg5Y+C5pWwOui/nuaOpeWQjeensFxyXG4gICAgICAgIOi/lOWbnuWAvDrmiYDmnInlupTor7fmsYLngrlcclxuICAgICovXHJcbiAgICBnZXRUYWdzKGNsaWVudEtleSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2xpZW50S2V5ID09IFwic3RyaW5nXCIgJiYgY2xpZW50S2V5ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudEtleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og70657yT5a2Y5Y+Y5YyW54K55L+h5oGvXHJcbiAgICAgICAg5Y+C5pWwOnJlc3BvbmVEYXRh6K+35rGC5a6e5pe257uT5p6cXHJcbiAgICAgICAgICAgIHJlcXVlc3REYXRh6K+35rGC5L+h5oGvXHJcbiAgICAgICAg6L+U5Zue5YC8OuaXoFxyXG4gICAgKi9cclxuICAgIGNhY2hlRGF0YShyZXNwb25lRGF0YSwgcmVxdWVzdERhdGEpIHtcclxuICAgICAgICByZXNwb25lRGF0YS5tYXAoKGRhdGEsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmKHJlcXVlc3REYXRhW2luZGV4XS5nbG9iYWxSZWYpe1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbaW5kZXhdLmdsb2JhbFJlZi5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGllbnQgPSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdGFnTmFtZSBpbiBjbGllbnQuc2hlbGxSZWdEYXRhKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGFnTmFtZSA9PSBkYXRhLnRhZ05hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnNoZWxsUmVnRGF0YVt0YWdOYW1lXS52YWx1ZSA9IHJlc3BvbmVEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5bCG5YC85pu05paw5Yiw5ZCE5Liq5a6i5oi356uv5LitXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm8pIHtcclxuICAgICAgICAgICAgLy/ljZXkuKrlrqLmiLfnq69cclxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mb1trZXldO1xyXG4gICAgICAgICAgICAvL3JlZ0RhdGEg5q+P5Liq5a6i5oi356uv5a2Y55qE54K55ZCNam9zblxyXG4gICAgICAgICAgICBmb3IgKGxldCB0YWdOYW1lIGluIGNsaWVudC5yZWdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvL+avj+S4queCueS4i+S/neWtmOaJgOacieWxnuaAp+WQjeensFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcGFyTmFtZSBpbiBjbGllbnQucmVnRGF0YVt0YWdOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5LuO5YWo5bGA5Lit6I635Y+W5pyA5paw5YC8XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhdGVzdERhdGEgPSB0aGlzLkdsb2JhbFJlcXVlc3REYXRhW3RhZ05hbWUgKyBcIi5cIiArIHBhck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5pqC5pe255yL5YC877yM5pe26Ze05oizIOi0qOmHj+aIs+acquiAg+iZkVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQucmVnRGF0YVt0YWdOYW1lXVtwYXJOYW1lXS5kYXRhLnZhbHVlICE9IGxhdGVzdERhdGEuZGF0YS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQucmVnRGF0YVt0YWdOYW1lXVtwYXJOYW1lXS5kYXRhLnZhbHVlID0gbGF0ZXN0RGF0YS5kYXRhLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQucmVnRGF0YVt0YWdOYW1lXVtwYXJOYW1lXS5kYXRhLnRpbWUgPSBsYXRlc3REYXRhLmRhdGEudGltZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnJlZ0RhdGFbdGFnTmFtZV1bcGFyTmFtZV0uZGF0YS5xdWFsaXR5ID0gbGF0ZXN0RGF0YS5kYXRhLnF1YWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuY2hhbmdlRGF0YS5sZW5ndGggPiAxNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LmNoYW5nZURhdGEuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WAvOS4jeebuOetie+8jOabtOaWsO+8jOW5tuS4lOS/neWtmOWIsOabtOaWsOekvOaLnOS4rVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuY2hhbmdlRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dE5hbWU6IGxhdGVzdERhdGEuZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhck5hbWU6IHBhck5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBsYXRlc3REYXRhLmRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuWHhuWkh+WunuaXtuaVsOaNruivt+axgiznvJPlrZjkuIDmrKHmlbDmja4s5qC55o2ucmVmZXJlbmNl5Yaz5a6a5piv5ZCm5rOo5YaM54K5XHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgICAgICByZWZlcmVuY2U65piv5ZCm5rOo5YaMXHJcbiAgICAgICAg6L+U5Zue5YC8OuacquazqOWGjOeCueeahOesrOS4gOasoee8k+WtmOWAvFxyXG4gICAgKi9cclxuICAgIGFzeW5jIHByZXBhcmVSZWFsRGF0YShqc29uLCB0b2tlbiwgY29udGV4dCwgcmVmZXJlbmNlID0gdHJ1ZSkge1xyXG4gICAgICAgIGxldCBjbGllbnRLZXkgPSAoY29udGV4dC5yZW1vdGVBZGRyZXNzLmFkZHJlc3MgKyBcIjpcIiArIGNvbnRleHQucmVtb3RlQWRkcmVzcy5wb3J0KS5zbGljZSg3KTtcclxuICAgICAgICBsZXQgY3VycmVudFJlcXVlc3QgPSBhd2FpdCB0aGlzLnJlZ2lzdGVyKGNsaWVudEtleSwganNvbiwgcmVmZXJlbmNlKTtcclxuICAgICAgICAvL+ivt+axguWbnuadpeaVsOaNruWIt+aWsOWIsOWFqOWxgOWIl+ihqOS4rVxyXG4gICAgICAgIGlmIChjdXJyZW50UmVxdWVzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8v5Yqg5Yiw5pys5Zyw5YiX6KGo77yM5YWI6K+35rGC5LiA5qyhXHJcbiAgICAgICAgICAgIGxldCByZXF1ZXN0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRSZXF1ZXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdERhdGEgPSBjdXJyZW50UmVxdWVzdFtpXTtcclxuICAgICAgICAgICAgICAgIGxldCB1bmlxdWVrZXkgPSByZXF1ZXN0RGF0YS50YWdOYW1lICsgXCIuXCIgKyAocmVxdWVzdERhdGEucGFyTmFtZSB8fCBcInB2XCIpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdExpc3QucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogcmVxdWVzdERhdGEudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJJZDogdGhpcy5Nb2RlUHJvcGVydHlbcmVxdWVzdERhdGEucGFyTmFtZV0uaWQgfHwgMTMsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsUmVmOiB0aGlzLkdsb2JhbFJlcXVlc3REYXRhW3VuaXF1ZWtleV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCByZXNwb25lRGF0YSA9IGF3YWl0IHRoaXMuZGIuZ2V0RGF0YShyZXF1ZXN0TGlzdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXJyb3IocmVzcG9uZURhdGEucmV0Q29kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25lRGF0YS5yZXRDb2RlID09IC0xOTk5Nykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5b2T5YmNZmNOb2Rl5peg5rOV6L+U5ZueIC0xOTk5NyDplJnor69cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g6YOo5YiG6ZSZ6K+vYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25lRGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uZURhdGEuZGF0YS5tYXAoKGRhdGEsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0W2luZGV4XS5nbG9iYWxSZWYuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUkVBTC1TRVJWRVIgJHtjb25maWdKc29uLm5hbWV9XSAke3Jlc3BvbmVEYXRhLnJldENvZGV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlQ29ubmVjdChyZXNwb25lRGF0YS5yZXRDb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WGjeS7juWFqOWxgOWIl+ihqOS4re+8jOaKiuW9k+WJjeWPmOmHj+etm+mAieWbnuadpVxyXG4gICAgICAgIGxldCByZXN1bHREYXRhID0ganNvbi5tYXAoKHJlcXVlc3REYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB1bmlxdWVrZXkgPSByZXF1ZXN0RGF0YS50YWdOYW1lICsgXCIuXCIgKyAocmVxdWVzdERhdGEucGFyTmFtZSB8fCBcInB2XCIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhck5hbWU6IHJlcXVlc3REYXRhLnBhck5hbWUsXHJcbiAgICAgICAgICAgICAgICBleHROYW1lOiB0aGlzLkdsb2JhbFJlcXVlc3REYXRhW3VuaXF1ZWtleV0uZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuR2xvYmFsUmVxdWVzdERhdGFbdW5pcXVla2V5XS5kYXRhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdERhdGE7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrms6jplIDngrnvvIjlj6/op4bkuLrms6jplIDngrnlh73mlbDlr7nlpJbmj5DkvpvnmoTlh73mlbDliKvlkI3vvIlcclxuICAgICAgICDlj4LmlbA6anNvbjror7fmsYLkv6Hmga/jgIJcclxuICAgICAgICAgICAgdG9rZW465pqC5pyq6LW35pWI44CCXHJcbiAgICAgICAgICAgIGNvbnRleHQ66L+e5o6l5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHJlZmVyZW5jZTrmmK/lkKbms6jplIBcclxuICAgICAgICDov5Tlm57lgLw65pegXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgdW5wcmVwYXJlUmVhbERhdGEoanNvbiwgdG9rZW4sIGNvbnRleHQsIHJlZmVyZW5jZSA9IHRydWUpIHtcclxuICAgICAgICBsZXQgY2xpZW50S2V5ID0gKGNvbnRleHQucmVtb3RlQWRkcmVzcy5hZGRyZXNzICsgXCI6XCIgKyBjb250ZXh0LnJlbW90ZUFkZHJlc3MucG9ydCkuc2xpY2UoNylcclxuICAgICAgICB0aGlzLnVuUmVnaXN0ZXIoY2xpZW50S2V5LCBqc29uLCByZWZlcmVuY2UpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5b2T5YmN6L+e5o6l55qE5Y+Y5YyW5a6e5pe25YC8XHJcbiAgICAgICAg5Y+C5pWwOlxyXG4gICAgICAgIHRva2VuOuaaguacquS9v+eUqFxyXG4gICAgICAgIGNvbnRleHQ66L+e5o6l5L+h5oGvXHJcbiAgICAgICAg6L+U5Zue5YC8OlxyXG4gICAgKi9cclxuICAgIGdldFJlYWxEYXRhKHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHJlc3BvbmVEYXRhID0gW107XHJcbiAgICAgICAgbGV0IGNsaWVudEtleSA9IChjb250ZXh0LnJlbW90ZUFkZHJlc3MuYWRkcmVzcyArIFwiOlwiICsgY29udGV4dC5yZW1vdGVBZGRyZXNzLnBvcnQpLnNsaWNlKDcpO1xyXG4gICAgICAgIGxldCB0YWdzID0gdGhpcy5nZXRUYWdzKGNsaWVudEtleSk7XHJcbiAgICAgICAgaWYgKHRhZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHRhZ3MuY2hhbmdlRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL+WFi+mahui/lOWbnlxyXG4gICAgICAgICAgICAgICAgcmVzcG9uZURhdGEgPSBfLmNsb25lKHRhZ3MuY2hhbmdlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvL+ivt+axguS4gOasoeWQjua4heepulxyXG4gICAgICAgICAgICAgICAgdGFncy5jaGFuZ2VEYXRhID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbmVEYXRhO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7065pqC5pyq5a6e546wXHJcbiAgICAgICAg5Y+C5pWwOiAgIG5hbWU654K55ZCN56ewXHJcbiAgICAgICAgICAgICAgICB0b2tlbjrmmoLmnKrkvb/nlKhcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ66L+e5o6l5L+h5oGvXHJcbiAgICAgICAg6L+U5Zue5YC8OuaaguacquehruWumlxyXG4gICAgKi9cclxuICAgIC8v6L2u6K+i5p+l54K55YC8XHJcbiAgICBnZXRUYWdEYXRhKG5hbWUsIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHRtcCA9IFtdO1xyXG4gICAgICAgIHJldHVybiB0bXA7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrms6jlhozngrlcclxuICAgICAgICDlj4LmlbA6ICAganNvbjrngrnlkI3np7BcclxuICAgICAgICAgICAgICAgIHRva2VuOuaaguacquS9v+eUqFxyXG4gICAgICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga9cclxuICAgICAgICDov5Tlm57lgLw6XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgc3ViUmVhbERhdGEoanNvbiwgdG9rZW4sIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlUmVhbERhdGEoanNvbiwgdG9rZW4sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7065rOo6ZSA54K5XHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDpcclxuICAgICovXHJcbiAgICBhc3luYyB1blN1YlJlYWxEYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudW5wcmVwYXJlUmVhbERhdGEoanNvbiwgdG9rZW4sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5Y6G5Y+y5pWw5o2uXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrljoblj7LmlbDmja5cclxuICAgICovXHJcbiAgICBhc3luYyBnZXRIaXNEYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwi5a2Q57G75b+F6aG75a6M5oiQ5q2kIGdldEhpc0RhdGEg5o6l5Y+jXCIpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5oql6K2m5pWw5o2uXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrmiqXorabmlbDmja5cclxuICAgICovXHJcbiAgICBhc3luYyBnZXRBbG1EYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwi5a2Q57G75b+F6aG75a6M5oiQ5q2kIGdldEFsbURhdGEg5o6l5Y+jXCIpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W54K55L+h5oGvXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrngrnkv6Hmga9cclxuICAgICovXHJcbiAgICBhc3luYyBnZXRUYWdJbmZvKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnVHJlZTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluWunuaXtuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65q2k6ZO+5o6l55qE5Y+Y5YyW5a6e5pe25YC8XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgZ2V0RGF0YShhcnJKc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIuWtkOexu+W/hemhu+WujOaIkOatpCBnZXREYXRhIOaOpeWPo1wiKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuaVsOaNruS4i+e9rlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw6XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgc2V0RGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIuWtkOexu+W/hemhu+WujOaIkOatpCBzZXREYXRhIOaOpeWPo1wiKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuWRqOacn+S7juaVsOaNrua6kOafpeivouaVsOaNrlxyXG4gICAgICAgIOWPguaVsDrml6BcclxuICAgICAgICDov5Tlm57lgLw65pegXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgcG9sbFJlcXVlc3QoKSB7XHJcbiAgICAgICAgLy/mnoTpgKDor7fmsYLnu5PmnoRcclxuICAgICAgICBsZXQgcmVxdWVzdERhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5HbG9iYWxSZXF1ZXN0RGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IHRoaXMuR2xvYmFsUmVxdWVzdERhdGFba2V5XTtcclxuICAgICAgICAgICAgcmVxdWVzdERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiByZXF1ZXN0SW5mby50YWdOYW1lLFxyXG4gICAgICAgICAgICAgICAgcGFySWQ6IHRoaXMuTW9kZVByb3BlcnR5W3JlcXVlc3RJbmZvLnBhck5hbWVdLmlkIHx8IDEzLFxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsUmVmOiByZXF1ZXN0SW5mb1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBjbGllbnQgaW4gdGhpcy53ZWJDbGllbnRSZWdEYXRhSW5mbykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZUtleSBpbiB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudF0uc2hlbGxSZWdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2hlbGxSZWdEYXRhSW5mbyA9IHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50XS5zaGVsbFJlZ0RhdGFbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogY2FjaGVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFySWQ6IHNoZWxsUmVnRGF0YUluZm8ucGFySWQgfHwgMTNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0RGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8v5ZCR5pyN5Yqh56uv6K+35rGCICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCByZXNwb25lRGF0YSA9IGF3YWl0IHRoaXMuZGIuZ2V0RGF0YShyZXF1ZXN0RGF0YSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXJyb3IocmVzcG9uZURhdGEucmV0Q29kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25lRGF0YS5yZXRDb2RlID09IC0xOTk5Nykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5b2T5YmNZmNOb2Rl5peg5rOV6L+U5ZueIC0xOTk5NyDplJnor69cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0g6YOo5YiG6ZSZ6K+vYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25lRGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZURhdGEocmVzcG9uZURhdGEuZGF0YSwgcmVxdWVzdERhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1JFQUwtU0VSVkVSICR7Y29uZmlnSnNvbi5uYW1lfV0gJHtyZXNwb25lRGF0YS5yZXRDb2RlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSZUNvbm5lY3QocmVzcG9uZURhdGEucmV0Q29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnBvbGxSZXF1ZXN0LmJpbmQodGhpcyksIDEwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIG1hbmFnZXJDYWNoZSgpe1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvKSB7XHJcbiAgICAgICAgICAgIGxldCBjbGllbnQgPSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2tleV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRhZ05hbWUgaW4gY2xpZW50LnNoZWxsUmVnRGF0YSl7XHJcbiAgICAgICAgICAgICAgICBpZihuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGNsaWVudC5zaGVsbFJlZ0RhdGFbdGFnTmFtZV0ubGl2ZVRpbWUgPiAyNCAqIDYwICogNjAgKiAxMDAwKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2xpZW50LnNoZWxsUmVnRGF0YVt0YWdOYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMubWFuYWdlckNhY2hlLmJpbmQodGhpcyksMzYwMDAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNSZUNvbm5lY3QocmV0Q29kZSkge1xyXG4gICAgICAgIGlmIChyZXRDb2RlID09IC0xOTc5NSAvL+i/nuaOpeWksei0pVxyXG4gICAgICAgICAgICB8fCByZXRDb2RlID09IC0xOTc5MSAvL+ayoeaciei/nuaOpVxyXG4gICAgICAgICAgICB8fCByZXRDb2RlID09IC0xOTk5OCAvL+WPguaVsOmUmeivr1xyXG4gICAgICAgICAgICB8fCByZXRDb2RlID09IC0xOTc4OCAvKnBTcGFjZemHjeWQr++8jOmcgOimgeWGsua0l+i/nuaOpSovXHJcbiAgICAgICAgICAgIHx8IHJldENvZGUgPT0gLTE5Nzk5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi6ZSZ6K+vOiBcIiArIHJldENvZGUgKyBcIumHjeaWsOi/nuaOpVwiKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi6ZSZ6K+vOiBcIiArIHJldENvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpc0Vycm9yKHJldENvZGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHJldENvZGUgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAocmV0Q29kZSA9PSAwIHx8IHJldENvZGUgPT0gLTE5OTk3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn0iLCJjb25zdCBkYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcclxuLy/mlbDmja7mk43kvZzor7fmsYJcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhZ2VudEFkYXB0ZXIgZXh0ZW5kcyBkYXRhU291cmNlQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnRhZ1RyZWUgPSB7fTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuWKoOi9veaVsOaNruW6k+eCueihqFxyXG4gICAgICAgIOWPguaVsDrml6BcclxuICAgICAgICDov5Tlm57lgLw65pegXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgbG9hZEFsbFRhZ3MoKSB7XHJcblxyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5Y6G5Y+y5pWw5o2uXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrljoblj7LmlbDmja5cclxuICAgICovXHJcbiAgICBhc3luYyBnZXRIaXNEYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0SGlzRGF0YShqc29uKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluaKpeitpuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65oql6K2m5pWw5o2uXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWxtRGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBsYXlJbmZvID0gdGhpcy5kYi5nZXRMYXllcigpO1xyXG4gICAgICAgIGxldCBsYXlJZHMgPSBbXTtcclxuICAgICAgICBpZiAobGF5SW5mbyAmJiBsYXlJbmZvLmRhdGEpIHtcclxuICAgICAgICAgICAgbGF5SW5mby5kYXRhLm1hcCgobGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlJZHMucHVzaChwYXJzZUludChsYXkubGF5ZXJJZCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0QWxhcm1CeUFyZWEobGF5SWRzKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluWunuaXtuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65q2k6ZO+5o6l55qE5Y+Y5YyW5a6e5pe25YC8XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgZ2V0RGF0YShhcnJKc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBjbGllbnRLZXkgPSAoY29udGV4dC5yZW1vdGVBZGRyZXNzLmFkZHJlc3MgKyBcIjpcIiArIGNvbnRleHQucmVtb3RlQWRkcmVzcy5wb3J0KS5zbGljZSg3KTtcclxuICAgICAgICBsZXQgcmVnTmFtZURhdGEgPSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudEtleV0uc2hlbGxSZWdEYXRhO1xyXG4gICAgICAgIGxldCByZXF1ZXN0TGlzdCA9IFtdO1xyXG4gICAgICAgIC8v5Zyo57yT5a2Y5Lit55qE5pWw5o2u54K5XHJcbiAgICAgICAgbGV0IGNhY2hlUmVzcG9uZURhdGEgPSBbXTtcclxuICAgICAgICBhcnJKc29uLm1hcCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgIC8v5Zyo5pWw5o2u54K557yT5a2Y5Lit5a2Y5ZyoXHJcbiAgICAgICAgICAgIGlmIChyZWdOYW1lRGF0YVt0YWcudGFnTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXS5saXZlVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgY2FjaGVSZXNwb25lRGF0YS5wdXNoKHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWcudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJJZDogdGhpcy5Nb2RlUHJvcGVydHlbdGFnLnBhck5hbWVdLmlkIHx8IDEzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsaXZlVGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFySWQ6IHRoaXMuTW9kZVByb3BlcnR5W3RhZy5wYXJOYW1lXS5pZCB8fCAxMyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgaWYgKHJlcXVlc3RMaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhY2hlUmVzcG9uZURhdGE7XHJcbiAgICAgICAgbGV0IHJlc3BvbmVEYXRhID0gYXdhaXQgdGhpcy5kYi5nZXREYXRhKHJlcXVlc3RMaXN0KTtcclxuICAgICAgICBpZiAodGhpcy5pc0Vycm9yKHJlc3BvbmVEYXRhLnJldENvZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25lRGF0YS5yZXRDb2RlID09IC0xOTk5Nykge1xyXG4gICAgICAgICAgICAgICAgLy/lvZPliY1mY05vZGXml6Dms5Xov5Tlm54gLTE5OTk3IOmUmeivr1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLpg6jliIbplJnor69cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uZURhdGEuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25lRGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnTmFtZURhdGFbcmVzcG9uZURhdGEuZGF0YVtpXS50YWdOYW1lXS52YWx1ZSA9IHJlc3BvbmVEYXRhLmRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnJlc3BvbmVEYXRhLmRhdGEsIC4uLmNhY2hlUmVzcG9uZURhdGFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uZURhdGEucmV0Q29kZSwgeyB0eXBlOiBcImVycm9yXCIgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlzUmVDb25uZWN0KHJlc3BvbmVEYXRhLnJldENvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuaVsOaNruS4i+e9rlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw6XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgc2V0RGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnNldERhdGEoanNvbik7XHJcbiAgICB9XHJcbn0iLCJjb25zdCBkYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcclxuLy/mlbDmja7mk43kvZzor7fmsYJcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhZ2VudEFkYXB0ZXIgZXh0ZW5kcyBkYXRhU291cmNlQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICAvL+aUr+aMgeeahOaooeWei+WxnuaAp1xyXG4gICAgICAgIHRoaXMuTW9kZVByb3BlcnR5ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogMVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwdjoge1xyXG4gICAgICAgICAgICAgICAgaWQ6IDEzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlc2M6IHtcclxuICAgICAgICAgICAgICAgIGlkOiAxMlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGFnVHJlZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7065Yqg6L295pWw5o2u5bqT54K56KGoXHJcbiAgICAgICAg5Y+C5pWwOuaXoFxyXG4gICAgICAgIOi/lOWbnuWAvDrml6BcclxuICAgICovXHJcbiAgICBhc3luYyBsb2FkQWxsVGFncygpIHtcclxuICAgICAgICBsZXQgdGFnSW5mb3MgPSB0aGlzLmRiLmdldFRhZ0luZm9FeCgtMSk7XHJcbiAgICAgICAgLy/mi7zmjqXmiYDmnInngrlpZO+8jOS7peWPimRlc2Plj4LmlbDkv6Hmga/vvIzojrflj5bngrnmj4/ov7BcclxuICAgICAgICBsZXQgdGFnSWRzID0gW107XHJcbiAgICAgICAgdGFnSW5mb3MuZGF0YS5tYXAoKHRhZykgPT4ge1xyXG4gICAgICAgICAgICB0YWdJZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0YWdJZDogdGFnLnRhZ0lkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v6I635Y+W54K55o+P6L+wXHJcbiAgICAgICAgbGV0IHRhZ0Rlc2NzID0gYXdhaXQgdGhpcy5kYi5nZXREYXRhKHRhZ0lkcyk7XHJcbiAgICAgICAgdGhpcy50YWdUcmVlID0ge307XHJcbiAgICAgICAgaWYgKHRhZ0Rlc2NzLmRhdGEubGVuZ3RoID09IHRhZ0luZm9zLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRhZ0luZm9zLmRhdGEubWFwKCh0YWcsIHRhZ0luZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0YWcudGFnTmFtZS5pbmRleE9mKFwiXFxcXFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/moLnoioLngrnkuIvmtYvngrks55u05o6l5rOo5YaMXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdUcmVlW3RhZy50YWdOYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFnLnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IHRhZ0Rlc2NzLmRhdGFbdGFnSW5kZXhdLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nTmFtZTogdGFnLnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0YWcudGFnSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB2OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5SW5mb3MgPSB0YWcudGFnTmFtZS5zcGxpdChcIlxcXFxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3QgPSB0aGlzLnRhZ1RyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/mnIDlkI7kuIDnuqfmmK/ngrnlkI1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheUluZm9zLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXlOYW1lID0gbGF5SW5mb3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm9vdFtsYXlOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFtsYXlOYW1lXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290W2xheU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL+aMguaOpeeCueWQjVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RbbGF5SW5mb3NbbGF5SW5mb3MubGVuZ3RoIC0gMV1dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXlJbmZvc1tsYXlJbmZvcy5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogdGFnRGVzY3MuZGF0YVt0YWdJbmRleF0udmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdOYW1lOiB0YWcudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRhZy50YWdJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHY6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLlrp7ml7blupM6IFwiICsgdGhpcy5jb25maWcuaXAgKyBcIiAg57G75Z6LOiBcIiArIHRoaXMuY29uZmlnLnR5cGUgKyBcIiDov57mjqXmiJDlip/vvIzmtYvngrnliqDovb3miJDlip9cIiwgeyB0eXBlOiBcInN0YXJ0XCIgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5Y6G5Y+y5pWw5o2uXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrljoblj7LmlbDmja5cclxuICAgICovXHJcbiAgICBhc3luYyBnZXRIaXNEYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0SGlzRGF0YShqc29uKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluaKpeitpuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65oql6K2m5pWw5o2uXHJcbiAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWxtRGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBsYXlJbmZvID0gdGhpcy5kYi5nZXRMYXllcigpO1xyXG4gICAgICAgIGxldCBsYXlJZHMgPSBbXTtcclxuICAgICAgICBpZiAobGF5SW5mbyAmJiBsYXlJbmZvLmRhdGEpIHtcclxuICAgICAgICAgICAgbGF5SW5mby5kYXRhLm1hcCgobGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXlJZHMucHVzaChwYXJzZUludChsYXkubGF5ZXJJZCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0QWxhcm1CeUFyZWEobGF5SWRzKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluWunuaXtuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65q2k6ZO+5o6l55qE5Y+Y5YyW5a6e5pe25YC8XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgZ2V0RGF0YShhcnJKc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBjbGllbnRLZXkgPSAoY29udGV4dC5yZW1vdGVBZGRyZXNzLmFkZHJlc3MgKyBcIjpcIiArIGNvbnRleHQucmVtb3RlQWRkcmVzcy5wb3J0KS5zbGljZSg3KTtcclxuICAgICAgICBsZXQgcmVnTmFtZURhdGEgPSB0aGlzLndlYkNsaWVudFJlZ0RhdGFJbmZvW2NsaWVudEtleV0uc2hlbGxSZWdEYXRhO1xyXG4gICAgICAgIGxldCByZXF1ZXN0TGlzdCA9IFtdO1xyXG4gICAgICAgIC8v5Zyo57yT5a2Y5Lit55qE5pWw5o2u54K5XHJcbiAgICAgICAgbGV0IGNhY2hlUmVzcG9uZURhdGEgPSBbXTtcclxuICAgICAgICBhcnJKc29uLm1hcCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgIC8v5Zyo5pWw5o2u54K557yT5a2Y5Lit5a2Y5ZyoXHJcbiAgICAgICAgICAgIGlmIChyZWdOYW1lRGF0YVt0YWcudGFnTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXS5saXZlVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgY2FjaGVSZXNwb25lRGF0YS5wdXNoKHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWcudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJJZDogdGhpcy5Nb2RlUHJvcGVydHlbdGFnLnBhck5hbWVdLmlkIHx8IDEzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsaXZlVGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFySWQ6IHRoaXMuTW9kZVByb3BlcnR5W3RhZy5wYXJOYW1lXS5pZCB8fCAxMyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgaWYgKHJlcXVlc3RMaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhY2hlUmVzcG9uZURhdGE7XHJcbiAgICAgICAgbGV0IHJlc3BvbmVEYXRhID0gYXdhaXQgdGhpcy5kYi5nZXREYXRhKHJlcXVlc3RMaXN0KTtcclxuICAgICAgICBpZiAodGhpcy5pc0Vycm9yKHJlc3BvbmVEYXRhLnJldENvZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25lRGF0YS5yZXRDb2RlID09IC0xOTk5Nykge1xyXG4gICAgICAgICAgICAgICAgLy/lvZPliY1mY05vZGXml6Dms5Xov5Tlm54gLTE5OTk3IOmUmeivr1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLpg6jliIbplJnor69cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uZURhdGEuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25lRGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnTmFtZURhdGFbcmVzcG9uZURhdGEuZGF0YVtpXS50YWdOYW1lXS52YWx1ZSA9IHJlc3BvbmVEYXRhLmRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnJlc3BvbmVEYXRhLmRhdGEsIC4uLmNhY2hlUmVzcG9uZURhdGFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uZURhdGEucmV0Q29kZSwgeyB0eXBlOiBcImVycm9yXCIgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlzUmVDb25uZWN0KHJlc3BvbmVEYXRhLnJldENvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuaVsOaNruS4i+e9rlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw6XHJcbiAgICAqL1xyXG4gICAgYXN5bmMgc2V0RGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnNldERhdGEoanNvbik7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrlkajmnJ/ku47mlbDmja7mupDmn6Xor6LmlbDmja5cclxuICAgICAgICDlj4LmlbA65pegXHJcbiAgICAgICAg6L+U5Zue5YC8OuaXoFxyXG4gICAgKi9cclxuICAgIGFzeW5jIHBvbGxSZXF1ZXN0KCkge1xyXG4gICAgICAgIC8v5p6E6YCg6K+35rGC57uT5p6EXHJcbiAgICAgICAgbGV0IHJlcXVlc3REYXRhID0gW107XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuR2xvYmFsUmVxdWVzdERhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSB0aGlzLkdsb2JhbFJlcXVlc3REYXRhW2tleV07XHJcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogcmVxdWVzdEluZm8udGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIHBhcklkOiB0aGlzLk1vZGVQcm9wZXJ0eVtyZXF1ZXN0SW5mby5wYXJOYW1lXS5pZCB8fCAxMyxcclxuICAgICAgICAgICAgICAgIGdsb2JhbFJlZjogcmVxdWVzdEluZm9cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3REYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy/lkJHmnI3liqHnq6/or7fmsYIgICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHJlc3BvbmVEYXRhID0gYXdhaXQgdGhpcy5kYi5nZXREYXRhKHJlcXVlc3REYXRhKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbmVEYXRhICYmIHRoaXMuaXNFcnJvcihyZXNwb25lRGF0YS5yZXRDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbmVEYXRhLnJldENvZGUgPT0gLTE5OTk3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lvZPliY1mY05vZGXml6Dms5Xov5Tlm54gLTE5OTk3IOmUmeivr1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi6YOo5YiG6ZSZ6K+vXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uZURhdGEuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVEYXRhKHJlc3BvbmVEYXRhLmRhdGEsIHJlcXVlc3REYXRhKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uZURhdGEucmV0Q29kZSwgeyB0eXBlOiBcImVycm9yXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbmVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVDb25uZWN0KHJlc3BvbmVEYXRhLnJldENvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5wb2xsUmVxdWVzdC5iaW5kKHRoaXMpLCAxMDAwKTtcclxuICAgIH1cclxufVxyXG4iLCJjb25zdCBkYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcclxuLy/mlbDmja7mk43kvZzor7fmsYJcclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhZ2VudEFkYXB0ZXIgZXh0ZW5kcyBkYXRhU291cmNlQmFzZSB7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKSB7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0Ly/mlK/mjIHnmoTmqKHlnovlsZ7mgKdcclxuXHRcdHRoaXMuTW9kZVByb3BlcnR5ID0ge1xyXG5cdFx0XHRuYW1lOiB7XHJcblx0XHRcdFx0aWQ6IDFcclxuXHRcdFx0fSxcclxuXHRcdFx0cHY6IHtcclxuXHRcdFx0XHRpZDogMTNcclxuXHRcdFx0fSxcclxuXHRcdFx0ZGVzYzoge1xyXG5cdFx0XHRcdGlkOiAxMlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wcm9wSWRzID0gWzAsIDEsIDIsIDMsIDUsIDcsIDExLCAzNywgMzksIDQwXTtcclxuXHRcdHRoaXMudGFnVHJlZSA9IHt9O1xyXG5cdFx0dGhpcy5ub2RlSWRUb1RhZ3MgPSB7fTtcclxuXHR9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrliqDovb3mlbDmja7lupPngrnooahcclxuICAgICAgICDlj4LmlbA65pegXHJcbiAgICAgICAg6L+U5Zue5YC8OuaXoFxyXG4gICAgKi9cclxuXHRhc3luYyBsb2FkQWxsVGFncygpIHtcclxuXHRcdGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmdldFRhZ1F1ZXJ5SWRzKHtcclxuXHRcdFx0J3RhZ0lkJzogMCxcclxuXHRcdFx0J3F1ZXJ5TGV2ZWwnOiAwXHJcblx0XHR9KTtcclxuXHRcdGlmICh0aGlzLmlzRXJyb3IocmVzdWx0LnJldENvZGUpKSB7XHJcblx0XHRcdGxldCB0YWdzID0gYXdhaXQgdGhpcy5kYi5nZXRUYWdMaXN0UHJvcHMoe1xyXG5cdFx0XHRcdCd0YWdJZHMnOiByZXN1bHQuaWRzLFxyXG5cdFx0XHRcdCdwcm9wSWRzJzogdGhpcy5wcm9wSWRzXHJcblx0XHRcdH0pXHJcblx0XHRcdGlmICh0aGlzLmlzRXJyb3IodGFncy5yZXRDb2RlKSkge1xyXG5cdFx0XHRcdHRoaXMuY3JlYXRlVGFnVHJlZSh0YWdzKTtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIuWunuaXtuW6kzogXCIgKyB0aGlzLmNvbmZpZy5pcCArIFwiICDnsbvlnos6IFwiICsgdGhpcy5jb25maWcudHlwZSArIFwiICDnirbmgIE6IOW3sueZu+W9lSzmtYvngrnliqDovb3miJDlip9cIiwgeyB0eXBlOiBcInN0YXJ0XCIgfSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrmnoTpgKDngrnmoJHnu5PmnoRcclxuICAgICAgICDlj4LmlbA65omA5pyJ54K55Y+K6IqC54K55pWw57uEXHJcbiAgICAgICAg6L+U5Zue5YC8OuaXoFxyXG4gICAgKi9cclxuXHRjcmVhdGVUYWdUcmVlKHRhZ3MpIHtcclxuXHRcdHRoaXMudGFnVHJlZSA9IHt9O1xyXG5cdFx0aWYgKHRhZ3MudGFnUHJvcExpc3QpIHtcclxuXHRcdFx0Ly/lvqrnjq/miYDmnInngrnmlbDnu4TjgILov5Tlm57nmoTkuLrmiYDmnInngrnlkozoioLngrnnmoTkuIDnu7TmlbDnu4TjgILmnoTpgKDkuLrlt7LngrlpZOS4uuagkeW9ouWQjeensOeahOagkeW9oue7k+aehOOAglxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhZ3MudGFnUHJvcExpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgb25jZSA9IHRhZ3MudGFnUHJvcExpc3RbaV07XHJcblx0XHRcdFx0Ly9vbmNl5pWw57uE55qE5LiL5qCH55SxIHRoaXMucHJvcElkcyDor7fmsYLnmoTpobrluo/lkozlhoXlrrnlhrPlrpogXHJcblx0XHRcdFx0aWYgKG9uY2VbNl0uZGF0YSA9PSAxKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVswXS5kYXRhXSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVJZFRvVGFnc1tvbmNlWzBdLmRhdGFdLm5hbWUgPSBvbmNlWzJdLmRhdGE7XHJcblx0XHRcdFx0XHRcdHRoaXMubm9kZUlkVG9UYWdzW29uY2VbMF0uZGF0YV0uaWQgPSBvbmNlWzBdLmRhdGE7XHJcblx0XHRcdFx0XHRcdHRoaXMubm9kZUlkVG9UYWdzW29uY2VbMF0uZGF0YV0udHlwZSA9IG9uY2VbMV0uZGF0YTtcclxuXHRcdFx0XHRcdFx0dGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVswXS5kYXRhXS5kZXNjID0gb25jZVs0XS5kYXRhO1xyXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVJZFRvVGFnc1tvbmNlWzBdLmRhdGFdLmxvbmdOYW1lID0gb25jZVszXS5kYXRhO1xyXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVJZFRvVGFnc1tvbmNlWzBdLmRhdGFdLnBhcmVudElkID0gb25jZVs1XS5kYXRhO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVswXS5kYXRhXSA9IHtcclxuXHRcdFx0XHRcdFx0XHRuYW1lOiBvbmNlWzJdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0aWQ6IG9uY2VbMF0uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBvbmNlWzFdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0ZGVzYzogb25jZVs0XS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGxvbmdOYW1lOiBvbmNlWzNdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IG9uY2VbNV0uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbjoge31cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVs1XS5kYXRhXSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVJZFRvVGFnc1tvbmNlWzVdLmRhdGFdLmNoaWxkcmVuW29uY2VbMl0uZGF0YV0gPSB7XHJcblx0XHRcdFx0XHRcdFx0bmFtZTogb25jZVsyXS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGlkOiBvbmNlWzBdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogb25jZVsxXS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGRlc2M6IG9uY2VbNF0uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRsb25nTmFtZTogb25jZVszXS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdHBhcmVudElkOiBvbmNlWzVdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0YWxhcm1TdGF0ZTogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0cHY6IHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBvbmNlWzddLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0XHR0aW1lOiBvbmNlWzhdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0XHRxdWFsaXR5OiBvbmNlWzldLmRhdGFcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpZiAob25jZVs1XS5kYXRhID09IDApIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm5vZGVJZFRvVGFnc1tvbmNlWzVdLmRhdGFdID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IDAsXHJcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbjoge31cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVs1XS5kYXRhXSA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuOiB7fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5ub2RlSWRUb1RhZ3Nbb25jZVs1XS5kYXRhXS5jaGlsZHJlbltvbmNlWzJdLmRhdGFdID0ge1xyXG5cdFx0XHRcdFx0XHRcdG5hbWU6IG9uY2VbMl0uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRpZDogb25jZVswXS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IG9uY2VbMV0uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRkZXNjOiBvbmNlWzRdLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0bG9uZ05hbWU6IG9uY2VbM10uZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogb25jZVs1XS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGFsYXJtU3RhdGU6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRcdHB2OiB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogb25jZVs3XS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0dGltZTogb25jZVs4XS5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0cXVhbGl0eTogb25jZVs5XS5kYXRhXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL+eUseeCuWlk5Li65qCR5b2i5ZCN56ew55qE5qCR57uT5p6E5p6E6YCg5Li65bey54K55ZCN56ew5Li65qCR5b2i5ZCN56ew55qE5qCR57uT5p6EXHJcblx0XHQvL+S5i+aJgOS7peS4jeWcqOS4iuS4gOatpeS9v+eUqOeCueWQjeensOaehOmAoOagkeaXtuW6lOS4uuS4jeWQjOiKgueCueS4i+eahOeCueWQjeensOWPr+S7pemHjeWQjVxyXG5cdFx0Zm9yIChsZXQgcCBpbiB0aGlzLm5vZGVJZFRvVGFncykge1xyXG5cdFx0XHQvL3AgPT0gXCIwXCIg5qCH56S66Lef6IqC54K55LiL55qE54K544CC6ZyA6KaB54m55q6K5aSE55CGXHJcblx0XHRcdGlmIChwID09IFwiMFwiICYmIHRoaXMubm9kZUlkVG9UYWdzW3BdLnBhcmVudElkID09IDApIHtcclxuXHRcdFx0XHRmb3IgKGxldCBwMSBpbiB0aGlzLm5vZGVJZFRvVGFnc1twXS5jaGlsZHJlbikge1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBPbmUgPSB0aGlzLm5vZGVJZFRvVGFnc1twXS5jaGlsZHJlbltwMV07XHJcblx0XHRcdFx0XHR0aGlzLnRhZ1RyZWVbdGVtcE9uZS5uYW1lXSA9IHRlbXBPbmU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubm9kZUlkVG9UYWdzW3BdLnBhcmVudElkID09IDApIHtcclxuXHRcdFx0XHR0aGlzLnRhZ1RyZWVbdGhpcy5ub2RlSWRUb1RhZ3NbcF0ubmFtZV0gPSB7XHJcblx0XHRcdFx0XHRkZXNjOiB0aGlzLm5vZGVJZFRvVGFnc1twXS5kZXNjLFxyXG5cdFx0XHRcdFx0aWQ6IHRoaXMubm9kZUlkVG9UYWdzW3BdLmlkXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRmb3IgKGxldCBwMSBpbiB0aGlzLm5vZGVJZFRvVGFnc1twXS5jaGlsZHJlbikge1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBPbmUgPSB0aGlzLm5vZGVJZFRvVGFnc1twXS5jaGlsZHJlbltwMV07XHJcblx0XHRcdFx0XHR0aGlzLnRhZ1RyZWVbdGhpcy5ub2RlSWRUb1RhZ3NbcF0ubmFtZV1bdGVtcE9uZS5uYW1lXSA9IHRlbXBPbmU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBuYW1lTm9kZXMgPSB0aGlzLm5vZGVJZFRvVGFnc1twXS5sb25nTmFtZS5zcGxpdChcIlxcXFxcIik7XHJcblx0XHRcdFx0dmFyIHRlbXAgPSB0aGlzLnRhZ1RyZWU7XHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDE7IGogPCBuYW1lTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XHJcblx0XHRcdFx0XHRpZiAodGVtcFtuYW1lTm9kZXNbal1dID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHR0ZW1wW25hbWVOb2Rlc1tqXV0gPSB7XHJcblx0XHRcdFx0XHRcdFx0ZGVzYzogXCJcIixcclxuXHRcdFx0XHRcdFx0XHRpZDogLTFcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGVtcCA9IHRlbXBbbmFtZU5vZGVzW2pdXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGVtcFt0aGlzLm5vZGVJZFRvVGFnc1twXS5uYW1lXSA9IHtcclxuXHRcdFx0XHRcdGRlc2M6IHRoaXMubm9kZUlkVG9UYWdzW3BdLmRlc2MsXHJcblx0XHRcdFx0XHRpZDogdGhpcy5ub2RlSWRUb1RhZ3NbcF0uaWRcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IHAxIGluIHRoaXMubm9kZUlkVG9UYWdzW3BdLmNoaWxkcmVuKSB7XHJcblx0XHRcdFx0XHR2YXIgdGVtcE9uZSA9IHRoaXMubm9kZUlkVG9UYWdzW3BdLmNoaWxkcmVuW3AxXTtcclxuXHRcdFx0XHRcdHRlbXBbdGhpcy5ub2RlSWRUb1RhZ3NbcF0ubmFtZV1bdGVtcE9uZS5uYW1lXSA9IHRlbXBPbmU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG4gICAgLypcclxuICAgICAgICDlip/og7066I635Y+W5Y6G5Y+y5pWw5o2uXHJcbiAgICAgICAg5Y+C5pWwOmpzb2466K+35rGC5L+h5oGv44CCXHJcbiAgICAgICAgICAgIHRva2VuOuaaguacqui1t+aViOOAglxyXG4gICAgICAgICAgICBjb250ZXh0Oui/nuaOpeS/oeaBr+OAglxyXG4gICAgICAgIOi/lOWbnuWAvDrljoblj7LmlbDmja5cclxuICAgICovXHJcblx0YXN5bmMgZ2V0SGlzRGF0YShqc29uLCB0b2tlbiwgY29udGV4dCkge1xyXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuZGIuZ2V0SGlzRGF0YShqc29uKTtcclxuXHR9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrojrflj5bmiqXorabmlbDmja5cclxuICAgICAgICDlj4LmlbA6anNvbjror7fmsYLkv6Hmga/jgIJcclxuICAgICAgICAgICAgdG9rZW465pqC5pyq6LW35pWI44CCXHJcbiAgICAgICAgICAgIGNvbnRleHQ66L+e5o6l5L+h5oGv44CCXHJcbiAgICAgICAg6L+U5Zue5YC8OuaKpeitpuaVsOaNrlxyXG4gICAgKi9cclxuXHRhc3luYyBnZXRBbG1EYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcblx0XHRsZXQgbGF5SW5mbyA9IGF3YWl0IHRoaXMuZGIuZ2V0TGF5ZXIoKTtcclxuXHRcdGxldCBsYXlJZHMgPSBbXTtcclxuXHRcdGlmIChsYXlJbmZvLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0bGF5SW5mby5tYXAoKGxheSkgPT4ge1xyXG5cdFx0XHRcdGxheUlkcy5wdXNoKHBhcnNlSW50KGxheS5sYXllcklkKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZGIuZ2V0QWxhcm1CeUFyZWEobGF5SWRzKTtcclxuXHJcblx0fVxyXG5cclxuICAgIC8qXHJcbiAgICAgICAg5Yqf6IO9OuiOt+WPluWunuaXtuaVsOaNrlxyXG4gICAgICAgIOWPguaVsDpqc29uOuivt+axguS/oeaBr+OAglxyXG4gICAgICAgICAgICB0b2tlbjrmmoLmnKrotbfmlYjjgIJcclxuICAgICAgICAgICAgY29udGV4dDrov57mjqXkv6Hmga/jgIJcclxuICAgICAgICDov5Tlm57lgLw65q2k6ZO+5o6l55qE5Y+Y5YyW5a6e5pe25YC8XHJcbiAgICAqL1xyXG5cdGFzeW5jIGdldERhdGEoYXJySnNvbiwgdG9rZW4sIGNvbnRleHQpIHtcclxuXHRcdGxldCBjbGllbnRLZXkgPSAoY29udGV4dC5yZW1vdGVBZGRyZXNzLmFkZHJlc3MgKyBcIjpcIiArIGNvbnRleHQucmVtb3RlQWRkcmVzcy5wb3J0KS5zbGljZSg3KTtcclxuXHRcdGxldCByZWdOYW1lRGF0YSA9IHRoaXMud2ViQ2xpZW50UmVnRGF0YUluZm9bY2xpZW50S2V5XS5zaGVsbFJlZ0RhdGE7XHJcblx0XHRsZXQgcmVxdWVzdExpc3QgPSBbXTtcclxuXHRcdC8v5Zyo57yT5a2Y5Lit55qE5pWw5o2u54K5XHJcblx0XHRsZXQgY2FjaGVSZXNwb25lRGF0YSA9IFtdO1xyXG5cdFx0YXJySnNvbi5tYXAoKHRhZykgPT4ge1xyXG5cdFx0XHQvL+WcqOaVsOaNrueCuee8k+WtmOS4reWtmOWcqFxyXG5cdFx0XHRpZiAocmVnTmFtZURhdGFbdGFnLnRhZ05hbWVdKSB7XHJcblx0XHRcdFx0cmVnTmFtZURhdGFbdGFnLnRhZ05hbWVdLmxpdmVUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdFx0Y2FjaGVSZXNwb25lRGF0YS5wdXNoKHJlZ05hbWVEYXRhW3RhZy50YWdOYW1lXS52YWx1ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVxdWVzdExpc3QucHVzaCh7XHJcblx0XHRcdFx0XHR0YWdOYW1lOiB0YWcudGFnTmFtZSxcclxuXHRcdFx0XHRcdHBhcklkOiB0aGlzLk1vZGVQcm9wZXJ0eVt0YWcucGFyTmFtZV0uaWQgfHwgMTNcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZWdOYW1lRGF0YVt0YWcudGFnTmFtZV0gPSB7XHJcblx0XHRcdFx0XHRsaXZlVGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcblx0XHRcdFx0XHRwYXJJZDogdGhpcy5Nb2RlUHJvcGVydHlbdGFnLnBhck5hbWVdLmlkIHx8IDEzLFxyXG5cdFx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdFx0aWYgKHJlcXVlc3RMaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhY2hlUmVzcG9uZURhdGE7XHJcblx0XHRsZXQgcmVzcG9uZURhdGEgPSBhd2FpdCB0aGlzLmRiLmdldERhdGEocmVxdWVzdExpc3QpO1xyXG5cdFx0aWYgKHRoaXMuaXNFcnJvcihyZXNwb25lRGF0YS5yZXRDb2RlKSkge1xyXG5cdFx0XHRpZiAocmVzcG9uZURhdGEucmV0Q29kZSA9PSAtMTk5OTcpIHtcclxuXHRcdFx0XHQvL+W9k+WJjWZjTm9kZeaXoOazlei/lOWbniAtMTk5OTcg6ZSZ6K+vXHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCLpg6jliIbplJnor69cIik7XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlc3BvbmVEYXRhLmRhdGEpIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbmVEYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHJlZ05hbWVEYXRhW3Jlc3BvbmVEYXRhLmRhdGFbaV0udGFnTmFtZV0udmFsdWUgPSByZXNwb25lRGF0YS5kYXRhW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gWy4uLnJlc3BvbmVEYXRhLmRhdGEsIC4uLmNhY2hlUmVzcG9uZURhdGFdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlc3BvbmVEYXRhLnJldENvZGUsIHsgdHlwZTogXCJlcnJvclwiIH0pO1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5pc1JlQ29ubmVjdChyZXNwb25lRGF0YS5yZXRDb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbiAgICAvKlxyXG4gICAgICAgIOWKn+iDvTrmlbDmja7kuIvnva5cclxuICAgICAgICDlj4LmlbA6anNvbjror7fmsYLkv6Hmga/jgIJcclxuICAgICAgICAgICAgdG9rZW465pqC5pyq6LW35pWI44CCXHJcbiAgICAgICAgICAgIGNvbnRleHQ66L+e5o6l5L+h5oGv44CCXHJcbiAgICAgICAg6L+U5Zue5YC8OlxyXG4gICAgKi9cclxuXHRhc3luYyBzZXREYXRhKGpzb24sIHRva2VuLCBjb250ZXh0KSB7XHJcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5kYi5zZXREYXRhKGpzb24pO1xyXG5cdH1cclxufSIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQnl0ZVN0cmVhbS50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBCeXRlU3RyZWFtIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxNSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVNUFRZX0JZVEVTID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG52YXIgSU5JVF9TSVpFID0gMTAyNDtcbmZ1bmN0aW9uIHdyaXRlSW50MzJCRShieXRlcywgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHZhbHVlID4+PiAyNCAmIDB4RkY7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdmFsdWUgPj4+IDE2ICYgMHhGRjtcbiAgICBieXRlc1tvZmZzZXQrK10gPSB2YWx1ZSA+Pj4gOCAmIDB4RkY7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdmFsdWUgJiAweEZGO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5leHBvcnRzLndyaXRlSW50MzJCRSA9IHdyaXRlSW50MzJCRTtcbmZ1bmN0aW9uIHdyaXRlSW50MzJMRShieXRlcywgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHZhbHVlICYgMHhGRjtcbiAgICBieXRlc1tvZmZzZXQrK10gPSB2YWx1ZSA+Pj4gOCAmIDB4RkY7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdmFsdWUgPj4+IDE2ICYgMHhGRjtcbiAgICBieXRlc1tvZmZzZXQrK10gPSB2YWx1ZSA+Pj4gMjQgJiAweEZGO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5leHBvcnRzLndyaXRlSW50MzJMRSA9IHdyaXRlSW50MzJMRTtcbmZ1bmN0aW9uIHBvdzJyb3VuZHVwKHZhbHVlKSB7XG4gICAgLS12YWx1ZTtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDI7XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gNDtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDE2O1xuICAgIHJldHVybiB2YWx1ZSArIDE7XG59XG52YXIgYXJyYXlMaWtlT2JqZWN0QXJndW1lbnRzRW5hYmxlZCA9IHRydWU7XG50cnkge1xuICAgIGZyb21DaGFyQ29kZShuZXcgVWludDhBcnJheShbMSwgMl0pKTtcbn1cbmNhdGNoIChlKSB7XG4gICAgYXJyYXlMaWtlT2JqZWN0QXJndW1lbnRzRW5hYmxlZCA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdG9BcnJheShhcnJheWxpa2UpIHtcbiAgICB2YXIgbiA9IGFycmF5bGlrZS5sZW5ndGg7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlsaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBmcm9tQ2hhckNvZGUoY2hhckNvZGVzKSB7XG4gICAgaWYgKGFycmF5TGlrZU9iamVjdEFyZ3VtZW50c0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaGFyQ29kZXMpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHRvQXJyYXkoY2hhckNvZGVzKSk7XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nKGJ5dGVzLCBjaGFyTGVuZ3RoKSB7XG4gICAgaWYgKGNoYXJMZW5ndGggPCAwKVxuICAgICAgICBjaGFyTGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGlmIChjaGFyTGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gWycnLCAwXTtcbiAgICB2YXIgY2hhck9mZnNldCA9IDA7XG4gICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgIHZhciBuID0gKGNoYXJMZW5ndGggPCAweDdGRkYpID8gY2hhckxlbmd0aCA6IDB4N0ZGRjtcbiAgICB2YXIgY2hhckNvZGVzID0gbmV3IFVpbnQxNkFycmF5KG4gKyAxKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICB2YXIgYnVmID0gW107XG4gICAgZG8ge1xuICAgICAgICBmb3IgKDsgY2hhck9mZnNldCA8IG4gJiYgYnl0ZU9mZnNldCA8IGJ5dGVMZW5ndGg7IGNoYXJPZmZzZXQrKykge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBieXRlc1tieXRlT2Zmc2V0KytdO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0ID4+IDQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZXNbY2hhck9mZnNldF0gPSB1bml0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlT2Zmc2V0IDwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGVzW2NoYXJPZmZzZXRdID0gKCh1bml0ICYgMHgxRikgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IChieXRlc1tieXRlT2Zmc2V0KytdICYgMHgzRik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZmluaXNoZWQgVVRGLTggb2N0ZXQgc2VxdWVuY2UnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIDEgPCBieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZXNbY2hhck9mZnNldF0gPSAoKHVuaXQgJiAweDBGKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoYnl0ZXNbYnl0ZU9mZnNldCsrXSAmIDB4M0YpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoYnl0ZXNbYnl0ZU9mZnNldCsrXSAmIDB4M0YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmZpbmlzaGVkIFVURi04IG9jdGV0IHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyAyIDwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bmUgPSAoKCh1bml0ICYgMHgwNykgPDwgMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoKGJ5dGVzW2J5dGVPZmZzZXQrK10gJiAweDNGKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoYnl0ZXNbYnl0ZU9mZnNldCsrXSAmIDB4M0YpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoYnl0ZXNbYnl0ZU9mZnNldCsrXSAmIDB4M0YpKSAtIDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA8PSBydW5lICYmIHJ1bmUgPD0gMHhGRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2Rlc1tjaGFyT2Zmc2V0KytdID0gKCgocnVuZSA+PiAxMCkgJiAweDAzRkYpIHwgMHhEODAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZXNbY2hhck9mZnNldF0gPSAoKHJ1bmUgJiAweDAzRkYpIHwgMHhEQzAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhcmFjdGVyIG91dHNpZGUgdmFsaWQgVW5pY29kZSByYW5nZTogMHgnICsgcnVuZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5maW5pc2hlZCBVVEYtOCBvY3RldCBzZXF1ZW5jZScpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIFVURi04IGVuY29kaW5nIDB4JyArIHVuaXQudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWYucHVzaChmcm9tQ2hhckNvZGUoY2hhckNvZGVzLnN1YmFycmF5KDAsIGNoYXJPZmZzZXQpKSk7XG4gICAgICAgIGNoYXJMZW5ndGggLT0gY2hhck9mZnNldDtcbiAgICAgICAgY2hhck9mZnNldCA9IDA7XG4gICAgICAgIGlmIChuID4gY2hhckxlbmd0aClcbiAgICAgICAgICAgIG4gPSBjaGFyTGVuZ3RoO1xuICAgIH0gd2hpbGUgKGNoYXJPZmZzZXQgPCBjaGFyTGVuZ3RoICYmIGJ5dGVPZmZzZXQgPCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gW2J1Zi5sZW5ndGggPT09IDEgPyBidWZbMF0gOiBidWYuam9pbignJyksIGJ5dGVPZmZzZXRdO1xufVxuZnVuY3Rpb24gZnJvbVVpbnQ4QXJyYXkoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmVhZFN0cmluZyhieXRlcywgYnl0ZXMubGVuZ3RoKVswXTtcbn1cbmV4cG9ydHMuZnJvbVVpbnQ4QXJyYXkgPSBmcm9tVWludDhBcnJheTtcbmZ1bmN0aW9uIHRvQmluYXJ5U3RyaW5nKGJ5dGVzKSB7XG4gICAgdmFyIGRhdGEgPSAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSA/IGJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHZhciBuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKG4gPT09IDApXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAobiA8IDB4RkZGRilcbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShkYXRhKTtcbiAgICB2YXIgcmVtYWluID0gbiAmIDB4N0ZGRjtcbiAgICB2YXIgY291bnQgPSBuID4+IDE1O1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXkocmVtYWluID8gY291bnQgKyAxIDogY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcbiAgICAgICAgYnVmW2ldID0gZnJvbUNoYXJDb2RlKGRhdGEuc3ViYXJyYXkoaSA8PCAxNSwgKGkgKyAxKSA8PCAxNSkpO1xuICAgIGlmIChyZW1haW4pXG4gICAgICAgIGJ1Zltjb3VudF0gPSBmcm9tQ2hhckNvZGUoZGF0YS5zdWJhcnJheShjb3VudCA8PCAxNSwgbikpO1xuICAgIHJldHVybiBidWYuam9pbignJyk7XG59XG5leHBvcnRzLnRvQmluYXJ5U3RyaW5nID0gdG9CaW5hcnlTdHJpbmc7XG52YXIgQnl0ZVN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCeXRlU3RyZWFtKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gRU1QVFlfQllURVM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5ybWFyayA9IDA7XG4gICAgICAgIHRoaXMud21hcmsgPSAwO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCeXRlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdmFsdWUudG9CeXRlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcmsoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGRhdGEgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBUeXBlLlxuICAgICAqIEBwYXJhbSBkYXRhIHRvIGJlIGRlY29kZWQgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS50b1N0cmluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnRvU3RyaW5nLmFwcGx5KEJ5dGVTdHJlYW0pO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQnl0ZVN0cmVhbSlcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiBmcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkYXRhLCAwKSk7XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoZGF0YSk7XG4gICAgfTtcbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5ncm93ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gdGhpcy5jYXBhY2l0eTtcbiAgICAgICAgbiA9IHRoaXMuc2l6ZSArIG47XG4gICAgICAgIGlmIChuID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIGlmIChjYXBhY2l0eSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkocG93MnJvdW5kdXAobikpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShNYXRoLm1heChwb3cycm91bmR1cChuKSwgSU5JVF9TSVpFKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlU3RyZWFtLnByb3RvdHlwZSwgXCJjYXBhY2l0eVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNhcGFjaXR5IG9mIHRoaXMgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZVN0cmVhbS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBkYXRhIGluIHRoaXMgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZVN0cmVhbS5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIG5leHQgcmVhZGluZyBvcGVyYXRpb24gaW4gdGhpcyBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVTdHJlYW0ucHJvdG90eXBlLCBcImJ5dGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYWxsIGJ5dGVzIGRhdGEgaW4gdGhpcyBzdHJlYW0uXG4gICAgICAgICAqIElmIHRoZSByZXR1cm5lZCBkYXRhIGlzIGNoYW5nZWQsIHRoZSBkYXRhIGluIHRoaXMgc3RyZWFtIHdpbGwgYmUgYWxzbyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5zaXplKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVTdHJlYW0ucHJvdG90eXBlLCBcInJlbWFpbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbGwgYnl0ZXMgZGF0YSBpbiB0aGlzIHN0cmVhbSB0aGF0IGhhcyBub3QgYmVlbiByZWFkLlxuICAgICAgICAgKiBJZiB0aGUgcmV0dXJuZWQgZGF0YSBpcyBjaGFuZ2VkLCB0aGUgZGF0YSBpbiB0aGlzIHN0cmVhbSB3aWxsIGJlIGFsc28gY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLnNpemUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgc3RyZWFtJ3MgbWFyayBhdCBpdHMgcmVhZGluZyBhbmQgd3JpdGluZyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndtYXJrID0gdGhpcy5zaXplO1xuICAgICAgICB0aGlzLnJtYXJrID0gdGhpcy5vZmZzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhpcyBzdHJlYW0ncyByZWFkaW5nIGFuZCB3cml0aW5nIHBvc2l0aW9uIHRvIHRoZSBwcmV2aW91c2x5LW1hcmtlZCBwb3NpdGlvbi5cbiAgICAgKiBJbnZva2luZyB0aGlzIG1ldGhvZCBuZWl0aGVyIGNoYW5nZXMgbm9yIGRpc2NhcmRzIHRoZSBtYXJrJ3MgdmFsdWUuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMud21hcms7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5ybWFyaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGlzIHN0cmVhbS5cbiAgICAgKiBUaGUgcG9zaXRpb24gaXMgc2V0IHRvIHplcm8sIHRoZSBsaW1pdCBpcyBzZXQgdG8gdGhlIGNhcGFjaXR5LCBhbmQgdGhlIG1hcmsgaXMgZGlzY2FyZGVkLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEVNUFRZX0JZVEVTO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMud21hcmsgPSAwO1xuICAgICAgICB0aGlzLnJtYXJrID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIGJ5dGUgdG8gdGhlIHN0cmVhbSBhcyBhIDEtYnl0ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYnl0ZSBhIGJ5dGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICB0aGlzLmdyb3coMSk7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMuc2l6ZSsrXSA9IGJ5dGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdmFsdWUgdG8gdGhpcyBzdHJlYW0gd2l0aCBiaWcgZW5kaWFuIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgbnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBzdHJlYW0uIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIHNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKiBUeXBlRXJyb3Igd2lsbCBiZSB0aHJvd2VkIHdoZW4gdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAodmFsdWUgfCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3Jvdyg0KTtcbiAgICAgICAgdGhpcy5zaXplID0gd3JpdGVJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLnNpemUsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyB2YWx1ZSB0byB0aGlzIHN0cmVhbSB3aXRoIGJpZyBlbmRpYW4gZm9ybWF0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBudW1iZXIgdG8gYmUgd3JpdHRlbiB0byB0aGlzIHN0cmVhbS4gdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgdW5zaWduZWQgMzItYml0IGludGVnZXIuXG4gICAgICogVHlwZUVycm9yIHdpbGwgYmUgdGhyb3dlZCB3aGVuIHZhbHVlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlICE9PSAodmFsdWUgfCAwKSAmJiAodmFsdWUgJiAweDdGRkZGRkZGKSArIDB4ODAwMDAwMDAgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm93KDQpO1xuICAgICAgICB0aGlzLnNpemUgPSB3cml0ZUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMuc2l6ZSwgdmFsdWUgfCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyB2YWx1ZSB0byB0aGlzIHN0cmVhbSB3aXRoIGxpdHRsZSBlbmRpYW4gZm9ybWF0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBudW1iZXIgdG8gYmUgd3JpdHRlbiB0byB0aGlzIHN0cmVhbS4gdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqIFR5cGVFcnJvciB3aWxsIGJlIHRocm93ZWQgd2hlbiB2YWx1ZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgc2lnbmVkIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09ICh2YWx1ZSB8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm93KDQpO1xuICAgICAgICB0aGlzLnNpemUgPSB3cml0ZUludDMyTEUodGhpcy5idWZmZXIsIHRoaXMuc2l6ZSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHZhbHVlIHRvIHRoaXMgc3RyZWFtIHdpdGggbGl0dGxlIGVuZGlhbiBmb3JtYXQuXG4gICAgICogQHBhcmFtIHZhbHVlIG51bWJlciB0byBiZSB3cml0dGVuIHRvIHRoaXMgc3RyZWFtLiB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKiBUeXBlRXJyb3Igd2lsbCBiZSB0aHJvd2VkIHdoZW4gdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgIT09ICh2YWx1ZSB8IDApICYmICh2YWx1ZSAmIDB4N0ZGRkZGRkYpICsgMHg4MDAwMDAwMCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyb3coNCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHdyaXRlSW50MzJMRSh0aGlzLmJ1ZmZlciwgdGhpcy5zaXplLCB2YWx1ZSB8IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGJpbmFyeSBkYXRhIHRvIHRoaXMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBkYXRhIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBzdHJlYW0uXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbiA9IChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmdyb3cobik7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ5dGVTdHJlYW0pIHtcbiAgICAgICAgICAgIGJ5dGVzLnNldChkYXRhLmJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnl0ZXMuc2V0KGRhdGEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplICs9IG47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgc3RyIHRvIHRoaXMgc3RyZWFtIHdpdGggYXNjaWkgZW5jb2RpbmcuXG4gICAgICogQHBhcmFtIHN0ciB0byBiZSB3cml0dGVuIHRvIHRoaXMgc3RyZWFtLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLndyaXRlQXNjaWlTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZ3JvdyhuKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5zaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplICs9IG47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgc3RyIHRvIHRoaXMgc3RyZWFtIHdpdGggdXRmOCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gc3RyIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBzdHJlYW0uXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRoZSBzaW5nbGUgY29kZSB1bml0IG9jY3VwaWVzIHVwIHRvIDMgYnl0ZXMuXG4gICAgICAgIHRoaXMuZ3JvdyhuICogMyk7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gY2hhckNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gMHhDMCB8IChjaGFyQ29kZSA+PiA2KTtcbiAgICAgICAgICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAweDgwIHwgKGNoYXJDb2RlICYgMHgzRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4RDgwMCB8fCBjaGFyQ29kZSA+IDB4REZGRikge1xuICAgICAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IDB4RTAgfCAoY2hhckNvZGUgPj4gMTIpO1xuICAgICAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IDB4ODAgfCAoKGNoYXJDb2RlID4+IDYpICYgMHgzRik7XG4gICAgICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gMHg4MCB8IChjaGFyQ29kZSAmIDB4M0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweERDMDAgJiYgMHhEQzAwIDw9IG5leHRDaGFyQ29kZSAmJiBuZXh0Q2hhckNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVuZSA9ICgoKGNoYXJDb2RlICYgMHgwM0ZGKSA8PCAxMCkgfCAobmV4dENoYXJDb2RlICYgMHgwM0ZGKSkgKyAweDAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IDB4RjAgfCAocnVuZSA+PiAxOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAweDgwIHwgKChydW5lID4+IDEyKSAmIDB4M0YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gMHg4MCB8ICgocnVuZSA+PiA2KSAmIDB4M0YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gMHg4MCB8IChydW5lICYgMHgzRik7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUgPSBvZmZzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbmQgcmV0dXJucyBhIHNpbmdsZSBieXRlLlxuICAgICAqIElmIG5vIGJ5dGUgaXMgYXZhaWxhYmxlLCByZXR1cm5zIC0xLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQgPj0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5vZmZzZXQrK107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHNpZ25lZCAzMi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgc3RyZWFtIHdpdGggdGhlIGJpZyBlbmRpYW4gZm9ybWF0LlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZGF0YSBpcyBsZXNzIHRoYW4gNCBieXRlcywgRXJyb3IoJ0VPRicpIHdpbGwgYmUgdGhyb3cuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChvZmZzZXQgKyAzID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFT0YnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gYnl0ZXNbb2Zmc2V0KytdIDw8IDI0IHwgYnl0ZXNbb2Zmc2V0KytdIDw8IDE2IHwgYnl0ZXNbb2Zmc2V0KytdIDw8IDggfCBieXRlc1tvZmZzZXQrK107XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGlzIHN0cmVhbSB3aXRoIHRoZSBiaWcgZW5kaWFuIGZvcm1hdC5cbiAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGRhdGEgaXMgbGVzcyB0aGFuIDQgYnl0ZXMsIEVycm9yKCdFT0YnKSB3aWxsIGJlIHRocm93LlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVhZEludDMyQkUoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgJiAweDdGRkZGRkZGKSArIDB4ODAwMDAwMDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHNpZ25lZCAzMi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgc3RyZWFtIHdpdGggdGhlIGxpdHRsZSBlbmRpYW4gZm9ybWF0LlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZGF0YSBpcyBsZXNzIHRoYW4gNCBieXRlcywgRXJyb3IoJ0VPRicpIHdpbGwgYmUgdGhyb3cuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChvZmZzZXQgKyAzID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFT0YnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gYnl0ZXNbb2Zmc2V0KytdIHwgYnl0ZXNbb2Zmc2V0KytdIDw8IDggfCBieXRlc1tvZmZzZXQrK10gPDwgMTYgfCBieXRlc1tvZmZzZXQrK10gPDwgMjQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGlzIHN0cmVhbSB3aXRoIHRoZSBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGRhdGEgaXMgbGVzcyB0aGFuIDQgYnl0ZXMsIEVycm9yKCdFT0YnKSB3aWxsIGJlIHRocm93LlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVhZEludDMyTEUoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgJiAweDdGRkZGRkZGKSArIDB4ODAwMDAwMDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBuIGJ5dGVzIG9mIGRhdGEgZnJvbSB0aGlzIHN0cmVhbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgVWludDhBcnJheS5cbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlLCByZWFkcyB0byB0aGUgZW5kIG9mIHRoaXMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBuIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA8IDAgfHwgdGhpcy5vZmZzZXQgKyBuID4gdGhpcy5zaXplKVxuICAgICAgICAgICAgbiA9IHRoaXMuc2l6ZSAtIHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9CWVRFUztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSBuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNraXBzIG92ZXIgYW5kIGRpc2NhcmRzIG4gYnl0ZXMgb2YgZGF0YSBmcm9tIHRoaXMgc3RyZWFtLlxuICAgICAqIFRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHNraXBwZWQgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSwgYWxsIHJlbWFpbmluZyBieXRlcyBhcmUgc2tpcHBlZC5cbiAgICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChuIDwgMCB8fCB0aGlzLm9mZnNldCArIG4gPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIG4gPSB0aGlzLnNpemUgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBVaW50OEFycmF5IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIGRlbGltaXRlci4gVGhlIHJlc3VsdCBpbmNsdWRlcyBkZWxpbWl0ZXIuXG4gICAgICogUmV0dXJucyBhbGwgcmVtYWluaW5nIGRhdGEgaWYgbm8gZGVsaW1pdGVyIGlzIGZvdW5kLlxuICAgICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgVGhlIG5ldyBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSBkZWxpbWl0ZXIgYSBieXRlLCB3aGljaCByZXByZXNlbnRzIHRoZSBlbmQgb2YgcmVhZGluZyBkYXRhLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlcyA9IGZ1bmN0aW9uIChkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuYnVmZmVyLmluZGV4T2YoZGVsaW1pdGVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLm9mZnNldCwgdGhpcy5zaXplKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5vZmZzZXQsIHBvcyArIDEpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBwb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIGRlbGltaXRlci4gVGhlIHJlc3VsdCBkb2Vzbid0IGluY2x1ZGUgZGVsaW1pdGVyLlxuICAgICAqIFJldHVybnMgYWxsIHJlbWFpbmluZyBkYXRhIGlmIG5vIGRlbGltaXRlciBpcyBmb3VuZC5cbiAgICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBuZXcgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0gZGVsaW1pdGVyIGEgYnl0ZSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZW5kIG9mIHJlYWRpbmcgZGF0YS5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbiAoZGVsaW1pdGVyKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKGRlbGltaXRlciwgdGhpcy5vZmZzZXQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmIChwb3MgPT09IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZyb21VaW50OEFycmF5KHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLnNpemUpKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnJvbVVpbnQ4QXJyYXkodGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5vZmZzZXQsIHBvcykpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBwb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBuIGJ5dGVzIG9mIGRhdGEgZnJvbSB0aGlzIHN0cmVhbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGFuIGFzY2lpIHN0cmluZy5cbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlLCByZWFkcyB0byB0aGUgZW5kIG9mIHRoaXMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBuIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRBc2NpaVN0cmluZyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB0b0JpbmFyeVN0cmluZyh0aGlzLnJlYWQobikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyBhIHN0cmluZyBvZiBsZW5ndGggbi5cbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlLCByZWFkcyB0byB0aGUgZW5kIG9mIHRoaXMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBuIGlzIHRoZSBzdHJpbmcoVVRGMTYpIGxlbmd0aC5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkU3RyaW5nQXNCeXRlcyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JZVEVTO1xuICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLm9mZnNldCwgdGhpcy5zaXplKTtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYnl0ZXMubGVuZ3RoOyBpIDwgbiAmJiBvZmZzZXQgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IGJ5dGVzW29mZnNldCsrXTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdCA+PiA0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgbGVuZ3RoXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmZpbmlzaGVkIFVURi04IG9jdGV0IHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDEgPCBsZW5ndGhfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZmluaXNoZWQgVVRGLTggb2N0ZXQgc2VxdWVuY2UnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbmd0aF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVuZSA9ICgoKHVuaXQgJiAweDA3KSA8PCAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoYnl0ZXNbb2Zmc2V0KytdICYgMHgzRikgPDwgMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoKGJ5dGVzW29mZnNldCsrXSAmIDB4M0YpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoYnl0ZXNbb2Zmc2V0KytdICYgMHgzRikpIC0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IHJ1bmUgJiYgcnVuZSA8PSAweEZGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgb3V0c2lkZSB2YWxpZCBVbmljb2RlIHJhbmdlOiAweCcgKyBydW5lLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmZpbmlzaGVkIFVURi04IG9jdGV0IHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgVVRGLTggZW5jb2RpbmcgMHgnICsgdW5pdC50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIG9mZnNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIGxlbmd0aCBuLlxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUsIHJlYWRzIHRvIHRoZSBlbmQgb2YgdGhpcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIG4gaXMgdGhlIHN0cmluZyhVVEYxNikgbGVuZ3RoLlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgX2EgPSByZWFkU3RyaW5nKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLnNpemUpLCBuKSwgc3RyID0gX2FbMF0sIGxlbmd0aCA9IF9hWzFdO1xuICAgICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgdGhlIGludGVybmFsIGJ1ZmZlciBhbmQgY2xlYXJzIGB0aGlzYC5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS50YWtlQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXM7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29udGVudHMgYW5kIGxlYXZlcyBgdGhpc2AgaW50YWN0LlxuICAgICAqL1xuICAgIEJ5dGVTdHJlYW0ucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLmJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJlYW0uXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmcm9tVWludDhBcnJheSh0aGlzLmJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXhhY3QgY29weSBvZiB0aGlzIHN0cmVhbS5cbiAgICAgKi9cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlU3RyZWFtKHRoaXMudG9CeXRlcygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyB0aGlzIHN0cmVhbSwgb25seSBsZWF2ZXMgdGhlIHVucmVhZCBkYXRhLlxuICAgICAqIFRoZSBwb3NpdGlvbiBpcyByZXNldCB0byAwLlxuICAgICAqIFRoZSBtYXJrIGlzIGNsZWFyZWQuXG4gICAgICovXG4gICAgQnl0ZVN0cmVhbS5wcm90b3R5cGUudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5yZW1haW5zO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy53bWFyayA9IDA7XG4gICAgICAgIHRoaXMucm1hcmsgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIEJ5dGVTdHJlYW07XG59KCkpO1xuZXhwb3J0cy5CeXRlU3RyZWFtID0gQnl0ZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBEZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIERlc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI5LCAyMDI5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnl0ZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vQnl0ZVN0cmVhbVwiKTtcbnZhciBBcnJheURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZGVzZXJpYWxpemVycy9BcnJheURlc2VyaWFsaXplclwiKTtcbnZhciBUeXBlZEFycmF5RGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL1R5cGVkQXJyYXlEZXNlcmlhbGl6ZXJcIik7XG52YXIgRnVuY3Rpb25EZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL2Rlc2VyaWFsaXplcnMvRnVuY3Rpb25EZXNlcmlhbGl6ZXJcIik7XG52YXIgTnVtYmVyRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL051bWJlckRlc2VyaWFsaXplclwiKTtcbnZhciBCb29sZWFuRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL0Jvb2xlYW5EZXNlcmlhbGl6ZXJcIik7XG52YXIgU3RyaW5nRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL1N0cmluZ0Rlc2VyaWFsaXplclwiKTtcbnZhciBEYXRlRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL0RhdGVEZXNlcmlhbGl6ZXJcIik7XG52YXIgQnl0ZVN0cmVhbURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZGVzZXJpYWxpemVycy9CeXRlU3RyZWFtRGVzZXJpYWxpemVyXCIpO1xudmFyIFNldERlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZGVzZXJpYWxpemVycy9TZXREZXNlcmlhbGl6ZXJcIik7XG52YXIgTWFwRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL01hcERlc2VyaWFsaXplclwiKTtcbnZhciBHdWlkRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL0d1aWREZXNlcmlhbGl6ZXJcIik7XG52YXIgRXJyb3JEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL2Rlc2VyaWFsaXplcnMvRXJyb3JEZXNlcmlhbGl6ZXJcIik7XG52YXIgTnVsbERlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZGVzZXJpYWxpemVycy9OdWxsRGVzZXJpYWxpemVyXCIpO1xudmFyIERlZmF1bHREZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL2Rlc2VyaWFsaXplcnMvRGVmYXVsdERlc2VyaWFsaXplclwiKTtcbnZhciBndWlkX3R5cGVzY3JpcHRfMSA9IHJlcXVpcmUoXCJndWlkLXR5cGVzY3JpcHRcIik7XG52YXIgZGVzZXJpYWxpemVycyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGRlc2VyaWFsaXplcikge1xuICAgIGRlc2VyaWFsaXplcnMuc2V0KHR5cGUsIGRlc2VyaWFsaXplcik7XG59XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uOiByZXR1cm4gRnVuY3Rpb25EZXNlcmlhbGl6ZXJfMS5GdW5jdGlvbkRlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgTnVtYmVyOiByZXR1cm4gTnVtYmVyRGVzZXJpYWxpemVyXzEuTnVtYmVyRGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOiByZXR1cm4gQm9vbGVhbkRlc2VyaWFsaXplcl8xLkJvb2xlYW5EZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFN0cmluZzogcmV0dXJuIFN0cmluZ0Rlc2VyaWFsaXplcl8xLlN0cmluZ0Rlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgRGF0ZTogcmV0dXJuIERhdGVEZXNlcmlhbGl6ZXJfMS5EYXRlRGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBBcnJheTogcmV0dXJuIEFycmF5RGVzZXJpYWxpemVyXzEuQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtOiByZXR1cm4gQnl0ZVN0cmVhbURlc2VyaWFsaXplcl8xLkJ5dGVTdHJlYW1EZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFVpbnQ4QXJyYXk6IHJldHVybiBUeXBlZEFycmF5RGVzZXJpYWxpemVyXzEuVWludDhBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6IHJldHVybiBUeXBlZEFycmF5RGVzZXJpYWxpemVyXzEuVWludDhDbGFtcGVkQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFVpbnQxNkFycmF5OiByZXR1cm4gVHlwZWRBcnJheURlc2VyaWFsaXplcl8xLlVpbnQxNkFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBVaW50MzJBcnJheTogcmV0dXJuIFR5cGVkQXJyYXlEZXNlcmlhbGl6ZXJfMS5VaW50MzJBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgSW50OEFycmF5OiByZXR1cm4gVHlwZWRBcnJheURlc2VyaWFsaXplcl8xLkludDhBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgSW50MTZBcnJheTogcmV0dXJuIFR5cGVkQXJyYXlEZXNlcmlhbGl6ZXJfMS5JbnQxNkFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBJbnQzMkFycmF5OiByZXR1cm4gVHlwZWRBcnJheURlc2VyaWFsaXplcl8xLkludDMyQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIEZsb2F0MzJBcnJheTogcmV0dXJuIFR5cGVkQXJyYXlEZXNlcmlhbGl6ZXJfMS5GbG9hdDMyQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIEZsb2F0NjRBcnJheTogcmV0dXJuIFR5cGVkQXJyYXlEZXNlcmlhbGl6ZXJfMS5GbG9hdDY0QXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFNldDogcmV0dXJuIFNldERlc2VyaWFsaXplcl8xLlNldERlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgTWFwOiByZXR1cm4gTWFwRGVzZXJpYWxpemVyXzEuTWFwRGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBndWlkX3R5cGVzY3JpcHRfMS5HdWlkOiByZXR1cm4gR3VpZERlc2VyaWFsaXplcl8xLkd1aWREZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIEVycm9yOiByZXR1cm4gRXJyb3JEZXNlcmlhbGl6ZXJfMS5FcnJvckRlc2VyaWFsaXplci5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gZGVzZXJpYWxpemVycy5nZXQodHlwZSk7XG4gICAgICAgIGlmIChkZXNlcmlhbGl6ZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gTnVsbERlc2VyaWFsaXplcl8xLk51bGxEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgcmV0dXJuIERlZmF1bHREZXNlcmlhbGl6ZXJfMS5EZWZhdWx0RGVzZXJpYWxpemVyLmluc3RhbmNlO1xufVxuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgRm9ybWF0dGVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBGb3JtYXR0ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEZlYiAxNywgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ5dGVTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL0J5dGVTdHJlYW1cIik7XG52YXIgV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9Xcml0ZXJcIik7XG52YXIgUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9SZWFkZXJcIik7XG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUsIHNpbXBsZSwgdXRjKSB7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBCeXRlU3RyZWFtXzEuQnl0ZVN0cmVhbSgpO1xuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyXzEuV3JpdGVyKHN0cmVhbSwgc2ltcGxlLCB1dGMpO1xuICAgIHdyaXRlci5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiBzdHJlYW0uYnl0ZXM7XG59XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHN0cmVhbSwgdHlwZSwgc2ltcGxlKSB7XG4gICAgaWYgKCEoc3RyZWFtIGluc3RhbmNlb2YgQnl0ZVN0cmVhbV8xLkJ5dGVTdHJlYW0pKSB7XG4gICAgICAgIHN0cmVhbSA9IG5ldyBCeXRlU3RyZWFtXzEuQnl0ZVN0cmVhbShzdHJlYW0pO1xuICAgIH1cbiAgICB2YXIgcmVhZGVyID0gbmV3IFJlYWRlcl8xLlJlYWRlcihzdHJlYW0sIHNpbXBsZSk7XG4gICAgcmV0dXJuIHJlYWRlci5kZXNlcmlhbGl6ZSh0eXBlKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1hdHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFJlYWRlci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgUmVhZGVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBKYW4gMTEsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBWYWx1ZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vVmFsdWVSZWFkZXJcIik7XG52YXIgVHlwZU1hbmFnZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZU1hbmFnZXJcIikpO1xudmFyIERlc2VyaWFsaXplciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9EZXNlcmlhbGl6ZXJcIikpO1xucmVxdWlyZShcIi4vZGVzZXJpYWxpemVycy9CaWdJbnREZXNlcmlhbGl6ZXJcIik7XG5yZXF1aXJlKFwiLi9kZXNlcmlhbGl6ZXJzL0JpZ0ludEFycmF5RGVzZXJpYWxpemVyXCIpO1xudmFyIFJlYWRlclJlZmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlYWRlclJlZmVyKCkge1xuICAgICAgICB0aGlzLnJlZiA9IFtdO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyUmVmZXIucHJvdG90eXBlLCBcImxhc3RJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmLmxlbmd0aCAtIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJlYWRlclJlZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZWYucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBSZWFkZXJSZWZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlZltpbmRleF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFJlYWRlclJlZmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZltpbmRleF07XG4gICAgfTtcbiAgICBSZWFkZXJSZWZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVmLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZGVyUmVmZXI7XG59KCkpO1xudmFyIFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWFkZXIoc3RyZWFtLCBzaW1wbGUpIHtcbiAgICAgICAgaWYgKHNpbXBsZSA9PT0gdm9pZCAwKSB7IHNpbXBsZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnJlZiA9IFtdO1xuICAgICAgICB0aGlzLmxvbmdUeXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuZGljdFR5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgdGhpcy5zaW1wbGUgPSBzaW1wbGU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCBcInNpbXBsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXIgPSB2YWx1ZSA/IHVuZGVmaW5lZCA6IG5ldyBSZWFkZXJSZWZlcigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSZWFkZXIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIERlc2VyaWFsaXplci5nZXRJbnN0YW5jZSh0eXBlKS5kZXNlcmlhbGl6ZSh0aGlzKTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIERlc2VyaWFsaXplci5nZXRJbnN0YW5jZSh0eXBlKS5yZWFkKHRoaXMsIHRhZyk7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnJlYWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICB2YXIgbmFtZSA9IFZhbHVlUmVhZGVyXzEucmVhZFN0cmluZyhzdHJlYW0pO1xuICAgICAgICB2YXIgY291bnQgPSBWYWx1ZVJlYWRlcl8xLnJlYWRDb3VudChzdHJlYW0pO1xuICAgICAgICB2YXIgbmFtZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICB2YXIgc3RyRGVzZXJpYWxpemUgPSBEZXNlcmlhbGl6ZXIuZ2V0SW5zdGFuY2UoU3RyaW5nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lc1tpXSA9IHN0ckRlc2VyaWFsaXplLmRlc2VyaWFsaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICB0aGlzLnJlZi5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBuYW1lczogbmFtZXMsXG4gICAgICAgICAgICB0eXBlOiBUeXBlTWFuYWdlci5nZXRUeXBlKG5hbWUpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5nZXRUeXBlSW5mbyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZbaW5kZXhdO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5yZWFkUmVmZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlciA/IHRoaXMucmVmZXIucmVhZChWYWx1ZVJlYWRlcl8xLnJlYWRJbnQodGhpcy5zdHJlYW0pKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuYWRkUmVmZXJlbmNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyKVxuICAgICAgICAgICAgdGhpcy5yZWZlci5hZGQodmFsdWUpO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zZXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyKVxuICAgICAgICAgICAgdGhpcy5yZWZlci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCBcImxhc3RSZWZlcmVuY2VJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXIgPyB0aGlzLnJlZmVyLmxhc3RJbmRleCA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZlcilcbiAgICAgICAgICAgIHRoaXMucmVmZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yZWYubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkZXI7XG59KCkpO1xuZXhwb3J0cy5SZWFkZXIgPSBSZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBSZWZlcmVuY2VSZWFkZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHJlZmVyZW5jZSByZWFkZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVmFsdWVSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vVmFsdWVSZWFkZXJcIikpO1xuZnVuY3Rpb24gcmVhZEJ5dGVzKHJlYWRlcikge1xuICAgIHZhciByZXN1bHQgPSBWYWx1ZVJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnN0cmVhbSk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlYWRCeXRlcyA9IHJlYWRCeXRlcztcbmZ1bmN0aW9uIHJlYWRBc2NpaVN0cmluZyhyZWFkZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gVmFsdWVSZWFkZXIucmVhZEFzY2lpU3RyaW5nKHJlYWRlci5zdHJlYW0pO1xuICAgIHJlYWRlci5hZGRSZWZlcmVuY2UocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZWFkQXNjaWlTdHJpbmcgPSByZWFkQXNjaWlTdHJpbmc7XG5mdW5jdGlvbiByZWFkU3RyaW5nKHJlYWRlcikge1xuICAgIHZhciByZXN1bHQgPSBWYWx1ZVJlYWRlci5yZWFkU3RyaW5nKHJlYWRlci5zdHJlYW0pO1xuICAgIHJlYWRlci5hZGRSZWZlcmVuY2UocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZWFkU3RyaW5nID0gcmVhZFN0cmluZztcbmZ1bmN0aW9uIHJlYWRHdWlkKHJlYWRlcikge1xuICAgIHZhciByZXN1bHQgPSBWYWx1ZVJlYWRlci5yZWFkR3VpZChyZWFkZXIuc3RyZWFtKTtcbiAgICByZWFkZXIuYWRkUmVmZXJlbmNlKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVhZEd1aWQgPSByZWFkR3VpZDtcbmZ1bmN0aW9uIHJlYWREYXRlVGltZShyZWFkZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gVmFsdWVSZWFkZXIucmVhZERhdGVUaW1lKHJlYWRlci5zdHJlYW0pO1xuICAgIHJlYWRlci5hZGRSZWZlcmVuY2UocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZWFkRGF0ZVRpbWUgPSByZWFkRGF0ZVRpbWU7XG5mdW5jdGlvbiByZWFkVGltZShyZWFkZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gVmFsdWVSZWFkZXIucmVhZFRpbWUocmVhZGVyLnN0cmVhbSk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG5mdW5jdGlvbiByZWFkQXJyYXkocmVhZGVyKSB7XG4gICAgdmFyIHN0cmVhbSA9IHJlYWRlci5zdHJlYW07XG4gICAgdmFyIGNvdW50ID0gVmFsdWVSZWFkZXIucmVhZENvdW50KHN0cmVhbSk7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHJlYWRlci5hZGRSZWZlcmVuY2UoYSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGFbaV0gPSByZWFkZXIuZGVzZXJpYWxpemUoKTtcbiAgICB9XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLnJlYWRBcnJheSA9IHJlYWRBcnJheTtcbmZ1bmN0aW9uIHJlYWRTZXQocmVhZGVyKSB7XG4gICAgdmFyIHN0cmVhbSA9IHJlYWRlci5zdHJlYW07XG4gICAgdmFyIGNvdW50ID0gVmFsdWVSZWFkZXIucmVhZENvdW50KHN0cmVhbSk7XG4gICAgdmFyIGEgPSBuZXcgU2V0KCk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgYS5hZGQocmVhZGVyLmRlc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMucmVhZFNldCA9IHJlYWRTZXQ7XG5mdW5jdGlvbiByZWFkTWFwKHJlYWRlcikge1xuICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShtYXApO1xuICAgIHZhciBjb3VudCA9IFZhbHVlUmVhZGVyLnJlYWRDb3VudChzdHJlYW0pO1xuICAgIGZvciAoOyBjb3VudCA+IDA7IC0tY291bnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHJlYWRlci5kZXNlcmlhbGl6ZSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZWFkZXIuZGVzZXJpYWxpemUoKTtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbmV4cG9ydHMucmVhZE1hcCA9IHJlYWRNYXA7XG5mdW5jdGlvbiByZWFkT2JqZWN0KHJlYWRlcikge1xuICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgIHZhciBpbmRleCA9IFZhbHVlUmVhZGVyLnJlYWRJbnQoc3RyZWFtLCAxMjMgLyogVGFnT3BlbmJyYWNlICovKTtcbiAgICB2YXIgdHlwZUluZm8gPSByZWFkZXIuZ2V0VHlwZUluZm8oaW5kZXgpO1xuICAgIHZhciB0eXBlID0gdHlwZUluZm8udHlwZTtcbiAgICB2YXIgb2JqID0gKHR5cGUpID8gbmV3IHR5cGUoKSA6IHt9O1xuICAgIHJlYWRlci5hZGRSZWZlcmVuY2Uob2JqKTtcbiAgICB2YXIgbmFtZXMgPSB0eXBlSW5mby5uYW1lcztcbiAgICB2YXIgY291bnQgPSBuYW1lcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG9ialtuYW1lc1tpXV0gPSByZWFkZXIuZGVzZXJpYWxpemUoKTtcbiAgICB9XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMucmVhZE9iamVjdCA9IHJlYWRPYmplY3Q7XG5mdW5jdGlvbiByZWFkT2JqZWN0QXNNYXAocmVhZGVyKSB7XG4gICAgdmFyIHN0cmVhbSA9IHJlYWRlci5zdHJlYW07XG4gICAgdmFyIGluZGV4ID0gVmFsdWVSZWFkZXIucmVhZEludChzdHJlYW0sIDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xuICAgIHZhciB0eXBlSW5mbyA9IHJlYWRlci5nZXRUeXBlSW5mbyhpbmRleCk7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICByZWFkZXIuYWRkUmVmZXJlbmNlKG1hcCk7XG4gICAgdmFyIG5hbWVzID0gdHlwZUluZm8ubmFtZXM7XG4gICAgdmFyIGNvdW50ID0gbmFtZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtYXAuc2V0KG5hbWVzW2ldLCByZWFkZXIuZGVzZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiBtYXA7XG59XG5leHBvcnRzLnJlYWRPYmplY3RBc01hcCA9IHJlYWRPYmplY3RBc01hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZmVyZW5jZVJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgU2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBEZWMgMTgsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCeXRlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9CeXRlU3RyZWFtXCIpO1xudmFyIEJhc2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVycy9CYXNlU2VyaWFsaXplclwiKTtcbnZhciBOdW1iZXJTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVycy9OdW1iZXJTZXJpYWxpemVyXCIpO1xudmFyIEJvb2xlYW5TZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVycy9Cb29sZWFuU2VyaWFsaXplclwiKTtcbnZhciBTdHJpbmdTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVycy9TdHJpbmdTZXJpYWxpemVyXCIpO1xudmFyIERhdGVTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVycy9EYXRlU2VyaWFsaXplclwiKTtcbnZhciBCeXRlc1NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJzL0J5dGVzU2VyaWFsaXplclwiKTtcbnZhciBHdWlkU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplcnMvR3VpZFNlcmlhbGl6ZXJcIik7XG52YXIgVHlwZWRBcnJheVNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJzL1R5cGVkQXJyYXlTZXJpYWxpemVyXCIpO1xudmFyIEFycmF5U2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplcnMvQXJyYXlTZXJpYWxpemVyXCIpO1xudmFyIFNldFNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJzL1NldFNlcmlhbGl6ZXJcIik7XG52YXIgTWFwU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplcnMvTWFwU2VyaWFsaXplclwiKTtcbnZhciBEaWN0aW9uYXJ5U2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplcnMvRGljdGlvbmFyeVNlcmlhbGl6ZXJcIik7XG52YXIgT2JqZWN0U2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplcnMvT2JqZWN0U2VyaWFsaXplclwiKTtcbnZhciBFcnJvclNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJzL0Vycm9yU2VyaWFsaXplclwiKTtcbnZhciBUeXBlTWFuYWdlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9UeXBlTWFuYWdlclwiKSk7XG52YXIgVmFsdWVXcml0ZXJfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlV3JpdGVyXCIpO1xudmFyIGd1aWRfdHlwZXNjcmlwdF8xID0gcmVxdWlyZShcImd1aWQtdHlwZXNjcmlwdFwiKTtcbnZhciBzZXJpYWxpemVycyA9IG5ldyBNYXAoKTtcbnZhciBudWxsU2VyaWFsaXplciA9IG5ldyBCYXNlU2VyaWFsaXplcl8xLkJhc2VTZXJpYWxpemVyKCk7XG52YXIgbnVtYmVyU2VyaWFsaXplciA9IG5ldyBOdW1iZXJTZXJpYWxpemVyXzEuTnVtYmVyU2VyaWFsaXplcigpO1xudmFyIGJvb2xlYW5TZXJpYWxpemVyID0gbmV3IEJvb2xlYW5TZXJpYWxpemVyXzEuQm9vbGVhblNlcmlhbGl6ZXIoKTtcbnZhciBzdHJpbmdTZXJpYWxpemVyID0gbmV3IFN0cmluZ1NlcmlhbGl6ZXJfMS5TdHJpbmdTZXJpYWxpemVyKCk7XG52YXIgZGF0ZVNlcmlhbGl6ZXIgPSBuZXcgRGF0ZVNlcmlhbGl6ZXJfMS5EYXRlU2VyaWFsaXplcigpO1xudmFyIGJ5dGVzU2VyaWFsaXplciA9IG5ldyBCeXRlc1NlcmlhbGl6ZXJfMS5CeXRlc1NlcmlhbGl6ZXIoKTtcbnZhciBndWlkU2VyaWFsaXplciA9IG5ldyBHdWlkU2VyaWFsaXplcl8xLkd1aWRTZXJpYWxpemVyKCk7XG52YXIgaW50QXJyYXlTZXJpYWxpemVyID0gbmV3IFR5cGVkQXJyYXlTZXJpYWxpemVyXzEuVHlwZWRBcnJheVNlcmlhbGl6ZXIoVmFsdWVXcml0ZXJfMS53cml0ZUludGVnZXIpO1xudmFyIGRvdWJsZUFycmF5U2VyaWFsaXplciA9IG5ldyBUeXBlZEFycmF5U2VyaWFsaXplcl8xLlR5cGVkQXJyYXlTZXJpYWxpemVyKFZhbHVlV3JpdGVyXzEud3JpdGVEb3VibGUpO1xudmFyIGFycmF5U2VyaWFsaXplciA9IG5ldyBBcnJheVNlcmlhbGl6ZXJfMS5BcnJheVNlcmlhbGl6ZXIoKTtcbnZhciBzZXRTZXJpYWxpemVyID0gbmV3IFNldFNlcmlhbGl6ZXJfMS5TZXRTZXJpYWxpemVyKCk7XG52YXIgbWFwU2VyaWFsaXplciA9IG5ldyBNYXBTZXJpYWxpemVyXzEuTWFwU2VyaWFsaXplcigpO1xudmFyIGRpY3Rpb25hcnlTZXJpYWxpemVyID0gbmV3IERpY3Rpb25hcnlTZXJpYWxpemVyXzEuRGljdGlvbmFyeVNlcmlhbGl6ZXIoKTtcbnZhciBlcnJvclNlcmlhbGl6ZXIgPSBuZXcgRXJyb3JTZXJpYWxpemVyXzEuRXJyb3JTZXJpYWxpemVyKCk7XG5mdW5jdGlvbiByZWdpc3Rlcih0eXBlLCBzZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplcnMuc2V0KHR5cGUsIHNlcmlhbGl6ZXIpO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2UodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uOiByZXR1cm4gbnVsbFNlcmlhbGl6ZXI7XG4gICAgICAgIGNhc2UgTnVtYmVyOiByZXR1cm4gbnVtYmVyU2VyaWFsaXplcjtcbiAgICAgICAgY2FzZSBCb29sZWFuOiByZXR1cm4gYm9vbGVhblNlcmlhbGl6ZXI7XG4gICAgICAgIGNhc2UgU3RyaW5nOiByZXR1cm4gc3RyaW5nU2VyaWFsaXplcjtcbiAgICAgICAgY2FzZSBEYXRlOiByZXR1cm4gZGF0ZVNlcmlhbGl6ZXI7XG4gICAgICAgIGNhc2UgZ3VpZF90eXBlc2NyaXB0XzEuR3VpZDogcmV0dXJuIGd1aWRTZXJpYWxpemVyO1xuICAgICAgICBjYXNlIEFycmF5OiByZXR1cm4gYXJyYXlTZXJpYWxpemVyO1xuICAgICAgICBjYXNlIFNldDogcmV0dXJuIHNldFNlcmlhbGl6ZXI7XG4gICAgICAgIGNhc2UgTWFwOiByZXR1cm4gbWFwU2VyaWFsaXplcjtcbiAgICAgICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgICBjYXNlIEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtOiByZXR1cm4gYnl0ZXNTZXJpYWxpemVyO1xuICAgICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgIGNhc2UgVWludDMyQXJyYXk6IHJldHVybiBpbnRBcnJheVNlcmlhbGl6ZXI7XG4gICAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgICBjYXNlIEZsb2F0NjRBcnJheTogcmV0dXJuIGRvdWJsZUFycmF5U2VyaWFsaXplcjtcbiAgICAgICAgY2FzZSBFcnJvcjogcmV0dXJuIGVycm9yU2VyaWFsaXplcjtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVycy5nZXQodHlwZSk7XG4gICAgaWYgKHNlcmlhbGl6ZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKVxuICAgICAgICByZXR1cm4gYXJyYXlTZXJpYWxpemVyO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJlZ2lzdGVyKHR5cGUsIGVycm9yU2VyaWFsaXplcik7XG4gICAgICAgIHJldHVybiBlcnJvclNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIHZhciBuYW1lID0gVHlwZU1hbmFnZXIuZ2V0TmFtZSh0eXBlKTtcbiAgICBpZiAobmFtZSA9PT0gJycpXG4gICAgICAgIHJldHVybiBkaWN0aW9uYXJ5U2VyaWFsaXplcjtcbiAgICBpZiAobmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIG51bGxTZXJpYWxpemVyO1xuICAgIGlmIChuYW1lID09PSAnQXN5bmNGdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBudWxsU2VyaWFsaXplcjtcbiAgICB2YXIgb2JqZWN0U2VyaWFsaXplciA9IG5ldyBPYmplY3RTZXJpYWxpemVyXzEuT2JqZWN0U2VyaWFsaXplcih2YWx1ZSwgbmFtZSk7XG4gICAgcmVnaXN0ZXIodHlwZSwgb2JqZWN0U2VyaWFsaXplcik7XG4gICAgcmV0dXJuIG9iamVjdFNlcmlhbGl6ZXI7XG59XG5leHBvcnRzLmdldEluc3RhbmNlID0gZ2V0SW5zdGFuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVHlwZU1hbmFnZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBUeXBlTWFuYWdlciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiA2LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHR5cGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgbmFtZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmlmICghKCduYW1lJyBpbiBGdW5jdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0b3IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gY3Rvci5zdWJzdHIoMCwgY3Rvci5pbmRleE9mKCcoJykpLnJlcGxhY2UoLyheXFxzKmZ1bmN0aW9uXFxzKil8KFxccyokKS9pZywgJycpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHlwZS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXIodHlwZSwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpXG4gICAgICAgIG5hbWUgPSB0eXBlLm5hbWU7XG4gICAgbmFtZUNhY2hlLnNldCh0eXBlLCBuYW1lKTtcbiAgICB0eXBlQ2FjaGVbbmFtZV0gPSB0eXBlO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG5hbWUgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWdpc3RlcmVkKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSBpbiB0eXBlQ2FjaGU7XG59XG5leHBvcnRzLmlzUmVnaXN0ZXJlZCA9IGlzUmVnaXN0ZXJlZDtcbi8qKlxuICogR2V0cyBuYW1lIGJ5IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUodHlwZSkge1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHZhciBuYW1lID0gbmFtZUNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAobmFtZSlcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgbmFtZSA9IHR5cGUubmFtZTtcbiAgICBpZiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gJ09iamVjdCcpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBuYW1lQ2FjaGUuc2V0KHR5cGUsIG5hbWUpO1xuICAgIHR5cGVDYWNoZVtuYW1lXSA9IHR5cGU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnRzLmdldE5hbWUgPSBnZXROYW1lO1xudmFyIHJvb3QgPSBudWxsO1xudHJ5IHtcbiAgICByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgPyBnbG9iYWwgOiB3aW5kb3c7XG59XG5jYXRjaCAoZSkgeyB9XG5mdW5jdGlvbiBsb2FkVHlwZShuYW1lKSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvYmogPSByb290O1xuICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9ialtuYW1lc1tpXV07XG4gICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIChvYmopICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBmaW5kVHlwZShhbGlhcywgcG9zaXRpb25zLCBpLCBjKSB7XG4gICAgaWYgKGkgPCBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGFsaWFzW3Bvc2l0aW9uc1tpKytdXSA9IGM7XG4gICAgICAgIHZhciB0eXBlID0gZmluZFR5cGUoYWxpYXMsIHBvc2l0aW9ucywgaSwgJy4nKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBpIDwgcG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdHlwZSA9IGZpbmRUeXBlKGFsaWFzLCBwb3NpdGlvbnMsIGksICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBsb2FkVHlwZShhbGlhcy5qb2luKCcnKSk7XG59XG4vKipcbiAqIEdldHMgdHlwZSBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlKG5hbWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVDYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgdHlwZSA9IGxvYWRUeXBlKG5hbWUpO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHJlZ2lzdGVyKHR5cGUsIG5hbWUpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciBwb3MgPSBuYW1lLmluZGV4T2YoJ18nKTtcbiAgICB3aGlsZSAocG9zID49IDApIHtcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGhdID0gcG9zO1xuICAgICAgICBwb3MgPSBuYW1lLmluZGV4T2YoJ18nLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhbGlhcyA9IG5hbWUuc3BsaXQoJycpO1xuICAgICAgICB0eXBlID0gZmluZFR5cGUoYWxpYXMsIHBvc2l0aW9ucywgMCwgJy4nKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHlwZSA9IGZpbmRUeXBlKGFsaWFzLCBwb3NpdGlvbnMsIDAsICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyKHR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHlwZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lIH0pO1xuICAgIHJlZ2lzdGVyKHR5cGUsIG5hbWUpO1xuICAgIHJldHVybiB0eXBlO1xufVxuZXhwb3J0cy5nZXRUeXBlID0gZ2V0VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVmFsdWVSZWFkZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSB2YWx1ZSByZWFkZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGd1aWRfdHlwZXNjcmlwdF8xID0gcmVxdWlyZShcImd1aWQtdHlwZXNjcmlwdFwiKTtcbmZ1bmN0aW9uIHJlYWRJbnQoc3RyZWFtLCB0YWcpIHtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHsgdGFnID0gNTkgLyogVGFnU2VtaWNvbG9uICovOyB9XG4gICAgdmFyIHMgPSBzdHJlYW0ucmVhZFVudGlsKHRhZyk7XG4gICAgaWYgKHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gcGFyc2VJbnQocywgMTApO1xufVxuZXhwb3J0cy5yZWFkSW50ID0gcmVhZEludDtcbmZ1bmN0aW9uIHJlYWREb3VibGUoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyZWFtLnJlYWRVbnRpbCg1OSAvKiBUYWdTZW1pY29sb24gKi8pKTtcbn1cbmV4cG9ydHMucmVhZERvdWJsZSA9IHJlYWREb3VibGU7XG5mdW5jdGlvbiByZWFkSW5maW5pdHkoc3RyZWFtKSB7XG4gICAgcmV0dXJuICgoc3RyZWFtLnJlYWRCeXRlKCkgPT09IDQ1IC8qIFRhZ05lZyAqLykgPyAtSW5maW5pdHkgOiBJbmZpbml0eSk7XG59XG5leHBvcnRzLnJlYWRJbmZpbml0eSA9IHJlYWRJbmZpbml0eTtcbmZ1bmN0aW9uIHJlYWRDb3VudChzdHJlYW0pIHtcbiAgICByZXR1cm4gcmVhZEludChzdHJlYW0sIDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xufVxuZXhwb3J0cy5yZWFkQ291bnQgPSByZWFkQ291bnQ7XG5mdW5jdGlvbiByZWFkTGVuZ3RoKHN0cmVhbSkge1xuICAgIHJldHVybiByZWFkSW50KHN0cmVhbSwgMzQgLyogVGFnUXVvdGUgKi8pO1xufVxuZXhwb3J0cy5yZWFkTGVuZ3RoID0gcmVhZExlbmd0aDtcbmZ1bmN0aW9uIHJlYWRTdHJpbmcoc3RyZWFtKSB7XG4gICAgdmFyIG4gPSByZWFkTGVuZ3RoKHN0cmVhbSk7XG4gICAgdmFyIHJlc3VsdCA9IHN0cmVhbS5yZWFkU3RyaW5nKG4pO1xuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlYWRTdHJpbmcgPSByZWFkU3RyaW5nO1xuZnVuY3Rpb24gcmVhZEJ5dGVzKHN0cmVhbSkge1xuICAgIHZhciBuID0gcmVhZExlbmd0aChzdHJlYW0pO1xuICAgIHZhciByZXN1bHQgPSBzdHJlYW0ucmVhZChuKTtcbiAgICBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZWFkQnl0ZXMgPSByZWFkQnl0ZXM7XG5mdW5jdGlvbiByZWFkQXNjaWlTdHJpbmcoc3RyZWFtKSB7XG4gICAgdmFyIG4gPSByZWFkTGVuZ3RoKHN0cmVhbSk7XG4gICAgdmFyIHJlc3VsdCA9IHN0cmVhbS5yZWFkQXNjaWlTdHJpbmcobik7XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVhZEFzY2lpU3RyaW5nID0gcmVhZEFzY2lpU3RyaW5nO1xuZnVuY3Rpb24gcmVhZEd1aWQoc3RyZWFtKSB7XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgdmFyIHJlc3VsdCA9IGd1aWRfdHlwZXNjcmlwdF8xLkd1aWQucGFyc2Uoc3RyZWFtLnJlYWRBc2NpaVN0cmluZygzNikpO1xuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlYWRHdWlkID0gcmVhZEd1aWQ7XG5mdW5jdGlvbiByZWFkNERpZ2l0KHN0cmVhbSkge1xuICAgIHZhciBuID0gc3RyZWFtLnJlYWRCeXRlKCkgLSAweDMwO1xuICAgIG4gPSBuICogMTAgKyBzdHJlYW0ucmVhZEJ5dGUoKSAtIDB4MzA7XG4gICAgbiA9IG4gKiAxMCArIHN0cmVhbS5yZWFkQnl0ZSgpIC0gMHgzMDtcbiAgICByZXR1cm4gbiAqIDEwICsgc3RyZWFtLnJlYWRCeXRlKCkgLSAweDMwO1xufVxuZnVuY3Rpb24gcmVhZDJEaWdpdChzdHJlYW0pIHtcbiAgICB2YXIgbiA9IHN0cmVhbS5yZWFkQnl0ZSgpIC0gMHgzMDtcbiAgICByZXR1cm4gbiAqIDEwICsgc3RyZWFtLnJlYWRCeXRlKCkgLSAweDMwO1xufVxuZnVuY3Rpb24gcmVhZE1pbGxpc2Vjb25kKHN0cmVhbSkge1xuICAgIHZhciBtaWxsaXNlY29uZCA9IHN0cmVhbS5yZWFkQnl0ZSgpIC0gMHgzMDtcbiAgICBtaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kICogMTAgKyBzdHJlYW0ucmVhZEJ5dGUoKSAtIDB4MzA7XG4gICAgbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZCAqIDEwICsgc3RyZWFtLnJlYWRCeXRlKCkgLSAweDMwO1xuICAgIHZhciB0YWcgPSBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICBpZiAoKHRhZyA+PSAweDMwKSAmJiAodGFnIDw9IDB4MzkpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwKDIpO1xuICAgICAgICB0YWcgPSBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgaWYgKCh0YWcgPj0gMHgzMCkgJiYgKHRhZyA8PSAweDM5KSkge1xuICAgICAgICAgICAgc3RyZWFtLnNraXAoMik7XG4gICAgICAgICAgICB0YWcgPSBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbGxpc2Vjb25kLCB0YWddO1xufVxuZnVuY3Rpb24gcmVhZFRpbWUoc3RyZWFtKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBob3VyID0gcmVhZDJEaWdpdChzdHJlYW0pO1xuICAgIHZhciBtaW51dGUgPSByZWFkMkRpZ2l0KHN0cmVhbSk7XG4gICAgdmFyIHNlY29uZCA9IHJlYWQyRGlnaXQoc3RyZWFtKTtcbiAgICB2YXIgbWlsbGlzZWNvbmQgPSAwO1xuICAgIHZhciB0YWcgPSBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICBpZiAodGFnID09PSA0NiAvKiBUYWdQb2ludCAqLykge1xuICAgICAgICBfYSA9IHJlYWRNaWxsaXNlY29uZChzdHJlYW0pLCBtaWxsaXNlY29uZCA9IF9hWzBdLCB0YWcgPSBfYVsxXTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gOTAgLyogVGFnVVRDICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCk7XG59XG5leHBvcnRzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG5mdW5jdGlvbiByZWFkRGF0ZVRpbWUoc3RyZWFtKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciB5ZWFyID0gcmVhZDREaWdpdChzdHJlYW0pO1xuICAgIHZhciBtb250aCA9IHJlYWQyRGlnaXQoc3RyZWFtKSAtIDE7XG4gICAgdmFyIGRheSA9IHJlYWQyRGlnaXQoc3RyZWFtKTtcbiAgICB2YXIgdGFnID0gc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgaWYgKHRhZyA9PT0gODQgLyogVGFnVGltZSAqLykge1xuICAgICAgICB2YXIgaG91ciA9IHJlYWQyRGlnaXQoc3RyZWFtKTtcbiAgICAgICAgdmFyIG1pbnV0ZSA9IHJlYWQyRGlnaXQoc3RyZWFtKTtcbiAgICAgICAgdmFyIHNlY29uZCA9IHJlYWQyRGlnaXQoc3RyZWFtKTtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgdGFnID0gc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgIGlmICh0YWcgPT09IDQ2IC8qIFRhZ1BvaW50ICovKSB7XG4gICAgICAgICAgICBfYSA9IHJlYWRNaWxsaXNlY29uZChzdHJlYW0pLCBtaWxsaXNlY29uZCA9IF9hWzBdLCB0YWcgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSA5MCAvKiBUYWdVVEMgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gOTAgLyogVGFnVVRDICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcbn1cbmV4cG9ydHMucmVhZERhdGVUaW1lID0gcmVhZERhdGVUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWVSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBWYWx1ZVdyaXRlci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHZhbHVlIHdyaXRlciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDExLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB3cml0ZUludGVnZXIoc3RyZWFtLCB2YWx1ZSkge1xuICAgIGlmICgwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDkpIHtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgweDMwICsgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAodmFsdWUgfCAwKSkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMDUgLyogVGFnSW50ZWdlciAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEwOCAvKiBUYWdMb25nICovKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg1OSAvKiBUYWdTZW1pY29sb24gKi8pO1xuICAgIH1cbn1cbmV4cG9ydHMud3JpdGVJbnRlZ2VyID0gd3JpdGVJbnRlZ2VyO1xuZnVuY3Rpb24gd3JpdGVEb3VibGUoc3RyZWFtLCB2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg3OCAvKiBUYWdOYU4gKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMDAgLyogVGFnRG91YmxlICovKTtcbiAgICAgICAgc3RyZWFtLndyaXRlQXNjaWlTdHJpbmcoJycgKyB2YWx1ZSk7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNTkgLyogVGFnU2VtaWNvbG9uICovKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNzMgLyogVGFnSW5maW5pdHkgKi8pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKCh2YWx1ZSA+IDApID8gNDMgLyogVGFnUG9zICovIDogNDUgLyogVGFnTmVnICovKTtcbiAgICB9XG59XG5leHBvcnRzLndyaXRlRG91YmxlID0gd3JpdGVEb3VibGU7XG5mdW5jdGlvbiB3cml0ZUJpZ0ludChzdHJlYW0sIHZhbHVlKSB7XG4gICAgaWYgKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gOSkge1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDB4MzAgKyBOdW1iZXIodmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTA4IC8qIFRhZ0xvbmcgKi8pO1xuICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg1OSAvKiBUYWdTZW1pY29sb24gKi8pO1xuICAgIH1cbn1cbmV4cG9ydHMud3JpdGVCaWdJbnQgPSB3cml0ZUJpZ0ludDtcbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQm9keShzdHJlYW0sIHZhbHVlKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKVxuICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIG4pO1xuICAgIHN0cmVhbS53cml0ZUJ5dGUoMzQgLyogVGFnUXVvdGUgKi8pO1xuICAgIHN0cmVhbS53cml0ZVN0cmluZyh2YWx1ZSk7XG4gICAgc3RyZWFtLndyaXRlQnl0ZSgzNCAvKiBUYWdRdW90ZSAqLyk7XG59XG5leHBvcnRzLndyaXRlU3RyaW5nQm9keSA9IHdyaXRlU3RyaW5nQm9keTtcbmZ1bmN0aW9uIHdyaXRlVVRDRGF0ZShzdHJlYW0sIHZhbHVlKSB7XG4gICAgdmFyIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIHZhciBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIHZhciBkYXkgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgdmFyIGhvdXIgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBtaW51dGUgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgdmFyIHNlY29uZCA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICB2YXIgbWlsbGlzZWNvbmQgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB3cml0ZURhdGVUaW1lKHN0cmVhbSwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCB0cnVlKTtcbn1cbmV4cG9ydHMud3JpdGVVVENEYXRlID0gd3JpdGVVVENEYXRlO1xuZnVuY3Rpb24gd3JpdGVMb2NhbERhdGUoc3RyZWFtLCB2YWx1ZSkge1xuICAgIHZhciB5ZWFyID0gdmFsdWUuZ2V0RnVsbFllYXIoKTtcbiAgICB2YXIgbW9udGggPSB2YWx1ZS5nZXRNb250aCgpICsgMTtcbiAgICB2YXIgZGF5ID0gdmFsdWUuZ2V0RGF0ZSgpO1xuICAgIHZhciBob3VyID0gdmFsdWUuZ2V0SG91cnMoKTtcbiAgICB2YXIgbWludXRlID0gdmFsdWUuZ2V0TWludXRlcygpO1xuICAgIHZhciBzZWNvbmQgPSB2YWx1ZS5nZXRTZWNvbmRzKCk7XG4gICAgdmFyIG1pbGxpc2Vjb25kID0gdmFsdWUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgd3JpdGVEYXRlVGltZShzdHJlYW0sIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZmFsc2UpO1xufVxuZXhwb3J0cy53cml0ZUxvY2FsRGF0ZSA9IHdyaXRlTG9jYWxEYXRlO1xuZnVuY3Rpb24gd3JpdGVEYXRlVGltZShzdHJlYW0sIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgdXRjKSB7XG4gICAgaWYgKChob3VyID09PSAwKSAmJiAobWludXRlID09PSAwKSAmJiAoc2Vjb25kID09PSAwKSAmJiAobWlsbGlzZWNvbmQgPT09IDApKSB7XG4gICAgICAgIHdyaXRlRGF0ZShzdHJlYW0sIHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoeWVhciA9PT0gMTk3MCkgJiYgKG1vbnRoID09PSAxKSAmJiAoZGF5ID09PSAxKSkge1xuICAgICAgICB3cml0ZVRpbWUoc3RyZWFtLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVEYXRlKHN0cmVhbSwgeWVhciwgbW9udGgsIGRheSk7XG4gICAgICAgIHdyaXRlVGltZShzdHJlYW0sIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCk7XG4gICAgfVxuICAgIHN0cmVhbS53cml0ZUJ5dGUodXRjID8gOTAgLyogVGFnVVRDICovIDogNTkgLyogVGFnU2VtaWNvbG9uICovKTtcbn1cbmV4cG9ydHMud3JpdGVEYXRlVGltZSA9IHdyaXRlRGF0ZVRpbWU7XG5mdW5jdGlvbiB3cml0ZURhdGUoc3RyZWFtLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgc3RyZWFtLndyaXRlQnl0ZSg2OCAvKiBUYWdEYXRlICovKTtcbiAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygoJzAwMDAnICsgeWVhcikuc2xpY2UoLTQpKTtcbiAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygoJzAwJyArIG1vbnRoKS5zbGljZSgtMikpO1xuICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCgnMDAnICsgZGF5KS5zbGljZSgtMikpO1xufVxuZXhwb3J0cy53cml0ZURhdGUgPSB3cml0ZURhdGU7XG5mdW5jdGlvbiB3cml0ZVRpbWUoc3RyZWFtLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICBzdHJlYW0ud3JpdGVCeXRlKDg0IC8qIFRhZ1RpbWUgKi8pO1xuICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCgnMDAnICsgaG91cikuc2xpY2UoLTIpKTtcbiAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygoJzAwJyArIG1pbnV0ZSkuc2xpY2UoLTIpKTtcbiAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygoJzAwJyArIHNlY29uZCkuc2xpY2UoLTIpKTtcbiAgICBpZiAobWlsbGlzZWNvbmQgPiAwKSB7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNDYgLyogVGFnUG9pbnQgKi8pO1xuICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygoJzAwMCcgKyBtaWxsaXNlY29uZCkuc2xpY2UoLTMpKTtcbiAgICB9XG59XG5leHBvcnRzLndyaXRlVGltZSA9IHdyaXRlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlV3JpdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgV3JpdGVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBXcml0ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlcmlhbGl6ZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vU2VyaWFsaXplclwiKSk7XG5yZXF1aXJlKFwiLi9zZXJpYWxpemVycy9CaWdJbnRTZXJpYWxpemVyXCIpO1xucmVxdWlyZShcIi4vc2VyaWFsaXplcnMvQmlnSW50QXJyYXlTZXJpYWxpemVyXCIpO1xudmFyIFdyaXRlclJlZmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdyaXRlclJlZmVyKCkge1xuICAgICAgICB0aGlzLnJlZiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sYXN0ID0gMDtcbiAgICB9XG4gICAgV3JpdGVyUmVmZXIucHJvdG90eXBlLmFkZENvdW50ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHRoaXMubGFzdCArPSBjb3VudDtcbiAgICB9O1xuICAgIFdyaXRlclJlZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZWYuc2V0KHZhbHVlLCB0aGlzLmxhc3QrKyk7XG4gICAgfTtcbiAgICBXcml0ZXJSZWZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyZWFtLCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnJlZi5nZXQodmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMTQgLyogVGFnUmVmICovKTtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCcnICsgaW5kZXgpO1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg1OSAvKiBUYWdTZW1pY29sb24gKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgV3JpdGVyUmVmZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZi5jbGVhcigpO1xuICAgICAgICB0aGlzLmxhc3QgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlclJlZmVyO1xufSgpKTtcbnZhciBXcml0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV3JpdGVyKHN0cmVhbSwgc2ltcGxlLCB1dGMpIHtcbiAgICAgICAgaWYgKHNpbXBsZSA9PT0gdm9pZCAwKSB7IHNpbXBsZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh1dGMgPT09IHZvaWQgMCkgeyB1dGMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy51dGMgPSB1dGM7XG4gICAgICAgIHRoaXMucmVmID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhc3QgPSAwO1xuICAgICAgICB0aGlzLnNpbXBsZSA9IHNpbXBsZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsIFwic2ltcGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZlciA9IHZhbHVlID8gdW5kZWZpbmVkIDogbmV3IFdyaXRlclJlZmVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZUJ5dGUoMTEwIC8qIFRhZ051bGwgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgU2VyaWFsaXplci5nZXRJbnN0YW5jZSh2YWx1ZSkuc2VyaWFsaXplKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGVCeXRlKDExMCAvKiBUYWdOdWxsICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFNlcmlhbGl6ZXIuZ2V0SW5zdGFuY2UodmFsdWUpLndyaXRlKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS53cml0ZVJlZmVyZW5jZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlciA/IHRoaXMucmVmZXIud3JpdGUodGhpcy5zdHJlYW0sIHZhbHVlKSA6IGZhbHNlO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zZXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXIpXG4gICAgICAgICAgICB0aGlzLnJlZmVyLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmFkZFJlZmVyZW5jZUNvdW50ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyKVxuICAgICAgICAgICAgdGhpcy5yZWZlci5hZGRDb3VudChjb3VudCk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZlcilcbiAgICAgICAgICAgIHRoaXMucmVmZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yZWYuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5sYXN0ID0gMDtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVDbGFzcyA9IGZ1bmN0aW9uICh0eXBlLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJlZi5nZXQodHlwZSk7XG4gICAgICAgIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgciA9IHRoaXMubGFzdCsrO1xuICAgICAgICAgICAgdGhpcy5yZWYuc2V0KHR5cGUsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlcjtcbn0oKSk7XG5leHBvcnRzLldyaXRlciA9IFdyaXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyaXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEFycmF5RGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgYXJyYXkgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xudmFyIEFycmF5RGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdBcnJheScpIHx8IHRoaXM7XG4gICAgfVxuICAgIEFycmF5RGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZEFycmF5KHJlYWRlcik7XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIFtdO1xuICAgICAgICAgICAgY2FzZSAxMTUgLyogVGFnU3RyaW5nICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWRTdHJpbmcocmVhZGVyKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICBjYXNlIDk4IC8qIFRhZ0J5dGVzICovOiByZXR1cm4gQXJyYXkuZnJvbShSZWZlcmVuY2VSZWFkZXIucmVhZEJ5dGVzKHJlYWRlcikpO1xuICAgICAgICAgICAgY2FzZSAxMTQgLyogVGFnUmVmICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYWRlci5yZWFkUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IEFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEFycmF5RGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5BcnJheURlc2VyaWFsaXplciA9IEFycmF5RGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlEZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBCYXNlRGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGJhc2UgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWcpIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgIGNhc2UgMHgzMTpcbiAgICAgICAgY2FzZSAweDMyOlxuICAgICAgICBjYXNlIDB4MzM6XG4gICAgICAgIGNhc2UgMHgzNDpcbiAgICAgICAgY2FzZSAweDM1OlxuICAgICAgICBjYXNlIDB4MzY6XG4gICAgICAgIGNhc2UgMHgzNzpcbiAgICAgICAgY2FzZSAweDM4OlxuICAgICAgICBjYXNlIDB4Mzk6XG4gICAgICAgIGNhc2UgMTA1IC8qIFRhZ0ludGVnZXIgKi86IHJldHVybiAnaW50MzIgbnVtYmVyJztcbiAgICAgICAgY2FzZSAxMDggLyogVGFnTG9uZyAqLzogcmV0dXJuICdsb25nIG51bWJlcic7XG4gICAgICAgIGNhc2UgMTAwIC8qIFRhZ0RvdWJsZSAqLzogcmV0dXJuICdkb3VibGUgbnVtYmVyJztcbiAgICAgICAgY2FzZSAxMTAgLyogVGFnTnVsbCAqLzogcmV0dXJuICdudWxsIHwgdW5kZWZpbmVkJztcbiAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiAnZW1wdHkgc3RyaW5nJztcbiAgICAgICAgY2FzZSAxMTYgLyogVGFnVHJ1ZSAqLzogcmV0dXJuICd0cnVlJztcbiAgICAgICAgY2FzZSAxMDIgLyogVGFnRmFsc2UgKi86IHJldHVybiAnZmFsc2UnO1xuICAgICAgICBjYXNlIDc4IC8qIFRhZ05hTiAqLzogcmV0dXJuICdOYU4nO1xuICAgICAgICBjYXNlIDczIC8qIFRhZ0luZmluaXR5ICovOiByZXR1cm4gJ0luZmluaXR5JztcbiAgICAgICAgY2FzZSA2OCAvKiBUYWdEYXRlICovOlxuICAgICAgICBjYXNlIDg0IC8qIFRhZ1RpbWUgKi86IHJldHVybiAnRGF0ZSc7XG4gICAgICAgIGNhc2UgOTggLyogVGFnQnl0ZXMgKi86IHJldHVybiAnVWludDhBcnJheSc7XG4gICAgICAgIGNhc2UgMTE3IC8qIFRhZ1VURjhDaGFyICovOlxuICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgY2FzZSAxMDMgLyogVGFnR3VpZCAqLzogcmV0dXJuICdndWlkIHN0cmluZyc7XG4gICAgICAgIGNhc2UgOTcgLyogVGFnTGlzdCAqLzogcmV0dXJuICdBcnJheSc7XG4gICAgICAgIGNhc2UgMTA5IC8qIFRhZ01hcCAqLzogcmV0dXJuICdvYmplY3QgfCBNYXAnO1xuICAgICAgICBjYXNlIDk5IC8qIFRhZ0NsYXNzICovOiByZXR1cm4gJ2NsYXNzJztcbiAgICAgICAgY2FzZSAxMTEgLyogVGFnT2JqZWN0ICovOiByZXR1cm4gJ09iamVjdCc7XG4gICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzogcmV0dXJuICdSZWZlcmVuY2UnO1xuICAgICAgICBjYXNlIDY5IC8qIFRhZ0Vycm9yICovOiByZXR1cm4gJ0Vycm9yJztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIFRhZzogMHgnICsgKHRhZyAmIDB4RkYpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxufVxudmFyIEJhc2VEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZURlc2VyaWFsaXplcih0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9ICd1bmRlZmluZWQnOyB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIEJhc2VEZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTEwIC8qIFRhZ051bGwgKi86IHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDExNCAvKiBUYWdSZWYgKi86IHJldHVybiByZWFkZXIucmVhZFJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgY2FzZSA5OSAvKiBUYWdDbGFzcyAqLzpcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZENsYXNzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgNjkgLyogVGFnRXJyb3IgKi86XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRlci5kZXNlcmlhbGl6ZShTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICcgKyB0YWdUb1N0cmluZyh0YWcpICsgJyB0byAnICsgdGhpcy50eXBlICsgJy4nKTtcbiAgICB9O1xuICAgIEJhc2VEZXNlcmlhbGl6ZXIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHJlYWRlciwgcmVhZGVyLnN0cmVhbS5yZWFkQnl0ZSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlRGVzZXJpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuQmFzZURlc2VyaWFsaXplciA9IEJhc2VEZXNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlRGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQmlnSW50QXJyYXlEZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBiaWdpbnQgQXJyYXkgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZURlc2VyaWFsaXplclwiKTtcbnZhciBEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9EZXNlcmlhbGl6ZXJcIik7XG52YXIgVmFsdWVSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1ZhbHVlUmVhZGVyXCIpKTtcbmZ1bmN0aW9uIHJlYWRCaWdJbnRBcnJheShyZWFkZXIsIHR5cGUpIHtcbiAgICB2YXIgc3RyZWFtID0gcmVhZGVyLnN0cmVhbTtcbiAgICB2YXIgY291bnQgPSBWYWx1ZVJlYWRlci5yZWFkQ291bnQoc3RyZWFtKTtcbiAgICB2YXIgYSA9IG5ldyB0eXBlKGNvdW50KTtcbiAgICByZWFkZXIuYWRkUmVmZXJlbmNlKGEpO1xuICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBEZXNlcmlhbGl6ZXJfMS5nZXRJbnN0YW5jZShCaWdJbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBhW2ldID0gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlYWRlcik7XG4gICAgfVxuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiBhO1xufVxuaWYgKHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBlbXB0eV8xID0gbmV3IEJpZ0ludDY0QXJyYXkoMCk7XG4gICAgdmFyIEJpZ0ludDY0QXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCaWdJbnQ2NEFycmF5RGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCaWdJbnQ2NEFycmF5RGVzZXJpYWxpemVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdCaWdJbnQ2NEFycmF5JykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBCaWdJbnQ2NEFycmF5RGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gZW1wdHlfMTtcbiAgICAgICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkQmlnSW50QXJyYXkocmVhZGVyLCBCaWdJbnQ2NEFycmF5KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCaWdJbnQ2NEFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IEJpZ0ludDY0QXJyYXlEZXNlcmlhbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXlEZXNlcmlhbGl6ZXI7XG4gICAgfShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuICAgIERlc2VyaWFsaXplcl8xLnJlZ2lzdGVyKEJpZ0ludDY0QXJyYXksIEJpZ0ludDY0QXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2UpO1xufVxuaWYgKHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgZW1wdHlfMiA9IG5ldyBCaWdVaW50NjRBcnJheSgwKTtcbiAgICB2YXIgQmlnVWludDY0QXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCaWdVaW50NjRBcnJheURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmlnVWludDY0QXJyYXlEZXNlcmlhbGl6ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0JpZ1VpbnQ2NEFycmF5JykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBCaWdVaW50NjRBcnJheURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIGVtcHR5XzI7XG4gICAgICAgICAgICAgICAgY2FzZSA5NyAvKiBUYWdMaXN0ICovOiByZXR1cm4gcmVhZEJpZ0ludEFycmF5KHJlYWRlciwgQmlnVWludDY0QXJyYXkpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJpZ1VpbnQ2NEFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IEJpZ1VpbnQ2NEFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBCaWdVaW50NjRBcnJheURlc2VyaWFsaXplcjtcbiAgICB9KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG4gICAgRGVzZXJpYWxpemVyXzEucmVnaXN0ZXIoQmlnVWludDY0QXJyYXksIEJpZ1VpbnQ2NEFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZ0ludEFycmF5RGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQmlnSW50RGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBiaWdpbnQgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IE1hciAyOSwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZURlc2VyaWFsaXplclwiKTtcbnZhciBEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9EZXNlcmlhbGl6ZXJcIik7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xuaWYgKHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIEJpZ0ludERlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJpZ0ludERlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmlnSW50RGVzZXJpYWxpemVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdiaWdpbnQnKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIEJpZ0ludERlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICAgICAgaWYgKHRhZyA+PSAweDMwICYmIHRhZyA8PSAweDM5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh0YWcgLSAweDMwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEwNSAvKiBUYWdJbnRlZ2VyICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTA4IC8qIFRhZ0xvbmcgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMDAgLyogVGFnRG91YmxlICovOiByZXR1cm4gQmlnSW50KHN0cmVhbS5yZWFkVW50aWwoNTkgLyogVGFnU2VtaWNvbG9uICovKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTYgLyogVGFnVHJ1ZSAqLzogcmV0dXJuIEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwMiAvKiBUYWdGYWxzZSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBCaWdJbnQoUmVmZXJlbmNlUmVhZGVyLnJlYWRTdHJpbmcocmVhZGVyKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTcgLyogVGFnVVRGOENoYXIgKi86IHJldHVybiBCaWdJbnQoc3RyZWFtLnJlYWRTdHJpbmcoMSkuY2hhckNvZGVBdCgxKSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2OCAvKiBUYWdEYXRlICovOiByZXR1cm4gQmlnSW50KFJlZmVyZW5jZVJlYWRlci5yZWFkRGF0ZVRpbWUocmVhZGVyKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgODQgLyogVGFnVGltZSAqLzogcmV0dXJuIEJpZ0ludChSZWZlcmVuY2VSZWFkZXIucmVhZFRpbWUocmVhZGVyKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVhZGVyLnJlYWRSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0LmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCaWdJbnREZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgQmlnSW50RGVzZXJpYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBCaWdJbnREZXNlcmlhbGl6ZXI7XG4gICAgfShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuICAgIERlc2VyaWFsaXplcl8xLnJlZ2lzdGVyKEJpZ0ludCwgQmlnSW50RGVzZXJpYWxpemVyLmluc3RhbmNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZ0ludERlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEJvb2xlYW5EZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgYm9vbGVhbiBkZXNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgVmFsdWVSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1ZhbHVlUmVhZGVyXCIpKTtcbnZhciBSZWZlcmVuY2VSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1JlZmVyZW5jZVJlYWRlclwiKSk7XG52YXIgQm9vbGVhbkRlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9vbGVhbkRlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb29sZWFuRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ2Jvb2xlYW4nKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCb29sZWFuRGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMTYgLyogVGFnVHJ1ZSAqLzogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDEwMiAvKiBUYWdGYWxzZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOlxuICAgICAgICAgICAgY2FzZSA3OCAvKiBUYWdOYU4gKi86XG4gICAgICAgICAgICBjYXNlIDB4MzA6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTA1IC8qIFRhZ0ludGVnZXIgKi86XG4gICAgICAgICAgICBjYXNlIDEwOCAvKiBUYWdMb25nICovOiByZXR1cm4gVmFsdWVSZWFkZXIucmVhZEludChzdHJlYW0pICE9PSAwO1xuICAgICAgICAgICAgY2FzZSAxMDAgLyogVGFnRG91YmxlICovOiByZXR1cm4gVmFsdWVSZWFkZXIucmVhZERvdWJsZShzdHJlYW0pICE9PSAwO1xuICAgICAgICAgICAgY2FzZSAxMTUgLyogVGFnU3RyaW5nICovOiByZXR1cm4gQm9vbGVhbihSZWZlcmVuY2VSZWFkZXIucmVhZFN0cmluZyhyZWFkZXIpKTtcbiAgICAgICAgICAgIGNhc2UgMTE3IC8qIFRhZ1VURjhDaGFyICovOiByZXR1cm4gJzBcXDAnLmluZGV4T2Yoc3RyZWFtLnJlYWRTdHJpbmcoMSkpID09PSAtMTtcbiAgICAgICAgICAgIGNhc2UgNzMgLyogVGFnSW5maW5pdHkgKi86XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDExNCAvKiBUYWdSZWYgKi86IHJldHVybiBCb29sZWFuKHJlYWRlci5yZWFkUmVmZXJlbmNlKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0YWcgPj0gMHgzMSAmJiB0YWcgPD0gMHgzOSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQm9vbGVhbkRlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBCb29sZWFuRGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEJvb2xlYW5EZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkJvb2xlYW5EZXNlcmlhbGl6ZXIgPSBCb29sZWFuRGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhbkRlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEJ5dGVTdHJlYW1EZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgQnl0ZVN0cmVhbSBkZXNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ5dGVTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9CeXRlU3RyZWFtXCIpO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgVHlwZWRBcnJheURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vVHlwZWRBcnJheURlc2VyaWFsaXplclwiKTtcbnZhciBSZWZlcmVuY2VSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIik7XG52YXIgQnl0ZVN0cmVhbURlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnl0ZVN0cmVhbURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCeXRlU3RyZWFtRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0J5dGVTdHJlYW0nKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCeXRlU3RyZWFtRGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDk4IC8qIFRhZ0J5dGVzICovOiByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKFJlZmVyZW5jZVJlYWRlcl8xLnJlYWRCeXRlcyhyZWFkZXIpKTtcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKDApO1xuICAgICAgICAgICAgY2FzZSA5NyAvKiBUYWdMaXN0ICovOiByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKFR5cGVkQXJyYXlEZXNlcmlhbGl6ZXJfMS5yZWFkSW50QXJyYXkocmVhZGVyLCBVaW50OEFycmF5KSk7XG4gICAgICAgICAgICBjYXNlIDExNyAvKiBUYWdVVEY4Q2hhciAqLzogcmV0dXJuIG5ldyBCeXRlU3RyZWFtXzEuQnl0ZVN0cmVhbShyZWFkZXIuc3RyZWFtLnJlYWRTdHJpbmcoMSkpO1xuICAgICAgICAgICAgY2FzZSAxMTUgLyogVGFnU3RyaW5nICovOiByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKFJlZmVyZW5jZVJlYWRlcl8xLnJlYWRTdHJpbmcocmVhZGVyKSk7XG4gICAgICAgICAgICBjYXNlIDExNCAvKiBUYWdSZWYgKi86IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVhZGVyLnJlYWRSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ5dGVTdHJlYW1EZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgQnl0ZVN0cmVhbURlc2VyaWFsaXplcigpO1xuICAgIHJldHVybiBCeXRlU3RyZWFtRGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5CeXRlU3RyZWFtRGVzZXJpYWxpemVyID0gQnl0ZVN0cmVhbURlc2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVTdHJlYW1EZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBEYXRlRGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGRhdGUgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI5LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9CYXNlRGVzZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9WYWx1ZVJlYWRlclwiKSk7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xudmFyIERhdGVEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGVEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdEYXRlJykgfHwgdGhpcztcbiAgICB9XG4gICAgRGF0ZURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICB2YXIgc3RyZWFtID0gcmVhZGVyLnN0cmVhbTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgNjggLyogVGFnRGF0ZSAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkRGF0ZVRpbWUocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgODQgLyogVGFnVGltZSAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkVGltZShyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSAxMDUgLyogVGFnSW50ZWdlciAqLzogcmV0dXJuIG5ldyBEYXRlKFZhbHVlUmVhZGVyLnJlYWRJbnQoc3RyZWFtKSk7XG4gICAgICAgICAgICBjYXNlIDEwOCAvKiBUYWdMb25nICovOiByZXR1cm4gbmV3IERhdGUoVmFsdWVSZWFkZXIucmVhZEludChzdHJlYW0pKTtcbiAgICAgICAgICAgIGNhc2UgMTAwIC8qIFRhZ0RvdWJsZSAqLzogcmV0dXJuIG5ldyBEYXRlKE1hdGguZmxvb3IoVmFsdWVSZWFkZXIucmVhZERvdWJsZShzdHJlYW0pKSk7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBuZXcgRGF0ZShSZWZlcmVuY2VSZWFkZXIucmVhZFN0cmluZyhyZWFkZXIpKTtcbiAgICAgICAgICAgIGNhc2UgMTE2IC8qIFRhZ1RydWUgKi86IHJldHVybiBuZXcgRGF0ZSgxKTtcbiAgICAgICAgICAgIGNhc2UgMTAyIC8qIFRhZ0ZhbHNlICovOlxuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBuZXcgRGF0ZSgwKTtcbiAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzoge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkZXIucmVhZFJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA+PSAweDMwICYmIHRhZyA8PSAweDM5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0YWcgLSAweDMwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0ZURlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBEYXRlRGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIERhdGVEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkRhdGVEZXNlcmlhbGl6ZXIgPSBEYXRlRGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZURlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IERlZmF1bHREZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgRGVmYXVsdERlc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBGZWIgOCwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgU3RyaW5nRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdEZXNlcmlhbGl6ZXJcIik7XG52YXIgVmFsdWVSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1ZhbHVlUmVhZGVyXCIpKTtcbnZhciBSZWZlcmVuY2VSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1JlZmVyZW5jZVJlYWRlclwiKSk7XG52YXIgRGVmYXVsdERlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdERlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0RGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ2FueScpIHx8IHRoaXM7XG4gICAgfVxuICAgIERlZmF1bHREZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgaWYgKHRhZyA+PSAweDMwICYmIHRhZyA8PSAweDM5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnIC0gMHgzMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtID0gcmVhZGVyLnN0cmVhbTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTA1IC8qIFRhZ0ludGVnZXIgKi86IHJldHVybiBWYWx1ZVJlYWRlci5yZWFkSW50KHN0cmVhbSk7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZFN0cmluZyhyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSA5OCAvKiBUYWdCeXRlcyAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkQnl0ZXMocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgMTE2IC8qIFRhZ1RydWUgKi86IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAxMDIgLyogVGFnRmFsc2UgKi86IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIDExMSAvKiBUYWdPYmplY3QgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZE9iamVjdChyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSA2OCAvKiBUYWdEYXRlICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWREYXRlVGltZShyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSA4NCAvKiBUYWdUaW1lICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWRUaW1lKHJlYWRlcik7XG4gICAgICAgICAgICBjYXNlIDEwMyAvKiBUYWdHdWlkICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWRHdWlkKHJlYWRlcik7XG4gICAgICAgICAgICBjYXNlIDEwOCAvKiBUYWdMb25nICovOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVhZGVyLmxvbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsdWVSZWFkZXIucmVhZEludChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChzdHJlYW0ucmVhZFVudGlsKDU5IC8qIFRhZ1NlbWljb2xvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3dpdGNoLWNhc2UtZmFsbC10aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtLnJlYWRVbnRpbCg1OSAvKiBUYWdTZW1pY29sb24gKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAwIC8qIFRhZ0RvdWJsZSAqLzogcmV0dXJuIFZhbHVlUmVhZGVyLnJlYWREb3VibGUoc3RyZWFtKTtcbiAgICAgICAgICAgIGNhc2UgNzggLyogVGFnTmFOICovOiByZXR1cm4gTmFOO1xuICAgICAgICAgICAgY2FzZSA3MyAvKiBUYWdJbmZpbml0eSAqLzogcmV0dXJuIFZhbHVlUmVhZGVyLnJlYWRJbmZpbml0eShzdHJlYW0pO1xuICAgICAgICAgICAgY2FzZSAxMTcgLyogVGFnVVRGOENoYXIgKi86IHJldHVybiBzdHJlYW0ucmVhZFN0cmluZygxKTtcbiAgICAgICAgICAgIGNhc2UgOTcgLyogVGFnTGlzdCAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkQXJyYXkocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgMTA5IC8qIFRhZ01hcCAqLzogcmV0dXJuIChyZWFkZXIuZGljdFR5cGUgPT09ICdtYXAnKSA/IFJlZmVyZW5jZVJlYWRlci5yZWFkTWFwKHJlYWRlcikgOiByZWFkRGljdChyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSA2OSAvKiBUYWdFcnJvciAqLzogcmV0dXJuIG5ldyBFcnJvcihyZWFkZXIuZGVzZXJpYWxpemUoU3RyaW5nKSk7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IERlZmF1bHREZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gRGVmYXVsdERlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuRGVmYXVsdERlc2VyaWFsaXplciA9IERlZmF1bHREZXNlcmlhbGl6ZXI7XG5mdW5jdGlvbiByZWFkRGljdChyZWFkZXIpIHtcbiAgICB2YXIgc3RyZWFtID0gcmVhZGVyLnN0cmVhbTtcbiAgICB2YXIgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShkaWN0KTtcbiAgICB2YXIgY291bnQgPSBWYWx1ZVJlYWRlci5yZWFkQ291bnQoc3RyZWFtKTtcbiAgICB2YXIgc3RyRGVzZXJpYWxpemVyID0gU3RyaW5nRGVzZXJpYWxpemVyXzEuU3RyaW5nRGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBEZWZhdWx0RGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgIGZvciAoOyBjb3VudCA+IDA7IC0tY291bnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHN0ckRlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZWFkZXIpO1xuICAgICAgICB2YXIgdmFsdWUgPSBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICAgICAgZGljdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiBkaWN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdERlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEVycm9yRGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgRXJyb3IgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBGZWIgOCwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgRXJyb3JEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9yRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0Vycm9yJykgfHwgdGhpcztcbiAgICB9XG4gICAgRXJyb3JEZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgNjkgLyogVGFnRXJyb3IgKi86IHJldHVybiBuZXcgRXJyb3IocmVhZGVyLmRlc2VyaWFsaXplKFN0cmluZykpO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXJyb3JEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgRXJyb3JEZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gRXJyb3JEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkVycm9yRGVzZXJpYWxpemVyID0gRXJyb3JEZXNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvckRlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEZ1bmN0aW9uRGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgZnVuY3Rpb24gZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBKYW4gNiwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgRnVuY3Rpb25EZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ2Z1bmN0aW9uJykgfHwgdGhpcztcbiAgICB9XG4gICAgRnVuY3Rpb25EZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgRnVuY3Rpb25EZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gRnVuY3Rpb25EZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkZ1bmN0aW9uRGVzZXJpYWxpemVyID0gRnVuY3Rpb25EZXNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbkRlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEd1aWREZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgR3VpZCBkZXNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xudmFyIGd1aWRfdHlwZXNjcmlwdF8xID0gcmVxdWlyZShcImd1aWQtdHlwZXNjcmlwdFwiKTtcbnZhciBHdWlkRGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHdWlkRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEd1aWREZXNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnR3VpZCcpIHx8IHRoaXM7XG4gICAgfVxuICAgIEd1aWREZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTAzIC8qIFRhZ0d1aWQgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZEd1aWQocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgMTE1IC8qIFRhZ1N0cmluZyAqLzogcmV0dXJuIGd1aWRfdHlwZXNjcmlwdF8xLkd1aWQucGFyc2UoUmVmZXJlbmNlUmVhZGVyLnJlYWRTdHJpbmcocmVhZGVyKSk7XG4gICAgICAgICAgICBjYXNlIDExNCAvKiBUYWdSZWYgKi86IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVhZGVyLnJlYWRSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgZ3VpZF90eXBlc2NyaXB0XzEuR3VpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1aWRfdHlwZXNjcmlwdF8xLkd1aWQucGFyc2UocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEd1aWREZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgR3VpZERlc2VyaWFsaXplcigpO1xuICAgIHJldHVybiBHdWlkRGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5HdWlkRGVzZXJpYWxpemVyID0gR3VpZERlc2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUd1aWREZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBJbnREZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGludCBkZXNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI5LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9CYXNlRGVzZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9WYWx1ZVJlYWRlclwiKSk7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xudmFyIEludERlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50RGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludERlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdpbnQnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbnREZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgaWYgKHRhZyA+PSAweDMwICYmIHRhZyA8PSAweDM5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnIC0gMHgzMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtID0gcmVhZGVyLnN0cmVhbTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTA1IC8qIFRhZ0ludGVnZXIgKi86XG4gICAgICAgICAgICBjYXNlIDEwOCAvKiBUYWdMb25nICovOiByZXR1cm4gVmFsdWVSZWFkZXIucmVhZEludChzdHJlYW0pO1xuICAgICAgICAgICAgY2FzZSAxMDAgLyogVGFnRG91YmxlICovOiByZXR1cm4gTWF0aC5mbG9vcihWYWx1ZVJlYWRlci5yZWFkRG91YmxlKHN0cmVhbSkpO1xuICAgICAgICAgICAgY2FzZSAxMTYgLyogVGFnVHJ1ZSAqLzogcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDEwMiAvKiBUYWdGYWxzZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMTE1IC8qIFRhZ1N0cmluZyAqLzogcmV0dXJuIHBhcnNlSW50KFJlZmVyZW5jZVJlYWRlci5yZWFkU3RyaW5nKHJlYWRlcikpO1xuICAgICAgICAgICAgY2FzZSAxMTcgLyogVGFnVVRGOENoYXIgKi86IHJldHVybiBzdHJlYW0ucmVhZFN0cmluZygxKS5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgY2FzZSA2OCAvKiBUYWdEYXRlICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWREYXRlVGltZShyZWFkZXIpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNhc2UgODQgLyogVGFnVGltZSAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkVGltZShyZWFkZXIpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzoge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkZXIucmVhZFJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnREZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgSW50RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEludERlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuSW50RGVzZXJpYWxpemVyID0gSW50RGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50RGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTWFwRGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBNYXAgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZURlc2VyaWFsaXplclwiKTtcbnZhciBSZWZlcmVuY2VSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1JlZmVyZW5jZVJlYWRlclwiKSk7XG52YXIgTWFwRGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ01hcCcpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1hcERlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjYXNlIDEwOSAvKiBUYWdNYXAgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZE1hcChyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSAxMTEgLyogVGFnT2JqZWN0ICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWRPYmplY3RBc01hcChyZWFkZXIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXBEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgTWFwRGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIE1hcERlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuTWFwRGVzZXJpYWxpemVyID0gTWFwRGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwRGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTnVsbERlc2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBudWxsIGRlc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiA2LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVmYXVsdERlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vRGVmYXVsdERlc2VyaWFsaXplclwiKTtcbnZhciBOdWxsRGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxEZXNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTnVsbERlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBpZiAodGFnID09PSAxMTAgLyogVGFnTnVsbCAqLylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgIH07XG4gICAgTnVsbERlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBOdWxsRGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIE51bGxEZXNlcmlhbGl6ZXI7XG59KERlZmF1bHREZXNlcmlhbGl6ZXJfMS5EZWZhdWx0RGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLk51bGxEZXNlcmlhbGl6ZXIgPSBOdWxsRGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVsbERlc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE51bWJlckRlc2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgbnVtYmVyIGRlc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VEZXNlcmlhbGl6ZXJcIik7XG52YXIgVmFsdWVSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1ZhbHVlUmVhZGVyXCIpKTtcbnZhciBSZWZlcmVuY2VSZWFkZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL1JlZmVyZW5jZVJlYWRlclwiKSk7XG52YXIgTnVtYmVyRGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdW1iZXJEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyRGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ251bWJlcicpIHx8IHRoaXM7XG4gICAgfVxuICAgIE51bWJlckRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBpZiAodGFnID49IDB4MzAgJiYgdGFnIDw9IDB4MzkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgLSAweDMwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDUgLyogVGFnSW50ZWdlciAqLzpcbiAgICAgICAgICAgIGNhc2UgMTA4IC8qIFRhZ0xvbmcgKi86IHJldHVybiBWYWx1ZVJlYWRlci5yZWFkSW50KHN0cmVhbSk7XG4gICAgICAgICAgICBjYXNlIDEwMCAvKiBUYWdEb3VibGUgKi86IHJldHVybiBWYWx1ZVJlYWRlci5yZWFkRG91YmxlKHN0cmVhbSk7XG4gICAgICAgICAgICBjYXNlIDc4IC8qIFRhZ05hTiAqLzogcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGNhc2UgNzMgLyogVGFnSW5maW5pdHkgKi86IHJldHVybiBWYWx1ZVJlYWRlci5yZWFkSW5maW5pdHkoc3RyZWFtKTtcbiAgICAgICAgICAgIGNhc2UgMTE2IC8qIFRhZ1RydWUgKi86IHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAxMDIgLyogVGFnRmFsc2UgKi86XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBOdW1iZXIoUmVmZXJlbmNlUmVhZGVyLnJlYWRTdHJpbmcocmVhZGVyKSk7XG4gICAgICAgICAgICBjYXNlIDExNyAvKiBUYWdVVEY4Q2hhciAqLzogcmV0dXJuIHN0cmVhbS5yZWFkU3RyaW5nKDEpLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgICAgICBjYXNlIDY4IC8qIFRhZ0RhdGUgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZERhdGVUaW1lKHJlYWRlcikuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY2FzZSA4NCAvKiBUYWdUaW1lICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWRUaW1lKHJlYWRlcikuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY2FzZSAxMTQgLyogVGFnUmVmICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYWRlci5yZWFkUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOdW1iZXJEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgTnVtYmVyRGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIE51bWJlckRlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuTnVtYmVyRGVzZXJpYWxpemVyID0gTnVtYmVyRGVzZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVtYmVyRGVzZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU2V0RGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBTZXQgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZURlc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZURlc2VyaWFsaXplclwiKTtcbnZhciBSZWZlcmVuY2VSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIik7XG52YXIgU2V0RGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXREZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2V0RGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ1NldCcpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNldERlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXJfMS5yZWFkU2V0KHJlYWRlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNldERlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBTZXREZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gU2V0RGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5TZXREZXNlcmlhbGl6ZXIgPSBTZXREZXNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXREZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTdHJpbmdEZXNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHN0cmluZyBkZXNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI5LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9CYXNlRGVzZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9WYWx1ZVJlYWRlclwiKSk7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9SZWZlcmVuY2VSZWFkZXJcIikpO1xudmFyIFN0cmluZ0Rlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyaW5nRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmluZ0Rlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdzdHJpbmcnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdHJpbmdEZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgaWYgKHRhZyA+PSAweDMwICYmIHRhZyA8PSAweDM5KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDUgLyogVGFnSW50ZWdlciAqLzpcbiAgICAgICAgICAgIGNhc2UgMTA4IC8qIFRhZ0xvbmcgKi86XG4gICAgICAgICAgICBjYXNlIDEwMCAvKiBUYWdEb3VibGUgKi86IHJldHVybiBzdHJlYW0ucmVhZFVudGlsKDU5IC8qIFRhZ1NlbWljb2xvbiAqLyk7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZFN0cmluZyhyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSA5OCAvKiBUYWdCeXRlcyAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkQXNjaWlTdHJpbmcocmVhZGVyKTtcbiAgICAgICAgICAgIGNhc2UgMTE2IC8qIFRhZ1RydWUgKi86IHJldHVybiAndHJ1ZSc7XG4gICAgICAgICAgICBjYXNlIDEwMiAvKiBUYWdGYWxzZSAqLzogcmV0dXJuICdmYWxzZSc7XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSA2OCAvKiBUYWdEYXRlICovOiByZXR1cm4gUmVmZXJlbmNlUmVhZGVyLnJlYWREYXRlVGltZShyZWFkZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDg0IC8qIFRhZ1RpbWUgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZFRpbWUocmVhZGVyKS50b1RpbWVTdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgMTAzIC8qIFRhZ0d1aWQgKi86IHJldHVybiBSZWZlcmVuY2VSZWFkZXIucmVhZEd1aWQocmVhZGVyKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSA3OCAvKiBUYWdOYU4gKi86IHJldHVybiAnTmFOJztcbiAgICAgICAgICAgIGNhc2UgNzMgLyogVGFnSW5maW5pdHkgKi86IHJldHVybiBWYWx1ZVJlYWRlci5yZWFkSW5maW5pdHkoc3RyZWFtKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAxMTcgLyogVGFnVVRGOENoYXIgKi86IHJldHVybiBzdHJlYW0ucmVhZFN0cmluZygxKTtcbiAgICAgICAgICAgIGNhc2UgOTcgLyogVGFnTGlzdCAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlci5yZWFkQXJyYXkocmVhZGVyKS5qb2luKCcnKTtcbiAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzogcmV0dXJuIHJlYWRlci5yZWFkUmVmZXJlbmNlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmluZ0Rlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBTdHJpbmdEZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gU3RyaW5nRGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5TdHJpbmdEZXNlcmlhbGl6ZXIgPSBTdHJpbmdEZXNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdEZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBUeXBlZEFycmF5RGVzZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIFR5cGVkQXJyYXkgZGVzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI5LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCeXRlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vQnl0ZVN0cmVhbVwiKTtcbnZhciBJbnREZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0ludERlc2VyaWFsaXplclwiKTtcbnZhciBOdW1iZXJEZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL051bWJlckRlc2VyaWFsaXplclwiKTtcbnZhciBCYXNlRGVzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9CYXNlRGVzZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVSZWFkZXJcIik7XG52YXIgUmVmZXJlbmNlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vUmVmZXJlbmNlUmVhZGVyXCIpO1xuZnVuY3Rpb24gcmVhZEludEFycmF5KHJlYWRlciwgdHlwZSkge1xuICAgIHZhciBzdHJlYW0gPSByZWFkZXIuc3RyZWFtO1xuICAgIHZhciBjb3VudCA9IFZhbHVlUmVhZGVyXzEucmVhZENvdW50KHN0cmVhbSk7XG4gICAgdmFyIGEgPSBuZXcgdHlwZShjb3VudCk7XG4gICAgcmVhZGVyLmFkZFJlZmVyZW5jZShhKTtcbiAgICB2YXIgZGVzZXJpYWxpemVyID0gSW50RGVzZXJpYWxpemVyXzEuSW50RGVzZXJpYWxpemVyLmluc3RhbmNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBhW2ldID0gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlYWRlcik7XG4gICAgfVxuICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5yZWFkSW50QXJyYXkgPSByZWFkSW50QXJyYXk7XG5mdW5jdGlvbiByZWFkTnVtYmVyQXJyYXkocmVhZGVyLCB0eXBlKSB7XG4gICAgdmFyIHN0cmVhbSA9IHJlYWRlci5zdHJlYW07XG4gICAgdmFyIGNvdW50ID0gVmFsdWVSZWFkZXJfMS5yZWFkQ291bnQoc3RyZWFtKTtcbiAgICB2YXIgYSA9IG5ldyB0eXBlKGNvdW50KTtcbiAgICByZWFkZXIuYWRkUmVmZXJlbmNlKGEpO1xuICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBOdW1iZXJEZXNlcmlhbGl6ZXJfMS5OdW1iZXJEZXNlcmlhbGl6ZXIuaW5zdGFuY2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGFbaV0gPSBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICB9XG4gICAgc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLnJlYWROdW1iZXJBcnJheSA9IHJlYWROdW1iZXJBcnJheTtcbnZhciBlbXB0eUludDhBcnJheSA9IG5ldyBJbnQ4QXJyYXkoMCk7XG52YXIgSW50OEFycmF5RGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnQ4QXJyYXlEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50OEFycmF5RGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ludDhBcnJheScpIHx8IHRoaXM7XG4gICAgfVxuICAgIEludDhBcnJheURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICB2YXIgYnl0ZXM7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIGVtcHR5SW50OEFycmF5O1xuICAgICAgICAgICAgY2FzZSA5NyAvKiBUYWdMaXN0ICovOiByZXR1cm4gcmVhZEludEFycmF5KHJlYWRlciwgSW50OEFycmF5KTtcbiAgICAgICAgICAgIGNhc2UgOTggLyogVGFnQnl0ZXMgKi86XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBSZWZlcmVuY2VSZWFkZXJfMS5yZWFkQnl0ZXMocmVhZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE3IC8qIFRhZ1VURjhDaGFyICovOlxuICAgICAgICAgICAgICAgIGJ5dGVzID0gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlYWRlci5zdHJlYW0ucmVhZFN0cmluZygxKSkuYnl0ZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBuZXcgQnl0ZVN0cmVhbV8xLkJ5dGVTdHJlYW0oUmVmZXJlbmNlUmVhZGVyXzEucmVhZFN0cmluZyhyZWFkZXIpKS5ieXRlcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBJbnQ4QXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgSW50OEFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEludDhBcnJheURlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuSW50OEFycmF5RGVzZXJpYWxpemVyID0gSW50OEFycmF5RGVzZXJpYWxpemVyO1xudmFyIGVtcHR5SW50MTZBcnJheSA9IG5ldyBJbnQxNkFycmF5KDApO1xudmFyIEludDE2QXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludDE2QXJyYXlEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50MTZBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdJbnQxNkFycmF5JykgfHwgdGhpcztcbiAgICB9XG4gICAgSW50MTZBcnJheURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBlbXB0eUludDE2QXJyYXk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkSW50QXJyYXkocmVhZGVyLCBJbnQxNkFycmF5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MTZBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBJbnQxNkFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEludDE2QXJyYXlEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkludDE2QXJyYXlEZXNlcmlhbGl6ZXIgPSBJbnQxNkFycmF5RGVzZXJpYWxpemVyO1xudmFyIGVtcHR5SW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KDApO1xudmFyIEludDMyQXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludDMyQXJyYXlEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50MzJBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdJbnQzMkFycmF5JykgfHwgdGhpcztcbiAgICB9XG4gICAgSW50MzJBcnJheURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBlbXB0eUludDMyQXJyYXk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkSW50QXJyYXkocmVhZGVyLCBJbnQzMkFycmF5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MzJBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBJbnQzMkFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEludDMyQXJyYXlEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkludDMyQXJyYXlEZXNlcmlhbGl6ZXIgPSBJbnQzMkFycmF5RGVzZXJpYWxpemVyO1xudmFyIGVtcHR5VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDApO1xudmFyIFVpbnQ4QXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVpbnQ4QXJyYXlEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVWludDhBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdVaW50OEFycmF5JykgfHwgdGhpcztcbiAgICB9XG4gICAgVWludDhBcnJheURlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChyZWFkZXIsIHRhZykge1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSA5OCAvKiBUYWdCeXRlcyAqLzogcmV0dXJuIFJlZmVyZW5jZVJlYWRlcl8xLnJlYWRCeXRlcyhyZWFkZXIpO1xuICAgICAgICAgICAgY2FzZSAxMDEgLyogVGFnRW1wdHkgKi86IHJldHVybiBlbXB0eVVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkSW50QXJyYXkocmVhZGVyLCBVaW50OEFycmF5KTtcbiAgICAgICAgICAgIGNhc2UgMTE3IC8qIFRhZ1VURjhDaGFyICovOiByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlYWRlci5zdHJlYW0ucmVhZFN0cmluZygxKSkuYnl0ZXM7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86IHJldHVybiBuZXcgQnl0ZVN0cmVhbV8xLkJ5dGVTdHJlYW0oUmVmZXJlbmNlUmVhZGVyXzEucmVhZFN0cmluZyhyZWFkZXIpKS5ieXRlcztcbiAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzoge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkZXIucmVhZFJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlc3VsdC50b1N0cmluZygpKS5ieXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVpbnQ4QXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgVWludDhBcnJheURlc2VyaWFsaXplcigpO1xuICAgIHJldHVybiBVaW50OEFycmF5RGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5VaW50OEFycmF5RGVzZXJpYWxpemVyID0gVWludDhBcnJheURlc2VyaWFsaXplcjtcbnZhciBlbXB0eVVpbnQ4Q2xhbXBlZEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDApO1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5RGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdVaW50OENsYW1wZWRBcnJheScpIHx8IHRoaXM7XG4gICAgfVxuICAgIFVpbnQ4Q2xhbXBlZEFycmF5RGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHZhciBieXRlcztcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gZW1wdHlVaW50OENsYW1wZWRBcnJheTtcbiAgICAgICAgICAgIGNhc2UgOTcgLyogVGFnTGlzdCAqLzogcmV0dXJuIHJlYWRJbnRBcnJheShyZWFkZXIsIFVpbnQ4Q2xhbXBlZEFycmF5KTtcbiAgICAgICAgICAgIGNhc2UgOTggLyogVGFnQnl0ZXMgKi86XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBSZWZlcmVuY2VSZWFkZXJfMS5yZWFkQnl0ZXMocmVhZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE3IC8qIFRhZ1VURjhDaGFyICovOlxuICAgICAgICAgICAgICAgIGJ5dGVzID0gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlYWRlci5zdHJlYW0ucmVhZFN0cmluZygxKSkuYnl0ZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDExNSAvKiBUYWdTdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBuZXcgQnl0ZVN0cmVhbV8xLkJ5dGVTdHJlYW0oUmVmZXJlbmNlUmVhZGVyXzEucmVhZFN0cmluZyhyZWFkZXIpKS5ieXRlcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE0IC8qIFRhZ1JlZiAqLzoge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkZXIucmVhZFJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gbmV3IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtKHJlc3VsdC50b1N0cmluZygpKS5ieXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplci5pbnN0YW5jZSA9IG5ldyBVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplcigpO1xuICAgIHJldHVybiBVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuVWludDhDbGFtcGVkQXJyYXlEZXNlcmlhbGl6ZXIgPSBVaW50OENsYW1wZWRBcnJheURlc2VyaWFsaXplcjtcbnZhciBlbXB0eVVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDApO1xudmFyIFVpbnQxNkFycmF5RGVzZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVaW50MTZBcnJheURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVaW50MTZBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdVaW50MTZBcnJheScpIHx8IHRoaXM7XG4gICAgfVxuICAgIFVpbnQxNkFycmF5RGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIGVtcHR5VWludDE2QXJyYXk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkSW50QXJyYXkocmVhZGVyLCBVaW50MTZBcnJheSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCByZWFkZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVpbnQxNkFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IFVpbnQxNkFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIFVpbnQxNkFycmF5RGVzZXJpYWxpemVyO1xufShCYXNlRGVzZXJpYWxpemVyXzEuQmFzZURlc2VyaWFsaXplcikpO1xuZXhwb3J0cy5VaW50MTZBcnJheURlc2VyaWFsaXplciA9IFVpbnQxNkFycmF5RGVzZXJpYWxpemVyO1xudmFyIGVtcHR5VWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG52YXIgVWludDMyQXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVpbnQzMkFycmF5RGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVpbnQzMkFycmF5RGVzZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ1VpbnQzMkFycmF5JykgfHwgdGhpcztcbiAgICB9XG4gICAgVWludDMyQXJyYXlEZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gZW1wdHlVaW50MzJBcnJheTtcbiAgICAgICAgICAgIGNhc2UgOTcgLyogVGFnTGlzdCAqLzogcmV0dXJuIHJlYWRJbnRBcnJheShyZWFkZXIsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVWludDMyQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgVWludDMyQXJyYXlEZXNlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gVWludDMyQXJyYXlEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLlVpbnQzMkFycmF5RGVzZXJpYWxpemVyID0gVWludDMyQXJyYXlEZXNlcmlhbGl6ZXI7XG52YXIgZW1wdHlGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDApO1xudmFyIEZsb2F0MzJBcnJheURlc2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvYXQzMkFycmF5RGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZsb2F0MzJBcnJheURlc2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdGbG9hdDMyQXJyYXknKSB8fCB0aGlzO1xuICAgIH1cbiAgICBGbG9hdDMyQXJyYXlEZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVhZGVyLCB0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTAxIC8qIFRhZ0VtcHR5ICovOiByZXR1cm4gZW1wdHlGbG9hdDMyQXJyYXk7XG4gICAgICAgICAgICBjYXNlIDk3IC8qIFRhZ0xpc3QgKi86IHJldHVybiByZWFkTnVtYmVyQXJyYXkocmVhZGVyLCBGbG9hdDMyQXJyYXkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWFkLmNhbGwodGhpcywgcmVhZGVyLCB0YWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGbG9hdDMyQXJyYXlEZXNlcmlhbGl6ZXIuaW5zdGFuY2UgPSBuZXcgRmxvYXQzMkFycmF5RGVzZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheURlc2VyaWFsaXplcjtcbn0oQmFzZURlc2VyaWFsaXplcl8xLkJhc2VEZXNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuRmxvYXQzMkFycmF5RGVzZXJpYWxpemVyID0gRmxvYXQzMkFycmF5RGVzZXJpYWxpemVyO1xudmFyIGVtcHR5RmxvYXQ2NEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSgwKTtcbnZhciBGbG9hdDY0QXJyYXlEZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb2F0NjRBcnJheURlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGbG9hdDY0QXJyYXlEZXNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnRmxvYXQ2NEFycmF5JykgfHwgdGhpcztcbiAgICB9XG4gICAgRmxvYXQ2NEFycmF5RGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlYWRlciwgdGFnKSB7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDEwMSAvKiBUYWdFbXB0eSAqLzogcmV0dXJuIGVtcHR5RmxvYXQ2NEFycmF5O1xuICAgICAgICAgICAgY2FzZSA5NyAvKiBUYWdMaXN0ICovOiByZXR1cm4gcmVhZE51bWJlckFycmF5KHJlYWRlciwgRmxvYXQ2NEFycmF5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIHJlYWRlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmxvYXQ2NEFycmF5RGVzZXJpYWxpemVyLmluc3RhbmNlID0gbmV3IEZsb2F0NjRBcnJheURlc2VyaWFsaXplcigpO1xuICAgIHJldHVybiBGbG9hdDY0QXJyYXlEZXNlcmlhbGl6ZXI7XG59KEJhc2VEZXNlcmlhbGl6ZXJfMS5CYXNlRGVzZXJpYWxpemVyKSk7XG5leHBvcnRzLkZsb2F0NjRBcnJheURlc2VyaWFsaXplciA9IEZsb2F0NjRBcnJheURlc2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVkQXJyYXlEZXNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UuaW8udHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQGhwcm9zZS9pbyBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDIyLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnl0ZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vQnl0ZVN0cmVhbVwiKTtcbmV4cG9ydHMuQnl0ZVN0cmVhbSA9IEJ5dGVTdHJlYW1fMS5CeXRlU3RyZWFtO1xuZXhwb3J0cy53cml0ZUludDMyQkUgPSBCeXRlU3RyZWFtXzEud3JpdGVJbnQzMkJFO1xuZXhwb3J0cy53cml0ZUludDMyTEUgPSBCeXRlU3RyZWFtXzEud3JpdGVJbnQzMkxFO1xuZXhwb3J0cy5mcm9tVWludDhBcnJheSA9IEJ5dGVTdHJlYW1fMS5mcm9tVWludDhBcnJheTtcbmV4cG9ydHMudG9CaW5hcnlTdHJpbmcgPSBCeXRlU3RyZWFtXzEudG9CaW5hcnlTdHJpbmc7XG52YXIgV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9Xcml0ZXJcIik7XG5leHBvcnRzLldyaXRlciA9IFdyaXRlcl8xLldyaXRlcjtcbnZhciBSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL1JlYWRlclwiKTtcbmV4cG9ydHMuUmVhZGVyID0gUmVhZGVyXzEuUmVhZGVyO1xudmFyIFR5cGVNYW5hZ2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1R5cGVNYW5hZ2VyXCIpKTtcbmV4cG9ydHMuVHlwZU1hbmFnZXIgPSBUeXBlTWFuYWdlcjtcbnZhciBTZXJpYWxpemVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1NlcmlhbGl6ZXJcIikpO1xuZXhwb3J0cy5TZXJpYWxpemVyID0gU2VyaWFsaXplcjtcbnZhciBEZXNlcmlhbGl6ZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vRGVzZXJpYWxpemVyXCIpKTtcbmV4cG9ydHMuRGVzZXJpYWxpemVyID0gRGVzZXJpYWxpemVyO1xudmFyIEZvcm1hdHRlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Gb3JtYXR0ZXJcIikpO1xuZXhwb3J0cy5Gb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG52YXIgUmVmZXJlbmNlUmVhZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1JlZmVyZW5jZVJlYWRlclwiKSk7XG5leHBvcnRzLlJlZmVyZW5jZVJlYWRlciA9IFJlZmVyZW5jZVJlYWRlcjtcbnZhciBWYWx1ZVJlYWRlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9WYWx1ZVJlYWRlclwiKSk7XG5leHBvcnRzLlZhbHVlUmVhZGVyID0gVmFsdWVSZWFkZXI7XG52YXIgVmFsdWVXcml0ZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vVmFsdWVXcml0ZXJcIikpO1xuZXhwb3J0cy5WYWx1ZVdyaXRlciA9IFZhbHVlV3JpdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBcnJheVNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGFycmF5IHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIEFycmF5U2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5U2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcnJheVNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg5NyAvKiBUYWdMaXN0ICovKTtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCcnICsgbik7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTIzIC8qIFRhZ09wZW5icmFjZSAqLyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB3cml0ZXIuc2VyaWFsaXplKHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVNlcmlhbGl6ZXI7XG59KFJlZmVyZW5jZVNlcmlhbGl6ZXJfMS5SZWZlcmVuY2VTZXJpYWxpemVyKSk7XG5leHBvcnRzLkFycmF5U2VyaWFsaXplciA9IEFycmF5U2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5U2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEJhc2VTZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgQmFzZVNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBKYW4gNiwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlU2VyaWFsaXplcigpIHtcbiAgICB9XG4gICAgQmFzZVNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgd3JpdGVyLnN0cmVhbS53cml0ZUJ5dGUoMTEwIC8qIFRhZ051bGwgKi8pO1xuICAgIH07XG4gICAgQmFzZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGUod3JpdGVyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVNlcmlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5CYXNlU2VyaWFsaXplciA9IEJhc2VTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBCaWdJbnRBcnJheVNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGJpZ2ludCBhcnJheSBzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDExLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVXcml0ZXJcIik7XG52YXIgU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4uL1NlcmlhbGl6ZXJcIik7XG5pZiAoKHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdmFyIEJpZ0ludEFycmF5U2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJpZ0ludEFycmF5U2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmlnSW50QXJyYXlTZXJpYWxpemVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgQmlnSW50QXJyYXlTZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoOTcgLyogVGFnTGlzdCAqLyk7XG4gICAgICAgICAgICB2YXIgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIG4pO1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMjMgLyogVGFnT3BlbmJyYWNlICovKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgVmFsdWVXcml0ZXJfMS53cml0ZUJpZ0ludChzdHJlYW0sIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTI1IC8qIFRhZ0Nsb3NlYnJhY2UgKi8pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmlnSW50QXJyYXlTZXJpYWxpemVyO1xuICAgIH0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbiAgICB2YXIgYmlnaW50QXJyYXlTZXJpYWxpemVyID0gbmV3IEJpZ0ludEFycmF5U2VyaWFsaXplcigpO1xuICAgIFNlcmlhbGl6ZXJfMS5yZWdpc3RlcihCaWdJbnQ2NEFycmF5LCBiaWdpbnRBcnJheVNlcmlhbGl6ZXIpO1xuICAgIFNlcmlhbGl6ZXJfMS5yZWdpc3RlcihCaWdVaW50NjRBcnJheSwgYmlnaW50QXJyYXlTZXJpYWxpemVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZ0ludEFycmF5U2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEJpZ0ludFNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBocHJvc2UgYmlnaW50IHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBKYW4gMTEsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFZhbHVlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVXcml0ZXJcIik7XG52YXIgQmFzZVNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VTZXJpYWxpemVyXCIpO1xudmFyIFNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9TZXJpYWxpemVyXCIpO1xuaWYgKHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIEJpZ0ludFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCaWdJbnRTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCaWdJbnRTZXJpYWxpemVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIEJpZ0ludFNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIFZhbHVlV3JpdGVyXzEud3JpdGVCaWdJbnQod3JpdGVyLnN0cmVhbSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmlnSW50U2VyaWFsaXplcjtcbiAgICB9KEJhc2VTZXJpYWxpemVyXzEuQmFzZVNlcmlhbGl6ZXIpKTtcbiAgICBTZXJpYWxpemVyXzEucmVnaXN0ZXIoQmlnSW50LCBuZXcgQmlnSW50U2VyaWFsaXplcigpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZ0ludFNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBCb29sZWFuU2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGJvb2xlYW4gc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZVNlcmlhbGl6ZXJcIik7XG52YXIgQm9vbGVhblNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvb2xlYW5TZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvb2xlYW5TZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJvb2xlYW5TZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHdyaXRlci5zdHJlYW0ud3JpdGVCeXRlKHZhbHVlLnZhbHVlT2YoKSA/IDExNiAvKiBUYWdUcnVlICovIDogMTAyIC8qIFRhZ0ZhbHNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBCb29sZWFuU2VyaWFsaXplcjtcbn0oQmFzZVNlcmlhbGl6ZXJfMS5CYXNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5Cb29sZWFuU2VyaWFsaXplciA9IEJvb2xlYW5TZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhblNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBCeXRlc1NlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGJ5dGVzIHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIEJ5dGVzU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnl0ZXNTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ5dGVzU2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCeXRlc1NlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg5OCAvKiBUYWdCeXRlcyAqLyk7XG4gICAgICAgIHZhciBuID0gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpID8gdmFsdWUuYnl0ZUxlbmd0aCA6IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPiAwKVxuICAgICAgICAgICAgc3RyZWFtLndyaXRlQXNjaWlTdHJpbmcoJycgKyBuKTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgzNCAvKiBUYWdRdW90ZSAqLyk7XG4gICAgICAgIHN0cmVhbS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMzQgLyogVGFnUXVvdGUgKi8pO1xuICAgIH07XG4gICAgcmV0dXJuIEJ5dGVzU2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuQnl0ZXNTZXJpYWxpemVyID0gQnl0ZXNTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXNTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgRGF0ZVNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBEYXRlIHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vUmVmZXJlbmNlU2VyaWFsaXplclwiKTtcbnZhciBWYWx1ZVdyaXRlcl8xID0gcmVxdWlyZShcIi4uL1ZhbHVlV3JpdGVyXCIpO1xudmFyIERhdGVTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlU2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEYXRlU2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIHZhciBzdHJlYW0gPSB3cml0ZXIuc3RyZWFtO1xuICAgICAgICB3cml0ZXIudXRjID8gVmFsdWVXcml0ZXJfMS53cml0ZVVUQ0RhdGUoc3RyZWFtLCB2YWx1ZSkgOiBWYWx1ZVdyaXRlcl8xLndyaXRlTG9jYWxEYXRlKHN0cmVhbSwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVTZXJpYWxpemVyO1xufShSZWZlcmVuY2VTZXJpYWxpemVyXzEuUmVmZXJlbmNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5EYXRlU2VyaWFsaXplciA9IERhdGVTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZVNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBEaWN0aW9uYXJ5U2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIGRpY3Rpb25hcnkgc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIERpY3Rpb25hcnlTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIHZhciBzdHJlYW0gPSB3cml0ZXIuc3RyZWFtO1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkcy5sZW5ndGhdID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiB2YWx1ZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1tmaWVsZHMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEwOSAvKiBUYWdNYXAgKi8pO1xuICAgICAgICBpZiAobiA+IDApXG4gICAgICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIG4pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZShmaWVsZHNbaV0pO1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZSh2YWx1ZVtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNlcmlhbGl6ZXIgPSBEaWN0aW9uYXJ5U2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpY3Rpb25hcnlTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgRXJyb3JTZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBlcnJvciBzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEZlYiA4LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vUmVmZXJlbmNlU2VyaWFsaXplclwiKTtcbnZhciBWYWx1ZVdyaXRlcl8xID0gcmVxdWlyZShcIi4uL1ZhbHVlV3JpdGVyXCIpO1xudmFyIEVycm9yU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXJyb3JTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9yU2VyaWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFcnJvclNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgLy8gTm8gcmVmZXJlbmNlIHRvIEVycm9yXG4gICAgICAgIHdyaXRlci5hZGRSZWZlcmVuY2VDb3VudCgxKTtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHdyaXRlci5zdHJlYW07XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNjkgLyogVGFnRXJyb3IgKi8pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDExNSAvKiBUYWdTdHJpbmcgKi8pO1xuICAgICAgICBWYWx1ZVdyaXRlcl8xLndyaXRlU3RyaW5nQm9keShzdHJlYW0sIHZhbHVlLm1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yU2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuRXJyb3JTZXJpYWxpemVyID0gRXJyb3JTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgR3VpZFNlcmlhbGl6ZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBHdWlkIHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiA2LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vUmVmZXJlbmNlU2VyaWFsaXplclwiKTtcbnZhciBHdWlkU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3VpZFNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3VpZFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgR3VpZFNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMDMgLyogVGFnR3VpZCAqLyk7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTIzIC8qIFRhZ09wZW5icmFjZSAqLyk7XG4gICAgICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBHdWlkU2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuR3VpZFNlcmlhbGl6ZXIgPSBHdWlkU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUd1aWRTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTWFwU2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBNYXAgc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiA2LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vUmVmZXJlbmNlU2VyaWFsaXplclwiKTtcbnZhciBNYXBTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTWFwU2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIHZhciBzdHJlYW0gPSB3cml0ZXIuc3RyZWFtO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEwOSAvKiBUYWdNYXAgKi8pO1xuICAgICAgICB2YXIgbiA9IHZhbHVlLnNpemU7XG4gICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCcnICsgbik7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTIzIC8qIFRhZ09wZW5icmFjZSAqLyk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIHdyaXRlci5zZXJpYWxpemUoayk7XG4gICAgICAgICAgICB3cml0ZXIuc2VyaWFsaXplKHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMjUgLyogVGFnQ2xvc2VicmFjZSAqLyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuTWFwU2VyaWFsaXplciA9IE1hcFNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTnVtYmVyU2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBudW1iZXIgc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAxMSwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZVNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VTZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVXcml0ZXJcIik7XG52YXIgTnVtYmVyU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJTZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE51bWJlclNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIFZhbHVlV3JpdGVyXzEud3JpdGVJbnRlZ2VyKHdyaXRlci5zdHJlYW0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFZhbHVlV3JpdGVyXzEud3JpdGVEb3VibGUod3JpdGVyLnN0cmVhbSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTnVtYmVyU2VyaWFsaXplcjtcbn0oQmFzZVNlcmlhbGl6ZXJfMS5CYXNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5OdW1iZXJTZXJpYWxpemVyID0gTnVtYmVyU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bWJlclNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPYmplY3RTZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIG9iamVjdCBzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE4LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCeXRlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vQnl0ZVN0cmVhbVwiKTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVXcml0ZXJcIik7XG52YXIgT2JqZWN0U2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0U2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXJpYWxpemVyKG9iaiwgbmFtZSwgZmllbGRzKSB7XG4gICAgICAgIGlmIChmaWVsZHMgPT09IHZvaWQgMCkgeyBmaWVsZHMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkcy5sZW5ndGhdID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdmFyIHN0cmVhbSA9IG5ldyBCeXRlU3RyZWFtXzEuQnl0ZVN0cmVhbSgpO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDk5IC8qIFRhZ0NsYXNzICovKTtcbiAgICAgICAgVmFsdWVXcml0ZXJfMS53cml0ZVN0cmluZ0JvZHkoc3RyZWFtLCBuYW1lKTtcbiAgICAgICAgdmFyIG4gPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICBpZiAobiA+IDApXG4gICAgICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIG4pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMTUgLyogVGFnU3RyaW5nICovKTtcbiAgICAgICAgICAgIFZhbHVlV3JpdGVyXzEud3JpdGVTdHJpbmdCb2R5KHN0cmVhbSwgZmllbGRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICAgICAgX3RoaXMubWV0YWRhdGEgPSBzdHJlYW0udGFrZUJ5dGVzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0U2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB2YXIgbiA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICAgIHZhciByID0gd3JpdGVyLndyaXRlQ2xhc3ModGhpcy50eXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGUobWV0YWRhdGEpO1xuICAgICAgICAgICAgd3JpdGVyLmFkZFJlZmVyZW5jZUNvdW50KG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIHdyaXRlciwgdmFsdWUpO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDExMSAvKiBUYWdPYmplY3QgKi8pO1xuICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIHIpO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZSh2YWx1ZVtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3RTZXJpYWxpemVyO1xufShSZWZlcmVuY2VTZXJpYWxpemVyXzEuUmVmZXJlbmNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5PYmplY3RTZXJpYWxpemVyID0gT2JqZWN0U2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBSZWZlcmVuY2VTZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHJlZmVyZW5jZSBzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vQmFzZVNlcmlhbGl6ZXJcIik7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VTZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgd3JpdGVyLnNldFJlZmVyZW5jZSh2YWx1ZSk7XG4gICAgfTtcbiAgICBSZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXdyaXRlci53cml0ZVJlZmVyZW5jZSh2YWx1ZSkpXG4gICAgICAgICAgICB0aGlzLndyaXRlKHdyaXRlciwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZVNlcmlhbGl6ZXI7XG59KEJhc2VTZXJpYWxpemVyXzEuQmFzZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuUmVmZXJlbmNlU2VyaWFsaXplciA9IFJlZmVyZW5jZVNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWZlcmVuY2VTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU2V0U2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGhwcm9zZSBTZXQgc2VyaWFsaXplciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiA2LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVmZXJlbmNlU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vUmVmZXJlbmNlU2VyaWFsaXplclwiKTtcbnZhciBTZXRTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXRTZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNldFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2V0U2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIHZhciBzdHJlYW0gPSB3cml0ZXIuc3RyZWFtO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDk3IC8qIFRhZ0xpc3QgKi8pO1xuICAgICAgICB2YXIgbiA9IHZhbHVlLnNpemU7XG4gICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUFzY2lpU3RyaW5nKCcnICsgbik7XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoMTIzIC8qIFRhZ09wZW5icmFjZSAqLyk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHdyaXRlci5zZXJpYWxpemUodik7IH0pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXRTZXJpYWxpemVyO1xufShSZWZlcmVuY2VTZXJpYWxpemVyXzEuUmVmZXJlbmNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5TZXRTZXJpYWxpemVyID0gU2V0U2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldFNlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTdHJpbmdTZXJpYWxpemVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHN0cmluZyBzZXJpYWxpemVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDExLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIFZhbHVlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi4vVmFsdWVXcml0ZXJcIik7XG52YXIgU3RyaW5nU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyaW5nU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJpbmdTZXJpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0cmluZ1NlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMTUgLyogVGFnU3RyaW5nICovKTtcbiAgICAgICAgVmFsdWVXcml0ZXJfMS53cml0ZVN0cmluZ0JvZHkoc3RyZWFtLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBTdHJpbmdTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyZWFtID0gd3JpdGVyLnN0cmVhbTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEwMSAvKiBUYWdFbXB0eSAqLyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMTcgLyogVGFnVVRGOENoYXIgKi8pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS53cml0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcywgd3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdTZXJpYWxpemVyO1xufShSZWZlcmVuY2VTZXJpYWxpemVyXzEuUmVmZXJlbmNlU2VyaWFsaXplcikpO1xuZXhwb3J0cy5TdHJpbmdTZXJpYWxpemVyID0gU3RyaW5nU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ1NlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBUeXBlZEFycmF5U2VyaWFsaXplci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgaHByb3NlIHR5cGVkIGFycmF5IHNlcmlhbGl6ZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDYsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWZlcmVuY2VTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VTZXJpYWxpemVyXCIpO1xudmFyIFR5cGVkQXJyYXlTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUeXBlZEFycmF5U2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUeXBlZEFycmF5U2VyaWFsaXplcih3cml0ZU51bWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFR5cGVkQXJyYXlTZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUud3JpdGUuY2FsbCh0aGlzLCB3cml0ZXIsIHZhbHVlKTtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHdyaXRlci5zdHJlYW07XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoOTcgLyogVGFnTGlzdCAqLyk7XG4gICAgICAgIHZhciBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobiA+IDApXG4gICAgICAgICAgICBzdHJlYW0ud3JpdGVBc2NpaVN0cmluZygnJyArIG4pO1xuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyMyAvKiBUYWdPcGVuYnJhY2UgKi8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy53cml0ZU51bWJlcihzdHJlYW0sIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyNSAvKiBUYWdDbG9zZWJyYWNlICovKTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlZEFycmF5U2VyaWFsaXplcjtcbn0oUmVmZXJlbmNlU2VyaWFsaXplcl8xLlJlZmVyZW5jZVNlcmlhbGl6ZXIpKTtcbmV4cG9ydHMuVHlwZWRBcnJheVNlcmlhbGl6ZXIgPSBUeXBlZEFycmF5U2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVkQXJyYXlTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQ2xpZW50LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IENsaWVudCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IE1hciAyOCwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDbGllbnRDb2RlY18xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29kZWNcIik7XG52YXIgQ2xpZW50Q29udGV4dF8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29udGV4dFwiKTtcbnZhciBJbnZva2VNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9JbnZva2VNYW5hZ2VyXCIpO1xudmFyIElPTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSU9NYW5hZ2VyXCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbmZ1bmN0aW9uIG1ha2VJbnZva2UoY2xpZW50LCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY29udGV4dCA9IChhcmdzLmxlbmd0aCA+IDAgJiYgYXJnc1thcmdzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQpID8gYXJncy5wb3AoKSA6IG5ldyBDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50Lmludm9rZShuYW1lLCBhcmdzLCBjb250ZXh0KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0TWV0aG9kcyhjbGllbnQsIHNlcnZpY2UsIG5hbWVzcGFjZSwgbmFtZSwgbWV0aG9kcykge1xuICAgIGlmIChzZXJ2aWNlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXJ2aWNlW25hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kcykpIHtcbiAgICAgICAgbWV0aG9kcyA9IFttZXRob2RzXTtcbiAgICB9XG4gICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlICsgbmFtZSArICdfJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBtZXRob2RzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXJ2aWNlW25hbWVdW25vZGVdID0gbWFrZUludm9rZShjbGllbnQsIG5hbWVzcGFjZSArIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBub2RlKSB7XG4gICAgICAgICAgICAgICAgc2V0TWV0aG9kcyhjbGllbnQsIHNlcnZpY2VbbmFtZV0sIG5hbWVzcGFjZSwgbiwgbm9kZVtuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VTZXJ2aWNlKGNsaWVudCwgZnVuY3Rpb25zKSB7XG4gICAgdmFyIHJvb3QgPSBVdGlsc18xLm5vcm1hbGl6ZShmdW5jdGlvbnMpO1xuICAgIHZhciBzZXJ2aWNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSByb290W2ldO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoc2VydmljZVtub2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VydmljZVtub2RlXSA9IG1ha2VJbnZva2UoY2xpZW50LCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBub2RlKSB7XG4gICAgICAgICAgICAgICAgc2V0TWV0aG9kcyhjbGllbnQsIHNlcnZpY2UsICcnLCBuYW1lXzEsIG5vZGVbbmFtZV8xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcnZpY2U7XG59XG52YXIgU2VydmljZVByb3h5SGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlUHJveHlIYW5kbGVyKGNsaWVudCwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICB9XG4gICAgU2VydmljZVByb3h5SGFuZGxlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gJ3RoZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHAgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0W3BdID0gbmV3IFByb3h5KGZ1bmN0aW9uICgpIHsgfSwgbmV3IFNlcnZpY2VQcm94eUhhbmRsZXIodGhpcy5jbGllbnQsIHRoaXMubmFtZXNwYWNlID8gdGhpcy5uYW1lc3BhY2UgKyAnXycgKyBwIDogJycgKyBwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFtwXTtcbiAgICB9O1xuICAgIFNlcnZpY2VQcm94eUhhbmRsZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGhpc0FyZywgYXJncykge1xuICAgICAgICBpZiAodGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gKGFyZ3MubGVuZ3RoID4gMCAmJiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCkgPyBhcmdzLnBvcCgpIDogbmV3IENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuaW52b2tlKHRoaXMubmFtZXNwYWNlLCBhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGFyZ2V0IGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VQcm94eUhhbmRsZXI7XG59KCkpO1xudmFyIENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQodXJpKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmNvZGVjID0gQ2xpZW50Q29kZWNfMS5EZWZhdWx0Q2xpZW50Q29kZWMuaW5zdGFuY2U7XG4gICAgICAgIHRoaXMudGltZW91dCA9IDMwMDAwO1xuICAgICAgICB0aGlzLnVyaWxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5pbnZva2VNYW5hZ2VyID0gbmV3IEludm9rZU1hbmFnZXJfMS5JbnZva2VNYW5hZ2VyKHRoaXMuY2FsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pb01hbmFnZXIgPSBuZXcgSU9NYW5hZ2VyXzEuSU9NYW5hZ2VyKHRoaXMudHJhbnNwb3J0LmJpbmQodGhpcykpO1xuICAgICAgICBDbGllbnQudHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBjdG9yID0gX2EuY3RvcjtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSBuZXcgY3RvcigpO1xuICAgICAgICAgICAgX3RoaXMudHJhbnNwb3J0c1tuYW1lXSA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNwb3J0OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc3BvcnRzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXJpbGlzdC5wdXNoKHVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnVyaWxpc3QpLnB1c2guYXBwbHkoX2EsIHVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2xpZW50LnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsIGN0b3IpIHtcbiAgICAgICAgQ2xpZW50LnRyYW5zcG9ydHMucHVzaCh7IG5hbWU6IG5hbWUsIGN0b3I6IGN0b3IgfSk7XG4gICAgICAgIGN0b3Iuc2NoZW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlbWUpIHsgcmV0dXJuIENsaWVudC5wcm90b2NvbHNbc2NoZW1lICsgJzonXSA9IG5hbWU7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsaWVudC5wcm90b3R5cGUsIFwidXJpc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXJpbGlzdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cmlsaXN0ID0gdmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cmlsaXN0LnNvcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5yYW5kb20oKSAtIDAuNTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENsaWVudC5wcm90b3R5cGUudXNlU2VydmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXNwYWNlO1xuICAgICAgICB2YXIgcmV0dXJuVHlwZXM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU2VydmljZSh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZXMgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJ2aWNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHJldHVyblR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gcmV0dXJuVHlwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsbG5hbWUgPSAnJyArIG5hbWVfMjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxuYW1lID0gbmFtZXNwYWNlICsgJ18nICsgbmFtZV8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJldHVyblR5cGVzW2Z1bGxuYW1lXSA9IHJldHVyblR5cGVzW25hbWVfMl07XG4gICAgICAgICAgICAgICAgc2VydmljZVtuYW1lXzJdID0gbWFrZUludm9rZSh0aGlzLCBmdWxsbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHNlcnZpY2UsIG5ldyBTZXJ2aWNlUHJveHlIYW5kbGVyKHRoaXMsIG5hbWVzcGFjZSkpO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS51c2VTZXJ2aWNlQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5pbnZva2UoJ34nKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVzZVNlcnZpY2UodGhpcywgbmFtZXMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGhhbmRsZXJzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuaW52b2tlTWFuYWdlcikudXNlLmFwcGx5KF9hLCBoYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5pb01hbmFnZXIpLnVzZS5hcHBseShfYiwgaGFuZGxlcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS51bnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGhhbmRsZXJzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuaW52b2tlTWFuYWdlcikudW51c2UuYXBwbHkoX2EsIGhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmlvTWFuYWdlcikudW51c2UuYXBwbHkoX2IsIGhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gW107IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbmV3IENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0KCk7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsaWVudENvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFyZ3MubGVuZ3RoID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoYXJncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRDb250ZXh0ID0gKGNvbnRleHQgaW5zdGFuY2VvZiBDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCkgPyBjb250ZXh0IDogbmV3IENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50Q29udGV4dC5pbml0KHRoaXMsIHRoaXMucmV0dXJuVHlwZXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuaW52b2tlTWFuYWdlci5oYW5kbGVyKG5hbWUsIGFyZ3MsIGNsaWVudENvbnRleHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29kZWMsIHJlcXVlc3QsIHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWMgPSB0aGlzLmNvZGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IGNvZGVjLmVuY29kZShuYW1lLCBhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdChyZXF1ZXN0LCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNvZGVjLmRlY29kZShyZXNwb25zZSwgY29udGV4dCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlvTWFuYWdlci5oYW5kbGVyKHJlcXVlc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS50cmFuc3BvcnQgPSBmdW5jdGlvbiAocmVxdWVzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJpLCBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IFV0aWxzXzEucGFyc2VVUkkoY29udGV4dC51cmkpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBDbGllbnQucHJvdG9jb2xzW3VyaS5wcm90b2NvbF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy50cmFuc3BvcnRzW25hbWVdLnRyYW5zcG9ydChyZXF1ZXN0LCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm90b2NvbCBcXFwiXCIgKyB1cmkucHJvdG9jb2wgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cywgbmFtZV8zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lXzMgaW4gdGhpcy50cmFuc3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudHJhbnNwb3J0c1tuYW1lXzNdLmFib3J0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocmVzdWx0cyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50LnRyYW5zcG9ydHMgPSBbXTtcbiAgICBDbGllbnQucHJvdG9jb2xzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQ2xpZW50Q29kZWMudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IENsaWVudENvZGVjIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEphbiAyNywgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlvXzEgPSByZXF1aXJlKFwiQGhwcm9zZS9pb1wiKTtcbnZhciBEZWZhdWx0Q2xpZW50Q29kZWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdENsaWVudENvZGVjKCkge1xuICAgICAgICB0aGlzLnNpbXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnV0YyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvbmdUeXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuZGljdFR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgRGVmYXVsdENsaWVudENvZGVjLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgY29udGV4dCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IGlvXzEuQnl0ZVN0cmVhbSgpO1xuICAgICAgICB2YXIgd3JpdGVyID0gbmV3IGlvXzEuV3JpdGVyKHN0cmVhbSwgdGhpcy5zaW1wbGUsIHRoaXMudXRjKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBjb250ZXh0LnJlcXVlc3RIZWFkZXJzO1xuICAgICAgICBpZiAodGhpcy5zaW1wbGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2ltcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIF8gaW4gaGVhZGVycykge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSg3MiAvKiBUYWdIZWFkZXIgKi8pO1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZShoZWFkZXJzKTtcbiAgICAgICAgICAgIHdyaXRlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNjcgLyogVGFnQ2FsbCAqLyk7XG4gICAgICAgIHdyaXRlci5zZXJpYWxpemUobmFtZSk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdyaXRlci5yZXNldCgpO1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDEyMiAvKiBUYWdFbmQgKi8pO1xuICAgICAgICByZXR1cm4gc3RyZWFtLnRha2VCeXRlcygpO1xuICAgIH07XG4gICAgRGVmYXVsdENsaWVudENvZGVjLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IG5ldyBpb18xLkJ5dGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IGlvXzEuUmVhZGVyKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICByZWFkZXIubG9uZ1R5cGUgPSB0aGlzLmxvbmdUeXBlO1xuICAgICAgICByZWFkZXIuZGljdFR5cGUgPSB0aGlzLmRpY3RUeXBlO1xuICAgICAgICB2YXIgdGFnID0gc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgIGlmICh0YWcgPT09IDcyIC8qIFRhZ0hlYWRlciAqLykge1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSByZWFkZXIuZGVzZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXNwb25zZUhlYWRlcnNbbmFtZV8xXSA9IGhlYWRlcnNbbmFtZV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgdGFnID0gc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgODIgLyogVGFnUmVzdWx0ICovOlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlSGVhZGVycy5zaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNpbXBsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZGVzZXJpYWxpemUoY29udGV4dC5yZXR1cm5UeXBlKTtcbiAgICAgICAgICAgIGNhc2UgNjkgLyogVGFnRXJyb3IgKi86XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRlci5kZXNlcmlhbGl6ZShTdHJpbmcpKTtcbiAgICAgICAgICAgIGNhc2UgMTIyIC8qIFRhZ0VuZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC50eXBlID09PSBudWxsID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlOlxcclxcbicgKyBzdHJlYW0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRDbGllbnRDb2RlYy5pbnN0YW5jZSA9IG5ldyBEZWZhdWx0Q2xpZW50Q29kZWMoKTtcbiAgICByZXR1cm4gRGVmYXVsdENsaWVudENvZGVjO1xufSgpKTtcbmV4cG9ydHMuRGVmYXVsdENsaWVudENvZGVjID0gRGVmYXVsdENsaWVudENvZGVjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50Q29kZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBDbGllbnRDb250ZXh0LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQ2xpZW50Q29udGV4dCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDMwLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9Db250ZXh0XCIpO1xudmFyIENsaWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsaWVudENvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xpZW50Q29udGV4dChpdGVtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoISFpdGVtcykge1xuICAgICAgICAgICAgX3RoaXMuY29weShpdGVtcywgX3RoaXMpO1xuICAgICAgICAgICAgaWYgKCdyZXF1ZXN0SGVhZGVycycgaW4gaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb3B5KGl0ZW1zWydyZXF1ZXN0SGVhZGVycyddLCBfdGhpcy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGllbnRDb250ZXh0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGNsaWVudCwgcmV0dXJuVHlwZSkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgaWYgKGNsaWVudC51cmlzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aGlzLnVyaSA9IGNsaWVudC51cmlzWzBdO1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5UeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnJldHVyblR5cGUgPSByZXR1cm5UeXBlO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBjbGllbnQudGltZW91dDtcbiAgICAgICAgdGhpcy5jb3B5KGNsaWVudC5yZXF1ZXN0SGVhZGVycywgdGhpcy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50Q29udGV4dDtcbn0oQ29udGV4dF8xLkNvbnRleHQpKTtcbmV4cG9ydHMuQ2xpZW50Q29udGV4dCA9IENsaWVudENvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRDb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQ29udGV4dC50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IENvbnRleHQgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IE1hciAyOSwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgQ29udGV4dC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChzcmMsIGRpc3QpIHtcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHNyYykge1xuICAgICAgICAgICAgICAgIGlmICgobmFtZV8xICE9PSAncmVxdWVzdEhlYWRlcnMnKSAmJlxuICAgICAgICAgICAgICAgICAgICAobmFtZV8xICE9PSAncmVzcG9uc2VIZWFkZXJzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFzcmMuaGFzT3duUHJvcGVydHkgfHwgc3JjLmhhc093blByb3BlcnR5KG5hbWVfMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RbbmFtZV8xXSA9IHNyY1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5jb3B5KHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHRoaXMuY29weSh0aGlzLnJlcXVlc3RIZWFkZXJzLCByZXN1bHQucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICB0aGlzLmNvcHkodGhpcy5yZXNwb25zZUhlYWRlcnMsIHJlc3VsdC5yZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5Db250ZXh0ID0gQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBDb29raWVNYW5hZ2VyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQ29va2llTWFuYWdlciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE4LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29va2llTWFuYWdlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBzZXRDb29raWUoaGVhZGVycywgaG9zdCkge1xuICAgIGlmIChob3N0ID09PSB2b2lkIDApIHsgaG9zdCA9ICdAJzsgfVxuICAgIGZ1bmN0aW9uIF9zZXRDb29raWUodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNvb2tpZXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoJzsnKTtcbiAgICAgICAgdmFyIGNvb2tpZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF9hID0gY29va2llc1swXS50cmltKCkuc3BsaXQoJz0nLCAyKSwgY29va2llLm5hbWUgPSBfYVswXSwgY29va2llLnZhbHVlID0gX2FbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9iID0gY29va2llc1tpXS50cmltKCkuc3BsaXQoJz0nLCAyKSwgayA9IF9iWzBdLCB2ID0gX2JbMV07XG4gICAgICAgICAgICBjb29raWVbay50b1VwcGVyQ2FzZSgpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9tY2F0IGNhbiByZXR1cm4gU2V0Q29va2llMiB3aXRoIHBhdGggd3JhcHBlZCBpbiBcIlxuICAgICAgICBpZiAoY29va2llLlBBVEgpIHtcbiAgICAgICAgICAgIHZhciBuID0gY29va2llLlBBVEgubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPiAyICYmIGNvb2tpZS5QQVRILmNoYXJBdCgwKSA9PT0gJ1wiJyAmJiBjb29raWUuUEFUSC5jaGFyQXQobiAtIDEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgY29va2llLlBBVEggPSBjb29raWUuUEFUSC5zdWJzdHIoMSwgbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29va2llLlBBVEggPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb2tpZS5FWFBJUkVTKSB7XG4gICAgICAgICAgICBjb29raWUuRVhQSVJFUyA9IERhdGUucGFyc2UoY29va2llLkVYUElSRVMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29raWUuRE9NQUlOKSB7XG4gICAgICAgICAgICBjb29raWUuRE9NQUlOID0gY29va2llLkRPTUFJTi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29va2llLkRPTUFJTiA9IGhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29va2llLlNFQ1VSRSA9IChjb29raWUuU0VDVVJFICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoY29va2llTWFuYWdlcltjb29raWUuRE9NQUlOXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb29raWVNYW5hZ2VyW2Nvb2tpZS5ET01BSU5dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb29raWVNYW5hZ2VyW2Nvb2tpZS5ET01BSU5dW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIGhlYWRlcnMpIHtcbiAgICAgICAgbmFtZV8xID0gbmFtZV8xLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICgobmFtZV8xID09PSAnc2V0LWNvb2tpZScpIHx8IChuYW1lXzEgPT09ICdzZXQtY29va2llMicpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXJzW25hbWVfMV07XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pLmZvckVhY2goX3NldENvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZTtcbmZ1bmN0aW9uIGdldENvb2tpZShob3N0LCBwYXRoLCBzZWN1cmUpIHtcbiAgICBob3N0ID0gKGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6ICdAJyk7XG4gICAgcGF0aCA9IChwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiAnLycpO1xuICAgIHZhciBjb29raWVzID0gW107XG4gICAgZm9yICh2YXIgZG9tYWluIGluIGNvb2tpZU1hbmFnZXIpIHtcbiAgICAgICAgaWYgKGhvc3QuaW5kZXhPZihkb21haW4pID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIGNvb2tpZU1hbmFnZXJbZG9tYWluXSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSBjb29raWVNYW5hZ2VyW2RvbWFpbl1bbmFtZV8yXTtcbiAgICAgICAgICAgICAgICBpZiAoY29va2llLkVYUElSRVMgJiYgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPiBjb29raWUuRVhQSVJFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lXzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoLmluZGV4T2YoY29va2llLlBBVEgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2VjdXJlID09PSBjb29raWUuU0VDVVJFKSAmJiAoY29va2llLnZhbHVlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29va2llcy5wdXNoKGNvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbmFtZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvb2tpZU1hbmFnZXJbZG9tYWluXVtuYW1lc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvb2tpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY29va2llcy5qb2luKCc7ICcpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5leHBvcnRzLmdldENvb2tpZSA9IGdldENvb2tpZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvb2tpZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBEZWZlcnJlZC50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgRGVmZXJyZWQgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDEwLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuZXhwb3J0cy5kZWZlciA9IGRlZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBJT01hbmFnZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgSU9NYW5hZ2VyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRmViIDE2LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQbHVnaW5NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9QbHVnaW5NYW5hZ2VyXCIpO1xudmFyIElPTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSU9NYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElPTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJT01hbmFnZXIucHJvdG90eXBlLmdldE5leHRIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0LCBjb250ZXh0KSB7IHJldHVybiBoYW5kbGVyKHJlcXVlc3QsIGNvbnRleHQsIG5leHQpOyB9O1xuICAgIH07XG4gICAgcmV0dXJuIElPTWFuYWdlcjtcbn0oUGx1Z2luTWFuYWdlcl8xLlBsdWdpbk1hbmFnZXIpKTtcbmV4cG9ydHMuSU9NYW5hZ2VyID0gSU9NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SU9NYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgSW52b2tlTWFuYWdlci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEludm9rZU1hbmFnZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEZlYiAxNiwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGx1Z2luTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vUGx1Z2luTWFuYWdlclwiKTtcbnZhciBJbnZva2VNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZva2VNYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludm9rZU1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW52b2tlTWFuYWdlci5wcm90b3R5cGUuZ2V0TmV4dEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgbmV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGFyZ3MsIGNvbnRleHQpIHsgcmV0dXJuIGhhbmRsZXIobmFtZSwgYXJncywgY29udGV4dCwgbmV4dCk7IH07XG4gICAgfTtcbiAgICByZXR1cm4gSW52b2tlTWFuYWdlcjtcbn0oUGx1Z2luTWFuYWdlcl8xLlBsdWdpbk1hbmFnZXIpKTtcbmV4cG9ydHMuSW52b2tlTWFuYWdlciA9IEludm9rZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnZva2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTWV0aG9kLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE1ldGhvZCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IE1hciAyOCwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1ldGhvZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXRob2QobWV0aG9kLCBuYW1lLCB0YXJnZXQsIHBhcmFtVHlwZXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMgPSBwYXJhbVR5cGVzO1xuICAgICAgICBpZiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbWV0aG9kLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1ldGhvZDtcbn0oKSk7XG5leHBvcnRzLk1ldGhvZCA9IE1ldGhvZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1ldGhvZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE1ldGhvZE1hbmFnZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBNZXRob2RNYW5hZ2VyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjgsIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNZXRob2RfMSA9IHJlcXVpcmUoXCIuL01ldGhvZFwiKTtcbnZhciBNZXRob2RNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ldGhvZE1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICB9XG4gICAgTWV0aG9kTWFuYWdlci5wcm90b3R5cGUuZ2V0TmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVzO1xuICAgIH07XG4gICAgTWV0aG9kTWFuYWdlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChuYW1lIGluIHRoaXMubWV0aG9kcykgPyB0aGlzLm1ldGhvZHNbbmFtZV0gOiB0aGlzLm1ldGhvZHNbJyonXTtcbiAgICB9O1xuICAgIE1ldGhvZE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ldGhvZHNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXRob2RNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lID0gbWV0aG9kLm5hbWU7XG4gICAgICAgIGlmIChuYW1lID09PSAnJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5hbWUgPSBtZXRob2QuZnVsbG5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG1ldGhvZC5tZXRob2QubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0aG9kLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0aG9kc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbWV0aG9kO1xuICAgICAgICBpZiAodGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXRob2RNYW5hZ2VyLnByb3RvdHlwZS5hZGRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChmbikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChmbiwgYXJnc1swXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3NbMF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChmbiwgYXJnc1swXSwgdW5kZWZpbmVkLCBhcmdzWzFdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ldGhvZE1hbmFnZXIucHJvdG90eXBlLmFkZE1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gYXJnc1sxXVthcmdzWzBdXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChtZXRob2QsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb2JqW25hbWVdIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChhcmdzWzBdLCB1bmRlZmluZWQsIGFyZ3NbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChuZXcgTWV0aG9kXzEuTWV0aG9kKGFyZ3NbMF0sIGFyZ3NbMl0sIGFyZ3NbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5ldyBNZXRob2RfMS5NZXRob2QoYXJnc1swXSwgdW5kZWZpbmVkLCBhcmdzWzFdLCBhcmdzWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChuZXcgTWV0aG9kXzEuTWV0aG9kKGFyZ3NbMF0sIGFyZ3NbMl0sIGFyZ3NbMV0sIGFyZ3NbM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWV0aG9kTWFuYWdlci5wcm90b3R5cGUuYWRkTWlzc2luZ01ldGhvZCA9IGZ1bmN0aW9uIChmbiwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBuZXcgTWV0aG9kXzEuTWV0aG9kKGZuLCAnKicsIHRhcmdldCk7XG4gICAgICAgIG1ldGhvZC5taXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZuLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgbWV0aG9kLnBhc3NDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZChtZXRob2QpO1xuICAgIH07XG4gICAgTWV0aG9kTWFuYWdlci5wcm90b3R5cGUuYWRkRnVuY3Rpb25zID0gZnVuY3Rpb24gKGZ1bmN0aW9ucykge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXM7XG4gICAgICAgIHZhciBwYXJhbVR5cGVzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKChhcmdzWzBdLmxlbmd0aCA+IDEpICYmICh0eXBlb2YgYXJnc1swXVswXSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBuYW1lcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgcGFyYW1UeXBlcyA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBmdW5jdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAobmFtZXMgJiYgbmFtZXMubGVuZ3RoICE9PSBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWVzLmxlbmd0aCBtdXN0IGJlIGVxdWFsIHRvIGZ1bmN0aW9ucy5sZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobmV3IE1ldGhvZF8xLk1ldGhvZChmdW5jdGlvbnNbaV0sIG5hbWVzID8gbmFtZXNbaV0gOiB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcGFyYW1UeXBlcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXRob2RNYW5hZ2VyLnByb3RvdHlwZS5hZGRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gYXJnc1swXS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWV0aG9kcztcbiAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBuYW1lcztcbiAgICAgICAgdmFyIHBhcmFtVHlwZXM7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWVzID0gYXJnc1swXTtcbiAgICAgICAgICAgIHBhcmFtVHlwZXMgPSBhcmdzWzJdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gdGFyZ2V0W25hbWVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChuZXcgTWV0aG9kXzEuTWV0aG9kKG1ldGhvZCwgbmFtZXNbaV0sIHRhcmdldCwgcGFyYW1UeXBlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmpbbmFtZV0gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kcyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzJdLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbMl1bMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzID0gYXJnc1syXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZXMgPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBuYW1lcyA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgcGFyYW1UeXBlcyA9IGFyZ3NbM107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzICYmIG5hbWVzLmxlbmd0aCAhPT0gbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lcy5sZW5ndGggbXVzdCBiZSBlcXVhbCB0byBmdW5jdGlvbnMubGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5ldyBNZXRob2RfMS5NZXRob2QobWV0aG9kc1tpXSwgbmFtZXMgPyBuYW1lc1tpXSA6IHVuZGVmaW5lZCwgdGFyZ2V0LCBwYXJhbVR5cGVzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ldGhvZE1hbmFnZXIucHJvdG90eXBlLmFkZEluc3RhbmNlTWV0aG9kcyA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWVzcGFjZSkge1xuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoKCF0YXJnZXQuaGFzT3duUHJvcGVydHkgfHwgdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWVfMSkpICYmIHR5cGVvZiB0YXJnZXRbbmFtZV8xXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZSA/IG5hbWVzcGFjZSArICdfJyArIG5hbWVfMSA6IG5hbWVfMTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChuZXcgTWV0aG9kXzEuTWV0aG9kKHRhcmdldFtuYW1lXzFdLCBmdWxsbmFtZSwgdGFyZ2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXRob2RNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuTWV0aG9kTWFuYWdlciA9IE1ldGhvZE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXRob2RNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTW9ja0FnZW50LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE1vY2tBZ2VudCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IEZlYiAyNywgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNb2NrQWdlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9ja0FnZW50KCkge1xuICAgIH1cbiAgICBNb2NrQWdlbnQucmVnaXN0ZXIgPSBmdW5jdGlvbiAoYWRkcmVzcywgaGFuZGxlcikge1xuICAgICAgICBNb2NrQWdlbnQuaGFuZGxlcnNbYWRkcmVzc10gPSBoYW5kbGVyO1xuICAgIH07XG4gICAgTW9ja0FnZW50LmNhbmNlbCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIGRlbGV0ZSBNb2NrQWdlbnQuaGFuZGxlcnNbYWRkcmVzc107XG4gICAgfTtcbiAgICBNb2NrQWdlbnQuaGFuZGxlciA9IGZ1bmN0aW9uIChhZGRyZXNzLCByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBNb2NrQWdlbnQuaGFuZGxlcnNbYWRkcmVzc107XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGhhbmRsZXIoYWRkcmVzcywgcmVxdWVzdCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBpcyBzdG9wcGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2NrQWdlbnQuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBNb2NrQWdlbnQ7XG59KCkpO1xuZXhwb3J0cy5Nb2NrQWdlbnQgPSBNb2NrQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb2NrQWdlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBNb2NrSGFuZGxlci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTW9ja0hhbmRsZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE3LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlcnZpY2VDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9TZXJ2aWNlQ29udGV4dFwiKTtcbnZhciBTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9TZXJ2aWNlXCIpO1xudmFyIE1vY2tBZ2VudF8xID0gcmVxdWlyZShcIi4vTW9ja0FnZW50XCIpO1xudmFyIE1vY2tTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9ja1NlcnZlcihhZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgfVxuICAgIE1vY2tTZXJ2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNb2NrQWdlbnRfMS5Nb2NrQWdlbnQuY2FuY2VsKHRoaXMuYWRkcmVzcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9ja1NlcnZlcjtcbn0oKSk7XG5leHBvcnRzLk1vY2tTZXJ2ZXIgPSBNb2NrU2VydmVyO1xudmFyIE1vY2tIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vY2tIYW5kbGVyKHNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKGFkZHJlc3MsIHJlcXVlc3QpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCBhZGRyZXNzSW5mbztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5sZW5ndGggPiB0aGlzLnNlcnZpY2UubWF4UmVxdWVzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZW50aXR5IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IFNlcnZpY2VDb250ZXh0XzEuU2VydmljZUNvbnRleHQodGhpcy5zZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzSW5mbyA9IHsgJ2ZhbWlseSc6ICdtb2NrJywgJ2FkZHJlc3MnOiBhZGRyZXNzLCAncG9ydCc6IDAgfTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW90ZUFkZHJlc3MgPSBhZGRyZXNzSW5mbztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxvY2FsQWRkcmVzcyA9IGFkZHJlc3NJbmZvO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaGFuZGxlciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VydmljZS5oYW5kbGUocmVxdWVzdCwgY29udGV4dCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgIH1cbiAgICBNb2NrSGFuZGxlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgTW9ja0FnZW50XzEuTW9ja0FnZW50LnJlZ2lzdGVyKHNlcnZlci5hZGRyZXNzLCB0aGlzLmhhbmRsZXIpO1xuICAgIH07XG4gICAgTW9ja0hhbmRsZXIuc2VydmVyVHlwZXMgPSBbTW9ja1NlcnZlcl07XG4gICAgcmV0dXJuIE1vY2tIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuTW9ja0hhbmRsZXIgPSBNb2NrSGFuZGxlcjtcblNlcnZpY2VfMS5TZXJ2aWNlLnJlZ2lzdGVyKCdtb2NrJywgTW9ja0hhbmRsZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9ja0hhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBNb2NrVHJhbnNwb3J0LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTW9ja1RyYW5zcG9ydCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRmViIDI3LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENsaWVudF8xID0gcmVxdWlyZShcIi4vQ2xpZW50XCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbnZhciBNb2NrQWdlbnRfMSA9IHJlcXVpcmUoXCIuL01vY2tBZ2VudFwiKTtcbnZhciBEZWZlcnJlZF8xID0gcmVxdWlyZShcIi4vRGVmZXJyZWRcIik7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKFwiLi9UaW1lb3V0RXJyb3JcIik7XG52YXIgTW9ja1RyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrVHJhbnNwb3J0KCkge1xuICAgIH1cbiAgICBNb2NrVHJhbnNwb3J0LnByb3RvdHlwZS50cmFuc3BvcnQgPSBmdW5jdGlvbiAocmVxdWVzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJpLCByZXN1bHQsIHRpbWVvdXRJZF8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IFV0aWxzXzEucGFyc2VVUkkoY29udGV4dC51cmkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IERlZmVycmVkXzEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWRfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgVGltZW91dEVycm9yXzEuVGltZW91dEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjb250ZXh0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNb2NrQWdlbnRfMS5Nb2NrQWdlbnQuaGFuZGxlcih1cmkuaG9zdG5hbWUsIHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXN1bHQucmVzb2x2ZSh2YWx1ZSk7IH0sIGZ1bmN0aW9uIChyZWFzb24pIHsgcmV0dXJuIHJlc3VsdC5yZWplY3QocmVhc29uKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5wcm9taXNlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1vY2tUcmFuc3BvcnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgTW9ja1RyYW5zcG9ydC5zY2hlbWVzID0gWydtb2NrJ107XG4gICAgcmV0dXJuIE1vY2tUcmFuc3BvcnQ7XG59KCkpO1xuZXhwb3J0cy5Nb2NrVHJhbnNwb3J0ID0gTW9ja1RyYW5zcG9ydDtcbkNsaWVudF8xLkNsaWVudC5yZWdpc3RlcignbW9jaycsIE1vY2tUcmFuc3BvcnQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9ja1RyYW5zcG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFBsdWdpbk1hbmFnZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBQbHVnaW5NYW5hZ2VyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBGZWIgMTYsIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQbHVnaW5NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsdWdpbk1hbmFnZXIoZGVmYXVsdEhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0SGFuZGxlciA9IGRlZmF1bHRIYW5kbGVyO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuZmlyc3RIYW5kbGVyID0gZGVmYXVsdEhhbmRsZXI7XG4gICAgfVxuICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLnJlYnVpbGRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZGVmYXVsdEhhbmRsZXI7XG4gICAgICAgIHZhciBuID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5nZXROZXh0SGFuZGxlcihoYW5kbGVyc1tpXSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJzdEhhbmRsZXIgPSBuZXh0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLCBcImhhbmRsZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0SGFuZGxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaGFuZGxlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmhhbmRsZXJzKS5wdXNoLmFwcGx5KF9hLCBoYW5kbGVycyk7XG4gICAgICAgIHRoaXMucmVidWlsZEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLnVudXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYnVpbGQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyc1tpXSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVidWlsZClcbiAgICAgICAgICAgIHRoaXMucmVidWlsZEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBQbHVnaW5NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUGx1Z2luTWFuYWdlciA9IFBsdWdpbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVnaW5NYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU2VydmljZS50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFNlcnZpY2UgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IE1hciAyOCwgMjAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlcnZpY2VDb2RlY18xID0gcmVxdWlyZShcIi4vU2VydmljZUNvZGVjXCIpO1xudmFyIEludm9rZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0ludm9rZU1hbmFnZXJcIik7XG52YXIgSU9NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9JT01hbmFnZXJcIik7XG52YXIgTWV0aG9kXzEgPSByZXF1aXJlKFwiLi9NZXRob2RcIik7XG52YXIgTWV0aG9kTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vTWV0aG9kTWFuYWdlclwiKTtcbnZhciBTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29kZWMgPSBTZXJ2aWNlQ29kZWNfMS5EZWZhdWx0U2VydmljZUNvZGVjLmluc3RhbmNlO1xuICAgICAgICB0aGlzLm1heFJlcXVlc3RMZW5ndGggPSAweDdGRkZGRkZGO1xuICAgICAgICB0aGlzLmludm9rZU1hbmFnZXIgPSBuZXcgSW52b2tlTWFuYWdlcl8xLkludm9rZU1hbmFnZXIodGhpcy5leGVjdXRlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmlvTWFuYWdlciA9IG5ldyBJT01hbmFnZXJfMS5JT01hbmFnZXIodGhpcy5wcm9jZXNzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1ldGhvZE1hbmFnZXIgPSBuZXcgTWV0aG9kTWFuYWdlcl8xLk1ldGhvZE1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG5hbWVfMSkge1xuICAgICAgICAgICAgdmFyIGN0b3IgPSBTZXJ2aWNlLmhhbmRsZXJzW25hbWVfMV07XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IG5ldyBjdG9yKHRoaXNfMSk7XG4gICAgICAgICAgICB0aGlzXzEuaGFuZGxlcnNbbmFtZV8xXSA9IGhhbmRsZXI7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc18xLCBuYW1lXzEsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZXI7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVyc1tuYW1lXzFdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gU2VydmljZS5oYW5kbGVycykge1xuICAgICAgICAgICAgX2xvb3BfMShuYW1lXzEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKG5ldyBNZXRob2RfMS5NZXRob2QodGhpcy5tZXRob2RNYW5hZ2VyLmdldE5hbWVzLmJpbmQodGhpcy5tZXRob2RNYW5hZ2VyKSwgJ34nKSk7XG4gICAgfVxuICAgIFNlcnZpY2UucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgY3Rvcikge1xuICAgICAgICBTZXJ2aWNlLmhhbmRsZXJzW25hbWVdID0gY3RvcjtcbiAgICAgICAgY3Rvci5zZXJ2ZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAoU2VydmljZS5zZXJ2ZXJUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBTZXJ2aWNlLnNlcnZlclR5cGVzLmdldCh0eXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgU2VydmljZS5zZXJ2ZXJUeXBlcy5zZXQodHlwZSwgW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwibmFtZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGhvZE1hbmFnZXIuZ2V0TmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2VydmljZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChzZXJ2ZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBzZXJ2ZXIuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBzZXJ2ZXJUeXBlcyA9IFNlcnZpY2Uuc2VydmVyVHlwZXM7XG4gICAgICAgIGlmIChzZXJ2ZXJUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IHNlcnZlclR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbmFtZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuYW1lID09PSB1bmRlZmluZWQpIHx8IChuYW1lID09PSBuYW1lc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyc1tuYW1lc1tpXV0uYmluZChzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0eXBlIHNlcnZlciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW9NYW5hZ2VyLmhhbmRsZXIocmVxdWVzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvZGVjLCByZXN1bHQsIF9hLCBuYW1lXzIsIGFyZ3MsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjID0gdGhpcy5jb2RlYztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gY29kZWMuZGVjb2RlKHJlcXVlc3QsIGNvbnRleHQpLCBuYW1lXzIgPSBfYVswXSwgYXJncyA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5pbnZva2VNYW5hZ2VyLmhhbmRsZXIobmFtZV8yLCBhcmdzLCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBlXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgY29kZWMuZW5jb2RlKHJlc3VsdCwgY29udGV4dCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kLCBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGNvbnRleHQubWV0aG9kO1xuICAgICAgICAgICAgICAgIGZ1bmMgPSBtZXRob2QubWV0aG9kO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLnBhc3NDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnVuYy5hcHBseShtZXRob2QudGFyZ2V0LCBbbmFtZSwgYXJncywgY29udGV4dF0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnVuYy5hcHBseShtZXRob2QudGFyZ2V0LCBbbmFtZSwgYXJnc10pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5wYXNzQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmdW5jLmFwcGx5KG1ldGhvZC50YXJnZXQsIGFyZ3MpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGhhbmRsZXJzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuaW52b2tlTWFuYWdlcikudXNlLmFwcGx5KF9hLCBoYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5pb01hbmFnZXIpLnVzZS5hcHBseShfYiwgaGFuZGxlcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUudW51c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaGFuZGxlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgc3dpdGNoIChoYW5kbGVyc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmludm9rZU1hbmFnZXIpLnVudXNlLmFwcGx5KF9hLCBoYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5pb01hbmFnZXIpLnVudXNlLmFwcGx5KF9iLCBoYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RNYW5hZ2VyLmdldChuYW1lKTtcbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdGhpcy5tZXRob2RNYW5hZ2VyLmFkZChtZXRob2QpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMubWV0aG9kTWFuYWdlci5yZW1vdmUobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLm1ldGhvZE1hbmFnZXIpLmFkZEZ1bmN0aW9uLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5cyhbZm5dLCBhcmdzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuYWRkTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5tZXRob2RNYW5hZ2VyKS5hZGRNZXRob2QuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXlzKFthcmdzWzBdLCBhcmdzWzFdXSwgYXJncy5zbGljZSgyKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLmFkZE1pc3NpbmdNZXRob2QgPSBmdW5jdGlvbiAoZm4sIHRhcmdldCkge1xuICAgICAgICB0aGlzLm1ldGhvZE1hbmFnZXIuYWRkTWlzc2luZ01ldGhvZChmbiwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5hZGRGdW5jdGlvbnMgPSBmdW5jdGlvbiAoZnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5tZXRob2RNYW5hZ2VyKS5hZGRGdW5jdGlvbnMuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXlzKFtmdW5jdGlvbnNdLCBhcmdzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuYWRkTWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMubWV0aG9kTWFuYWdlcikuYWRkTWV0aG9kcy5hcHBseShfYSwgX19zcHJlYWRBcnJheXMoW2FyZ3NbMF0sIGFyZ3NbMV1dLCBhcmdzLnNsaWNlKDIpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuYWRkSW5zdGFuY2VNZXRob2RzID0gZnVuY3Rpb24gKHRhcmdldCwgcHJlZml4KSB7XG4gICAgICAgIHRoaXMubWV0aG9kTWFuYWdlci5hZGRJbnN0YW5jZU1ldGhvZHModGFyZ2V0LCBwcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlcnZpY2UuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIFNlcnZpY2Uuc2VydmVyVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5TZXJ2aWNlID0gU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTZXJ2aWNlQ29kZWMudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU2VydmljZUNvZGVjIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogTWFyIDI4LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW9fMSA9IHJlcXVpcmUoXCJAaHByb3NlL2lvXCIpO1xudmFyIERlZmF1bHRTZXJ2aWNlQ29kZWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFNlcnZpY2VDb2RlYygpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpbXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnV0YyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvbmdUeXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuZGljdFR5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgdGhpcy5udWxsVHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgRGVmYXVsdFNlcnZpY2VDb2RlYy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHJlc3VsdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IGlvXzEuQnl0ZVN0cmVhbSgpO1xuICAgICAgICB2YXIgd3JpdGVyID0gbmV3IGlvXzEuV3JpdGVyKHN0cmVhbSwgdGhpcy5zaW1wbGUsIHRoaXMudXRjKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBjb250ZXh0LnJlc3BvbnNlSGVhZGVycztcbiAgICAgICAgaWYgKHRoaXMuc2ltcGxlKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNpbXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBmb3IgKHZhciBfIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNzIgLyogVGFnSGVhZGVyICovKTtcbiAgICAgICAgICAgIHdyaXRlci5zZXJpYWxpemUoaGVhZGVycyk7XG4gICAgICAgICAgICB3cml0ZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZUJ5dGUoNjkgLyogVGFnRXJyb3IgKi8pO1xuICAgICAgICAgICAgd3JpdGVyLnNlcmlhbGl6ZSh0aGlzLmRlYnVnID8gcmVzdWx0LnN0YWNrID8gcmVzdWx0LnN0YWNrIDogcmVzdWx0Lm1lc3NhZ2UgOiByZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKDgyIC8qIFRhZ1Jlc3VsdCAqLyk7XG4gICAgICAgICAgICB3cml0ZXIuc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLndyaXRlQnl0ZSgxMjIgLyogVGFnRW5kICovKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS50YWtlQnl0ZXMoKTtcbiAgICB9O1xuICAgIERlZmF1bHRTZXJ2aWNlQ29kZWMucHJvdG90eXBlLmRlY29kZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gY29udGV4dC5zZXJ2aWNlO1xuICAgICAgICB2YXIgbWV0aG9kID0gc2VydmljZS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGZpbmQgdGhpcyBtZXRob2QgJyArIG5hbWUgKyAnKCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfTtcbiAgICBEZWZhdWx0U2VydmljZUNvZGVjLnByb3RvdHlwZS5kZWNvZGVBcmd1bWVudHMgPSBmdW5jdGlvbiAobWV0aG9kLCByZWFkZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHJlYWRlci5zdHJlYW07XG4gICAgICAgIHZhciB0YWcgPSBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgaWYgKG1ldGhvZC5taXNzaW5nKSB7XG4gICAgICAgICAgICBpZiAodGFnID09PSA5NyAvKiBUYWdMaXN0ICovKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKHRhZywgQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmICh0YWcgPT09IDk3IC8qIFRhZ0xpc3QgKi8pIHtcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gaW9fMS5WYWx1ZVJlYWRlci5yZWFkQ291bnQoc3RyZWFtKTtcbiAgICAgICAgICAgIHZhciBwYXJhbVR5cGVzID0gbWV0aG9kLnBhcmFtVHlwZXM7XG4gICAgICAgICAgICBpZiAocGFyYW1UeXBlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1UeXBlcyA9IG5ldyBBcnJheShjb3VudCkuZmlsbCh0aGlzLm51bGxUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtVHlwZXMubGVuZ3RoID0gY291bnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbVR5cGVzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZXNbaV0gPSB0aGlzLm51bGxUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgICAgICByZWFkZXIuYWRkUmVmZXJlbmNlKGFyZ3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IHJlYWRlci5kZXNlcmlhbGl6ZShwYXJhbVR5cGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgRGVmYXVsdFNlcnZpY2VDb2RlYy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1ldGhvZCgnficsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFsnficsIFtdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IGlvXzEuQnl0ZVN0cmVhbShyZXF1ZXN0KTtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBpb18xLlJlYWRlcihzdHJlYW0sIGZhbHNlKTtcbiAgICAgICAgcmVhZGVyLmxvbmdUeXBlID0gdGhpcy5sb25nVHlwZTtcbiAgICAgICAgcmVhZGVyLmRpY3RUeXBlID0gdGhpcy5kaWN0VHlwZTtcbiAgICAgICAgdmFyIHRhZyA9IHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICBpZiAodGFnID09PSA3MiAvKiBUYWdIZWFkZXIgKi8pIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVhZGVyLmRlc2VyaWFsaXplKHRoaXMubnVsbFR5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlcXVlc3RIZWFkZXJzW25hbWVfMV0gPSBoZWFkZXJzW25hbWVfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRhZyA9IHN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIDY3IC8qIFRhZ0NhbGwgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQucmVxdWVzdEhlYWRlcnMuc2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5zaW1wbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gcmVhZGVyLmRlc2VyaWFsaXplKFN0cmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmRlY29kZUFyZ3VtZW50cyh0aGlzLmRlY29kZU1ldGhvZChuYW1lXzIsIGNvbnRleHQpLCByZWFkZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZV8yLCBhcmdzXTtcbiAgICAgICAgICAgIGNhc2UgMTIyIC8qIFRhZ0VuZCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZU1ldGhvZCgnficsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ34nLCBbXV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXF1ZXN0OlxcclxcbicgKyBzdHJlYW0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRTZXJ2aWNlQ29kZWMuaW5zdGFuY2UgPSBuZXcgRGVmYXVsdFNlcnZpY2VDb2RlYygpO1xuICAgIHJldHVybiBEZWZhdWx0U2VydmljZUNvZGVjO1xufSgpKTtcbmV4cG9ydHMuRGVmYXVsdFNlcnZpY2VDb2RlYyA9IERlZmF1bHRTZXJ2aWNlQ29kZWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJ2aWNlQ29kZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTZXJ2aWNlQ29udGV4dC50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU2VydmljZUNvbnRleHQgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDMwLCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9Db250ZXh0XCIpO1xudmFyIFNlcnZpY2VDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlQ29udGV4dChzZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZXJ2aWNlQ29udGV4dDtcbn0oQ29udGV4dF8xLkNvbnRleHQpKTtcbmV4cG9ydHMuU2VydmljZUNvbnRleHQgPSBTZXJ2aWNlQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZpY2VDb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVGltZW91dEVycm9yLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFRpbWVvdXRFcnJvciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IERlYyAyNiwgMjAxOCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGltZW91dEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lb3V0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gJ3RpbWVvdXQnOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGltZW91dEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lb3V0RXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBVdGlscy50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVXRpbHMgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogSmFuIDksIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwYXJzZVVSSSh1cmkpIHtcbiAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFxcXD8oW14jXSopKT8oIyguKikpPycpO1xuICAgIHZhciBtYXRjaGVzID0gdXJpLm1hdGNoKHBhdHRlcm4pO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciBob3N0ID0gbWF0Y2hlc1s0XS5zcGxpdCgnOicsIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBob3N0OiBtYXRjaGVzWzRdLFxuICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3RbMF0sXG4gICAgICAgICAgICBwb3J0OiBwYXJzZUludChob3N0WzFdLCAxMCkgfHwgMCxcbiAgICAgICAgICAgIHBhdGg6IG1hdGNoZXNbNV0sXG4gICAgICAgICAgICBxdWVyeTogbWF0Y2hlc1s3XSxcbiAgICAgICAgICAgIGZyYWdtZW50OiBtYXRjaGVzWzldXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVUkknKTtcbn1cbmV4cG9ydHMucGFyc2VVUkkgPSBwYXJzZVVSSTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZShmdW5jdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IFtPYmplY3QuY3JlYXRlKG51bGwpXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbnNbaV0uc3BsaXQoJ18nKTtcbiAgICAgICAgdmFyIG5fMSA9IGZ1bmMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG5fMSA+IDApIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gcm9vdDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbl8xOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmNbal07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVbMF1bZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlWzBdW2ZdID0gW09iamVjdC5jcmVhdGUobnVsbCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVswXVtmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucHVzaChmdW5jW25fMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QucHVzaChmdW5jdGlvbnNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZnVuY3Rpb24gZ2V0Q2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciBhcmcxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBhcmcyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGFyZzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGFyZzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhcmcyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXJnMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByb21pc2lmeShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChnZXRDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9taXNpZnkgPSBwcm9taXNpZnk7XG52YXIgQ1JDMzJUQUJMRSA9IFtcbiAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweEVFMEU2MTJDLCAweDk5MDk1MUJBLCAweDA3NkRDNDE5LCAweDcwNkFGNDhGLCAweEU5NjNBNTM1LCAweDlFNjQ5NUEzLFxuICAgIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsIDB4MDlCNjRDMkIsIDB4N0VCMTdDQkQsIDB4RTdCODJEMDcsIDB4OTBCRjFEOTEsXG4gICAgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSwgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNyxcbiAgICAweDEzNkM5ODU2LCAweDY0NkJBOEMwLCAweEZENjJGOTdBLCAweDhBNjVDOUVDLCAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LCAweEZBMEYzRDYzLCAweDhEMDgwREY1LFxuICAgIDB4M0I2RTIwQzgsIDB4NEM2OTEwNUUsIDB4RDU2MDQxRTQsIDB4QTI2NzcxNzIsIDB4M0MwM0U0RDEsIDB4NEIwNEQ0NDcsIDB4RDIwRDg1RkQsIDB4QTUwQUI1NkIsXG4gICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMywgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSxcbiAgICAweDI2RDkzMEFDLCAweDUxREUwMDNBLCAweEM4RDc1MTgwLCAweEJGRDA2MTE2LCAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LCAweEI4QkRBNTBGLFxuICAgIDB4MjgwMkI4OUUsIDB4NUYwNTg4MDgsIDB4QzYwQ0Q5QjIsIDB4QjEwQkU5MjQsIDB4MkY2RjdDODcsIDB4NTg2ODRDMTEsIDB4QzE2MTFEQUIsIDB4QjY2NjJEM0QsXG4gICAgMHg3NkRDNDE5MCwgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRiwgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMyxcbiAgICAweDc4MDdDOUEyLCAweDBGMDBGOTM0LCAweDk2MDlBODhFLCAweEUxMEU5ODE4LCAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLFxuICAgIDB4NkI2QjUxRjQsIDB4MUM2QzYxNjIsIDB4ODU2NTMwRDgsIDB4RjI2MjAwNEUsIDB4NkMwNjk1RUQsIDB4MUIwMUE1N0IsIDB4ODIwOEY0QzEsIDB4RjUwRkM0NTcsXG4gICAgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCwgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMywgMHhGQkQ0NEM2NSxcbiAgICAweDREQjI2MTU4LCAweDNBQjU1MUNFLCAweEEzQkMwMDc0LCAweEQ0QkIzMEUyLCAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLFxuICAgIDB4NDM2OUU5NkEsIDB4MzQ2RUQ5RkMsIDB4QUQ2Nzg4NDYsIDB4REE2MEI4RDAsIDB4NDQwNDJENzMsIDB4MzMwMzFERTUsIDB4QUEwQTRDNUYsIDB4REQwRDdDQzksXG4gICAgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCwgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RixcbiAgICAweDVFREVGOTBFLCAweDI5RDlDOTk4LCAweEIwRDA5ODIyLCAweEM3RDdBOEI0LCAweDU5QjMzRDE3LCAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELFxuICAgIDB4RURCODgzMjAsIDB4OUFCRkIzQjYsIDB4MDNCNkUyMEMsIDB4NzRCMUQyOUEsIDB4RUFENTQ3MzksIDB4OUREMjc3QUYsIDB4MDREQjI2MTUsIDB4NzNEQzE2ODMsXG4gICAgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCwgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSxcbiAgICAweEYwMEY5MzQ0LCAweDg3MDhBM0QyLCAweDFFMDFGMjY4LCAweDY5MDZDMkZFLCAweEY3NjI1NzVELCAweDgwNjU2N0NCLCAweDE5NkMzNjcxLCAweDZFNkIwNkU3LFxuICAgIDB4RkVENDFCNzYsIDB4ODlEMzJCRTAsIDB4MTBEQTdBNUEsIDB4NjdERDRBQ0MsIDB4RjlCOURGNkYsIDB4OEVCRUVGRjksIDB4MTdCN0JFNDMsIDB4NjBCMDhFRDUsXG4gICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSwgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QixcbiAgICAweEQ4MEQyQkRBLCAweEFGMEExQjRDLCAweDM2MDM0QUY2LCAweDQxMDQ3QTYwLCAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLCAweDQ2NjlCRTc5LFxuICAgIDB4Q0I2MUIzOEMsIDB4QkM2NjgzMUEsIDB4MjU2RkQyQTAsIDB4NTI2OEUyMzYsIDB4Q0MwQzc3OTUsIDB4QkIwQjQ3MDMsIDB4MjIwMjE2QjksIDB4NTUwNTI2MkYsXG4gICAgMHhDNUJBM0JCRSwgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSwgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCxcbiAgICAweDlCNjRDMkIwLCAweEVDNjNGMjI2LCAweDc1NkFBMzlDLCAweDAyNkQ5MzBBLCAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAgIDB4OTVCRjRBODIsIDB4RTJCODdBMTQsIDB4N0JCMTJCQUUsIDB4MENCNjFCMzgsIDB4OTJEMjhFOUIsIDB4RTVENUJFMEQsIDB4N0NEQ0VGQjcsIDB4MEJEQkRGMjEsXG4gICAgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MiwgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSwgMHgxOEI3NDc3NyxcbiAgICAweDg4MDg1QUU2LCAweEZGMEY2QTcwLCAweDY2MDYzQkNBLCAweDExMDEwQjVDLCAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LFxuICAgIDB4QTAwQUUyNzgsIDB4RDcwREQyRUUsIDB4NEUwNDgzNTQsIDB4MzkwM0IzQzIsIDB4QTc2NzI2NjEsIDB4RDA2MDE2RjcsIDB4NDk2OTQ3NEQsIDB4M0U2RTc3REIsXG4gICAgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NiwgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSxcbiAgICAweEJEQkRGMjFDLCAweENBQkFDMjhBLCAweDUzQjM5MzMwLCAweDI0QjRBM0E2LCAweEJBRDAzNjA1LCAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLFxuICAgIDB4QjM2NjdBMkUsIDB4QzQ2MTRBQjgsIDB4NUQ2ODFCMDIsIDB4MkE2RjJCOTQsIDB4QjQwQkJFMzcsIDB4QzMwQzhFQTEsIDB4NUEwNURGMUIsIDB4MkQwMkVGOERcbl07XG5mdW5jdGlvbiBjcmMzMihkYXRhLCBjcmMpIHtcbiAgICBpZiAoY3JjID09PSB2b2lkIDApIHsgY3JjID0gMDsgfVxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIENSQzMyVEFCTEVbKGNyYyBeIGRhdGFbaV0pICYgMHhGRl07XG4gICAgfVxuICAgIHJldHVybiBjcmMgXiAoLTEpO1xufVxuZXhwb3J0cy5jcmMzMiA9IGNyYzMyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBpbmRleC50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQGhwcm9zZS9ycGMtY29yZSBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRmViIDE2LCAyMDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xpZW50XzEgPSByZXF1aXJlKFwiLi9DbGllbnRcIik7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudF8xLkNsaWVudDtcbnZhciBDbGllbnRDb2RlY18xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29kZWNcIik7XG5leHBvcnRzLkRlZmF1bHRDbGllbnRDb2RlYyA9IENsaWVudENvZGVjXzEuRGVmYXVsdENsaWVudENvZGVjO1xudmFyIENsaWVudENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NsaWVudENvbnRleHRcIik7XG5leHBvcnRzLkNsaWVudENvbnRleHQgPSBDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dDtcbnZhciBDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9Db250ZXh0XCIpO1xuZXhwb3J0cy5Db250ZXh0ID0gQ29udGV4dF8xLkNvbnRleHQ7XG52YXIgQ29va2llTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQ29va2llTWFuYWdlclwiKTtcbmV4cG9ydHMuZ2V0Q29va2llID0gQ29va2llTWFuYWdlcl8xLmdldENvb2tpZTtcbmV4cG9ydHMuc2V0Q29va2llID0gQ29va2llTWFuYWdlcl8xLnNldENvb2tpZTtcbnZhciBEZWZlcnJlZF8xID0gcmVxdWlyZShcIi4vRGVmZXJyZWRcIik7XG5leHBvcnRzLmRlZmVyID0gRGVmZXJyZWRfMS5kZWZlcjtcbnZhciBQbHVnaW5NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9QbHVnaW5NYW5hZ2VyXCIpO1xuZXhwb3J0cy5QbHVnaW5NYW5hZ2VyID0gUGx1Z2luTWFuYWdlcl8xLlBsdWdpbk1hbmFnZXI7XG52YXIgSW52b2tlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW52b2tlTWFuYWdlclwiKTtcbmV4cG9ydHMuSW52b2tlTWFuYWdlciA9IEludm9rZU1hbmFnZXJfMS5JbnZva2VNYW5hZ2VyO1xudmFyIElPTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSU9NYW5hZ2VyXCIpO1xuZXhwb3J0cy5JT01hbmFnZXIgPSBJT01hbmFnZXJfMS5JT01hbmFnZXI7XG52YXIgTWV0aG9kXzEgPSByZXF1aXJlKFwiLi9NZXRob2RcIik7XG5leHBvcnRzLk1ldGhvZCA9IE1ldGhvZF8xLk1ldGhvZDtcbnZhciBNZXRob2RNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9NZXRob2RNYW5hZ2VyXCIpO1xuZXhwb3J0cy5NZXRob2RNYW5hZ2VyID0gTWV0aG9kTWFuYWdlcl8xLk1ldGhvZE1hbmFnZXI7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKFwiLi9UaW1lb3V0RXJyb3JcIik7XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcjtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5leHBvcnRzLnBhcnNlVVJJID0gVXRpbHNfMS5wYXJzZVVSSTtcbmV4cG9ydHMubm9ybWFsaXplID0gVXRpbHNfMS5ub3JtYWxpemU7XG5leHBvcnRzLnByb21pc2lmeSA9IFV0aWxzXzEucHJvbWlzaWZ5O1xuZXhwb3J0cy5jcmMzMiA9IFV0aWxzXzEuY3JjMzI7XG52YXIgU2VydmljZV8xID0gcmVxdWlyZShcIi4vU2VydmljZVwiKTtcbmV4cG9ydHMuU2VydmljZSA9IFNlcnZpY2VfMS5TZXJ2aWNlO1xudmFyIFNlcnZpY2VDb2RlY18xID0gcmVxdWlyZShcIi4vU2VydmljZUNvZGVjXCIpO1xuZXhwb3J0cy5EZWZhdWx0U2VydmljZUNvZGVjID0gU2VydmljZUNvZGVjXzEuRGVmYXVsdFNlcnZpY2VDb2RlYztcbnZhciBTZXJ2aWNlQ29udGV4dF8xID0gcmVxdWlyZShcIi4vU2VydmljZUNvbnRleHRcIik7XG5leHBvcnRzLlNlcnZpY2VDb250ZXh0ID0gU2VydmljZUNvbnRleHRfMS5TZXJ2aWNlQ29udGV4dDtcbnZhciBNb2NrSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vTW9ja0hhbmRsZXJcIik7XG5leHBvcnRzLk1vY2tTZXJ2ZXIgPSBNb2NrSGFuZGxlcl8xLk1vY2tTZXJ2ZXI7XG5leHBvcnRzLk1vY2tIYW5kbGVyID0gTW9ja0hhbmRsZXJfMS5Nb2NrSGFuZGxlcjtcbnZhciBNb2NrVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9Nb2NrVHJhbnNwb3J0XCIpO1xuZXhwb3J0cy5Nb2NrVHJhbnNwb3J0ID0gTW9ja1RyYW5zcG9ydF8xLk1vY2tUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEh0dHBIYW5kbGVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBIdHRwSGFuZGxlciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBNYXIgMjksIDIwMjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaHR0cCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cFwiKSk7XG52YXIgaHR0cHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImh0dHBzXCIpKTtcbnZhciBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG52YXIgZnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImZzXCIpKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgaW9fMSA9IHJlcXVpcmUoXCJAaHByb3NlL2lvXCIpO1xudmFyIGxhc3RNb2RpZmllZCA9IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpO1xudmFyIGV0YWcgPSAnXCInICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjE0NzQ4MzY0NykudG9TdHJpbmcoMTYpICtcbiAgICAnOicgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMTQ3NDgzNjQ3KS50b1N0cmluZygxNikgKyAnXCInO1xudmFyIEh0dHBIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBIYW5kbGVyKHNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5wM3AgPSB0cnVlO1xuICAgICAgICB0aGlzLmdldCA9IHRydWU7XG4gICAgICAgIHRoaXMuY3Jvc3NEb21haW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAzMDAwMDtcbiAgICAgICAgdGhpcy5odHRwSGVhZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3JpZ2lucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3JpZ2luQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9jcm9zc0RvbWFpblhtbEZpbGUgPSAnJztcbiAgICAgICAgdGhpcy5fY3Jvc3NEb21haW5YbWxDb250ZW50ID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLl9jbGllbnRBY2Nlc3NQb2xpY3lYbWxGaWxlID0gJyc7XG4gICAgICAgIHRoaXMuX2NsaWVudEFjY2Vzc1BvbGljeVhtbENvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCByZXNwb25zZSkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQsIHNpemU7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgcnBjX2NvcmVfMS5TZXJ2aWNlQ29udGV4dCh0aGlzLnNlcnZpY2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3RlQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZhbWlseSc6IHJlcXVlc3Quc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnOiByZXF1ZXN0LnNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAncG9ydCc6IHJlcXVlc3Quc29ja2V0LnJlbW90ZVBvcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRleHQubG9jYWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAnZmFtaWx5JzogbmV0XzEuaXNJUHY2KHJlcXVlc3Quc29ja2V0LmxvY2FsQWRkcmVzcykgPyAnSVB2NicgOiAnSVB2NCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRyZXNzJzogcmVxdWVzdC5zb2NrZXQubG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAncG9ydCc6IHJlcXVlc3Quc29ja2V0LmxvY2FsUG9ydFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udGV4dC5oYW5kbGVyID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb250ZXh0WydodHRwUmVxdWVzdEhlYWRlcnMnXSA9IHJlcXVlc3QuaGVhZGVycztcbiAgICAgICAgICAgICAgICBzaXplID0gTnVtYmVyKHJlcXVlc3QuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiB0aGlzLnNlcnZpY2UubWF4UmVxdWVzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID0gNDEzO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gJ1JlcXVlc3QgRW50aXR5IFRvbyBMYXJnZSc7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3kobmV3IHJwY19jb3JlXzEuVGltZW91dEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0cmVhbSA9IHNpemUgPyBuZXcgaW9fMS5CeXRlU3RyZWFtKHNpemUpIDogbmV3IGlvXzEuQnl0ZVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cmVhbS5sZW5ndGggKyBjaHVuay5sZW5ndGggPiBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub2ZmKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9IDQxMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSA9ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJlYW0ud3JpdGUobmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NsaWVudEFjY2Vzc1BvbGljeVhtbENvbnRlbnQubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jbGllbnRBY2Nlc3NQb2xpY3lYbWxIYW5kbGVyKHJlcXVlc3QsIHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc29sdmUoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nyb3NzRG9tYWluWG1sQ29udGVudC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNyb3NzRG9tYWluWG1sSGFuZGxlcihyZXF1ZXN0LCByZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNvbHZlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPSA0MDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gJ0ZvcmJpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzb2x2ZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlcnZpY2UuaGFuZGxlKGluc3RyZWFtLnRha2VCeXRlcygpLCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEhlYWRlcihyZXF1ZXN0LCByZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZWplY3QoZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZChyZXN1bHQsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jbG9zZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgfVxuICAgIEh0dHBIYW5kbGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgICBzZXJ2ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25lcnJvcilcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUuY3Jvc3NEb21haW5YbWxIYW5kbGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnVybCAmJiByZXF1ZXN0LnVybC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcvY3Jvc3Nkb21haW4ueG1sJykpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ10gPT09IGxhc3RNb2RpZmllZCAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddID09PSBldGFnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9IDMwNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNldEhlYWRlcignTGFzdC1Nb2RpZmllZCcsIGxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdFdGFnJywgZXRhZyk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgdGhpcy5fY3Jvc3NEb21haW5YbWxDb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGUodGhpcy5fY3Jvc3NEb21haW5YbWxDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgSHR0cEhhbmRsZXIucHJvdG90eXBlLmNsaWVudEFjY2Vzc1BvbGljeVhtbEhhbmRsZXIgPSBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QudXJsICYmIHJlcXVlc3QudXJsLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy9jbGllbnRhY2Nlc3Nwb2xpY3kueG1sJykpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ10gPT09IGxhc3RNb2RpZmllZCAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddID09PSBldGFnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9IDMwNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNldEhlYWRlcignTGFzdC1Nb2RpZmllZCcsIGxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdFdGFnJywgZXRhZyk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgdGhpcy5fY2xpZW50QWNjZXNzUG9saWN5WG1sQ29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHRoaXMuX2NsaWVudEFjY2Vzc1BvbGljeVhtbENvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhlYWRlcnNbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZXRIZWFkZXIobmFtZV8xLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUuc2VuZEhlYWRlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCByZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoJ2h0dHBTdGF0dXNDb2RlJyBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID0gTnVtYmVyKGNvbnRleHRbJ2h0dHBTdGF0dXNDb2RlJ10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9IDIwMDtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZS5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgIGlmICh0aGlzLnAzcCkge1xuICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdQM1AnLCAnQ1A9XCJDQU8gRFNQIENPUiBDVVIgQURNIERFViBUQUkgUFNBIFBTRCBJVkFpIElWRGkgJyArXG4gICAgICAgICAgICAgICAgJ0NPTmkgVEVMbyBPVFBpIE9VUiBERUxpIFNBTWkgT1RSaSBVTlJpIFBVQmkgSU5EIFBIWSBPTkwgJyArXG4gICAgICAgICAgICAgICAgJ1VOSSBQVVIgRklOIENPTSBOQVYgSU5UIERFTSBDTlQgU1RBIFBPTCBIRUEgUFJFIEdPVlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5fMSA9IHJlcXVlc3QuaGVhZGVyc1snb3JpZ2luJ107XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbl8xID09PSAnc3RyaW5nJyAmJiBvcmlnaW5fMSAhPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luQ291bnQgPT09IDAgfHwgdGhpcy5vcmlnaW5zW29yaWdpbl8xXSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZXRIZWFkZXIoJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsIG9yaWdpbl8xKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscycsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLCAnKicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKHJlc3BvbnNlLCB0aGlzLmh0dHBIZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIocmVzcG9uc2UsIGNvbnRleHRbJ2h0dHBSZXNwb25zZUhlYWRlcnMnXSk7XG4gICAgfTtcbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLnNldEhlYWRlcignQ29udGVudC1MZW5ndGgnLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLmVuZChCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCkpO1xuICAgIH07XG4gICAgSHR0cEhhbmRsZXIucHJvdG90eXBlLmFkZEFjY2Vzc0NvbnRyb2xBbGxvd09yaWdpbiA9IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbnNbb3JpZ2luXSkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5zW29yaWdpbl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5Db3VudCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdHRwSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlQWNjZXNzQ29udHJvbEFsbG93T3JpZ2luID0gZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zW29yaWdpbl0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9yaWdpbnNbb3JpZ2luXTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luQ291bnQtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0dHBIYW5kbGVyLnByb3RvdHlwZSwgXCJjcm9zc0RvbWFpblhtbEZpbGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcm9zc0RvbWFpblhtbEZpbGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcm9zc0RvbWFpblhtbEZpbGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nyb3NzRG9tYWluWG1sQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLl9jcm9zc0RvbWFpblhtbEZpbGUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHR0cEhhbmRsZXIucHJvdG90eXBlLCBcImNyb3NzRG9tYWluWG1sQ29udGVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzRG9tYWluWG1sQ29udGVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nyb3NzRG9tYWluWG1sRmlsZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fY3Jvc3NEb21haW5YbWxDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdHRwSGFuZGxlci5wcm90b3R5cGUsIFwiY2xpZW50QWNjZXNzUG9saWN5WG1sRmlsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudEFjY2Vzc1BvbGljeVhtbEZpbGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGllbnRBY2Nlc3NQb2xpY3lYbWxGaWxlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jbGllbnRBY2Nlc3NQb2xpY3lYbWxDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMuX2NsaWVudEFjY2Vzc1BvbGljeVhtbEZpbGUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHR0cEhhbmRsZXIucHJvdG90eXBlLCBcImNsaWVudEFjY2Vzc1BvbGljeVhtbENvbnRlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGllbnRBY2Nlc3NQb2xpY3lYbWxDb250ZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50QWNjZXNzUG9saWN5WG1sRmlsZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50QWNjZXNzUG9saWN5WG1sQ29udGVudCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIdHRwSGFuZGxlci5zZXJ2ZXJUeXBlcyA9IFtodHRwLlNlcnZlciwgaHR0cHMuU2VydmVyXTtcbiAgICByZXR1cm4gSHR0cEhhbmRsZXI7XG59KCkpO1xuZXhwb3J0cy5IdHRwSGFuZGxlciA9IEh0dHBIYW5kbGVyO1xucnBjX2NvcmVfMS5TZXJ2aWNlLnJlZ2lzdGVyKCdodHRwJywgSHR0cEhhbmRsZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHR0cEhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBIdHRwVHJhbnNwb3J0LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgSHR0cFRyYW5zcG9ydCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE3LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBodHRwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBodHRwcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIHJwY19jb3JlXzEgPSByZXF1aXJlKFwiQGhwcm9zZS9ycGMtY29yZVwiKTtcbnZhciBpb18xID0gcmVxdWlyZShcIkBocHJvc2UvaW9cIik7XG52YXIgSHR0cFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwVHJhbnNwb3J0KCkge1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLnJlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaHR0cFJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgSHR0cFRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChodHRwUmVxdWVzdEhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdGhpcy5odHRwUmVxdWVzdEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbbmFtZV8xXSA9IHRoaXMuaHR0cFJlcXVlc3RIZWFkZXJzW25hbWVfMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0dHBSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIGh0dHBSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV8yXSA9IGh0dHBSZXF1ZXN0SGVhZGVyc1tuYW1lXzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH07XG4gICAgSHR0cFRyYW5zcG9ydC5wcm90b3R5cGUudHJhbnNwb3J0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGNsaWVudCwgc2VjdXJlLCBrZXksIGh0dHBDb250ZXh0LCBjb29raWU7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmxfMS5wYXJzZShjb250ZXh0LnVyaSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudCA9IGh0dHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWdlbnQgPSB0aGlzLmh0dHBBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdodHRwczonOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50ID0gaHR0cHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hZ2VudCA9IHRoaXMuaHR0cHNBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCAnICsgb3B0aW9ucy5wcm90b2NvbCArICdwcm90b2NvbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkgfHwgdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0dHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldFJlcXVlc3RIZWFkZXIoaHR0cENvbnRleHQuaHR0cFJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSByZXF1ZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb29raWUgPSBycGNfY29yZV8xLmdldENvb2tpZShvcHRpb25zLmhvc3QsIG9wdGlvbnMucGF0aCwgc2VjdXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29va2llKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29va2llJ10gPSBjb29raWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gY2xpZW50LnJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RyZWFtID0gc2l6ZSA/IG5ldyBpb18xLkJ5dGVTdHJlYW0ocGFyc2VJbnQoc2l6ZSwgMTApKSA6IG5ldyBpb18xLkJ5dGVTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJlYW0ud3JpdGUobmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlcXVlc3RzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cENvbnRleHQuaHR0cFN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cENvbnRleHQuaHR0cFN0YXR1c1RleHQgPSByZXMuc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlcy5zdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cENvbnRleHQuaHR0cFJlc3BvbnNlSGVhZGVycyA9IHJlcy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY19jb3JlXzEuc2V0Q29va2llKHJlcy5oZWFkZXJzLCBvcHRpb25zLmhvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW5zdHJlYW0udGFrZUJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXMuc3RhdHVzQ29kZSArICc6JyArIHJlcy5zdGF0dXNNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoaW5zdHJlYW0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZXF1ZXN0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0c1tpbmRleF0gPSByZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuc2hvdWxkS2VlcEFsaXZlID0gX3RoaXMua2VlcEFsaXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNldFRpbWVvdXQoY29udGV4dC50aW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlcXVlc3RzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IHJwY19jb3JlXzEuVGltZW91dEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZXF1ZXN0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlcXVlc3RzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCd0cmFuc3BvcnQgYWJvcnQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5lbmQoQnVmZmVyLmZyb20ocmVxdWVzdC5idWZmZXIsIDAsIHJlcXVlc3QubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0dHBUcmFuc3BvcnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXgsIHJlcXVlc3Q7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0dHBUcmFuc3BvcnQuc2NoZW1lcyA9IFsnaHR0cCcsICdodHRwcyddO1xuICAgIHJldHVybiBIdHRwVHJhbnNwb3J0O1xufSgpKTtcbmV4cG9ydHMuSHR0cFRyYW5zcG9ydCA9IEh0dHBUcmFuc3BvcnQ7XG5ycGNfY29yZV8xLkNsaWVudC5yZWdpc3RlcignaHR0cCcsIEh0dHBUcmFuc3BvcnQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHR0cFRyYW5zcG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFNvY2tldEhhbmRsZXIudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTb2NrZXRIYW5kbGVyIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBEZWMgMTcsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xudmFyIGlvXzEgPSByZXF1aXJlKFwiQGhwcm9zZS9pb1wiKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgU29ja2V0SGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb2NrZXRIYW5kbGVyKHNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0LnVucmVmKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmFjY2VwdClcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25hY2NlcHQoc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jbG9zZShzb2NrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5yZWNlaXZlKHNvY2tldCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFNvY2tldEhhbmRsZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNlcnZlci5vbignY29ubmVjdGlvbicsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHNlcnZlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vbmVycm9yKVxuICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvY2tldEhhbmRsZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoc29ja2V0LCByZXNwb25zZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG4gPSByZXNwb25zZS5sZW5ndGg7XG4gICAgICAgIHZhciBoZWFkZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTIpO1xuICAgICAgICBoZWFkZXIud3JpdGVJbnQzMkJFKG4gfCAweDgwMDAwMDAwLCA0KTtcbiAgICAgICAgaGVhZGVyLndyaXRlSW50MzJCRShpbmRleCwgOCk7XG4gICAgICAgIHZhciBjcmMgPSBycGNfY29yZV8xLmNyYzMyKGhlYWRlci5zdWJhcnJheSg0LCAxMikpO1xuICAgICAgICBoZWFkZXIud3JpdGVJbnQzMkJFKGNyYywgMCk7XG4gICAgICAgIHNvY2tldC53cml0ZShoZWFkZXIpO1xuICAgICAgICBzb2NrZXQud3JpdGUoQnVmZmVyLmZyb20ocmVzcG9uc2UuYnVmZmVyLCByZXNwb25zZS5ieXRlT2Zmc2V0LCByZXNwb25zZS5sZW5ndGgpKTtcbiAgICB9O1xuICAgIFNvY2tldEhhbmRsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChzb2NrZXQsIHJlcXVlc3QsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCByZXNwb25zZSwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IG5ldyBycGNfY29yZV8xLlNlcnZpY2VDb250ZXh0KHRoaXMuc2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3RlQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFtaWx5Jzogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzcyc6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwb3J0Jzogc29ja2V0LnJlbW90ZVBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxvY2FsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFtaWx5JzogbmV0LmlzSVB2Nihzb2NrZXQubG9jYWxBZGRyZXNzKSA/ICdJUHY2JyA6ICdJUHY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzcyc6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BvcnQnOiBzb2NrZXQubG9jYWxQb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oYW5kbGVyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VydmljZS5oYW5kbGUocmVxdWVzdCwgY29udGV4dCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCB8PSAweDgwMDAwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAobmV3IGlvXzEuQnl0ZVN0cmVhbShlXzEubWVzc2FnZSkpLmJ5dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChzb2NrZXQsIHJlc3BvbnNlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29ja2V0SGFuZGxlci5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGluc3RyZWFtID0gbmV3IGlvXzEuQnl0ZVN0cmVhbSgpO1xuICAgICAgICB2YXIgaGVhZGVyTGVuZ3RoID0gMTI7XG4gICAgICAgIHZhciBib2R5TGVuZ3RoID0gLTE7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgaW5zdHJlYW0ud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGJvZHlMZW5ndGggPCAwKSAmJiAoaW5zdHJlYW0ubGVuZ3RoID49IGhlYWRlckxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNyYyA9IGluc3RyZWFtLnJlYWRJbnQzMkJFKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RyZWFtLm1hcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGluc3RyZWFtLnJlYWQoOCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycGNfY29yZV8xLmNyYzMyKGhlYWRlcikgIT09IGNyYyB8fCAoaGVhZGVyWzBdICYgMHg4MCkgPT09IDAgfHwgKGhlYWRlcls0XSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJlYW0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keUxlbmd0aCA9IGluc3RyZWFtLnJlYWRJbnQzMkJFKCkgJiAweDdGRkZGRkZGO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluc3RyZWFtLnJlYWRJbnQzMkJFKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoID4gX3RoaXMuc2VydmljZS5tYXhSZXF1ZXN0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZChzb2NrZXQsIChuZXcgaW9fMS5CeXRlU3RyZWFtKCdSZXF1ZXN0IGVudGl0eSB0b28gbGFyZ2UnKSkuYnl0ZXMsIGluZGV4IHwgMHg4MDAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChib2R5TGVuZ3RoID49IDApICYmICgoaW5zdHJlYW0ubGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKSA+PSBib2R5TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGluc3RyZWFtLnJlYWQoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RyZWFtLnRydW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlMZW5ndGggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKHNvY2tldCwgcmVxdWVzdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBvbmRhdGEpO1xuICAgIH07XG4gICAgU29ja2V0SGFuZGxlci5zZXJ2ZXJUeXBlcyA9IFtuZXQuU2VydmVyXTtcbiAgICByZXR1cm4gU29ja2V0SGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLlNvY2tldEhhbmRsZXIgPSBTb2NrZXRIYW5kbGVyO1xucnBjX2NvcmVfMS5TZXJ2aWNlLnJlZ2lzdGVyKCdzb2NrZXQnLCBTb2NrZXRIYW5kbGVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvY2tldEhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBTb2NrZXRUcmFuc3BvcnQudHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgU29ja2V0VHJhbnNwb3J0IGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE4LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5ldCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibmV0XCIpKTtcbnZhciB0bHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRsc1wiKSk7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIGlvXzEgPSByZXF1aXJlKFwiQGhwcm9zZS9pb1wiKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgU29ja2V0VHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvY2tldFRyYW5zcG9ydCgpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLm5vRGVsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcGFyc2VyID0gdXJsXzEucGFyc2UodXJpKTtcbiAgICAgICAgdmFyIHByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuICAgICAgICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgICAgICAgICBjYXNlICd0Y3A6JzpcbiAgICAgICAgICAgIGNhc2UgJ3RjcDQ6JzpcbiAgICAgICAgICAgIGNhc2UgJ3RjcDY6JzpcbiAgICAgICAgICAgIGNhc2UgJ3RsczonOlxuICAgICAgICAgICAgY2FzZSAndGxzNDonOlxuICAgICAgICAgICAgY2FzZSAndGxzNjonOlxuICAgICAgICAgICAgY2FzZSAnc3NsOic6XG4gICAgICAgICAgICBjYXNlICdzc2w0Oic6XG4gICAgICAgICAgICBjYXNlICdzc2w2Oic6IHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ob3N0ID0gKF9hID0gcGFyc2VyLmhvc3RuYW1lLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wb3J0ID0gcGFyc2VyLnBvcnQgPyBwYXJzZUludChwYXJzZXIucG9ydCwgMTApIDogODQxMjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RjcDQ6JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGxzNDonOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzc2w0Oic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmFtaWx5ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RjcDY6JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGxzNjonOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzc2w2Oic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmFtaWx5ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGNwOic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RjcDQ6JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGNwNjonOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsc09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5IHx8IHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRsc09wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bHMuY29ubmVjdCh0bHNPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3VuaXg6Jzoge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoID0gcGFyc2VyLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdW5peCBwYXRoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCAnICsgcHJvdG9jb2wgKyAnIHByb3RvY29sJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uICh1cmksIHNvY2tldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW5zdHJlYW0gPSBuZXcgaW9fMS5CeXRlU3RyZWFtKCk7XG4gICAgICAgIHZhciBoZWFkZXJMZW5ndGggPSAxMjtcbiAgICAgICAgdmFyIGJvZHlMZW5ndGggPSAtMTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBpbnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgoYm9keUxlbmd0aCA8IDApICYmIChpbnN0cmVhbS5sZW5ndGggPj0gaGVhZGVyTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JjID0gaW5zdHJlYW0ucmVhZEludDMyQkUoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJlYW0ubWFyaygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gaW5zdHJlYW0ucmVhZCg4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJwY19jb3JlXzEuY3JjMzIoaGVhZGVyKSAhPT0gY3JjIHx8IChoZWFkZXJbMF0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KG5ldyBFcnJvcignaW52YWxpZCByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cmVhbS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5TGVuZ3RoID0gaW5zdHJlYW0ucmVhZEludDMyQkUoKSAmIDB4N0ZGRkZGRkY7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5zdHJlYW0ucmVhZEludDMyQkUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChib2R5TGVuZ3RoID49IDApICYmICgoaW5zdHJlYW0ubGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKSA+PSBib2R5TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBpbnN0cmVhbS5yZWFkKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0cmVhbS50cnVuYygpO1xuICAgICAgICAgICAgICAgICAgICBib2R5TGVuZ3RoID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNfZXJyb3IgPSAoaW5kZXggJiAweDgwMDAwMDAwKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggJj0gMHg3RkZGRkZGRjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfdGhpcy5yZXN1bHRzLmdldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRXJyb3IoaW9fMS5mcm9tVWludDhBcnJheShyZXNwb25zZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIG9uZGF0YSk7XG4gICAgfTtcbiAgICBTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmdldFNvY2tldCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNvY2tldCwgY29ubiwgb25lcnJvcjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc29ja2V0c1t1cmldXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCAhPT0gdW5kZWZpbmVkICYmICFzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNvY2tldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uID0gcnBjX2NvcmVfMS5kZWZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gdGhpcy5jb25uZWN0KHVyaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRoaXMubm9EZWxheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRoaXMua2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uLnJlc29sdmUoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlKHVyaSwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cywgaW5kZXgsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5yZXN1bHRzLmdldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNvY2tldHNbdXJpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9hLnNlbnQoKSkgPT09IHNvY2tldCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc29ja2V0c1t1cmldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2Euc2VudCgpKS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ja2V0c1t1cmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbiAoaGFkX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhZF9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IobmV3IEVycm9yKCdjb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzW3VyaV0gPSBjb25uLnByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY29ubi5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnRyYW5zcG9ydCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmksIGluZGV4LCByZXN1bHQsIHNvY2tldCwgcmVzdWx0cywgdGltZW91dElkXzEsIG4sIGhlYWRlciwgY3JjO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpID0gY29udGV4dC51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9ICh0aGlzLmNvdW50ZXIgPCAweDdGRkZGRkZGKSA/ICsrdGhpcy5jb3VudGVyIDogdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJwY19jb3JlXzEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0U29ja2V0KHVyaSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzLmdldChzb2NrZXQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuc2V0KHNvY2tldCwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5yZXN1bHRzLmdldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZF8xID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgcnBjX2NvcmVfMS5UaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gcmVxdWVzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLndyaXRlSW50MzJCRShuIHwgMHg4MDAwMDAwMCwgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIud3JpdGVJbnQzMkJFKGluZGV4LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYyA9IHJwY19jb3JlXzEuY3JjMzIoaGVhZGVyLnN1YmFycmF5KDQsIDEyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIud3JpdGVJbnQzMkJFKGNyYywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQud3JpdGUoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC53cml0ZShCdWZmZXIuZnJvbShyZXF1ZXN0LmJ1ZmZlciwgcmVxdWVzdC5ieXRlT2Zmc2V0LCByZXF1ZXN0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfaSwgdXJpLCBzb2NrZXQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfYiBpbiB0aGlzLnNvY2tldHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EucHVzaChfYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSB0aGlzLnNvY2tldHNbdXJpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvY2tldHNbdXJpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc29ja2V0KSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNvY2tldF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYy5zZW50KCkpLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvY2tldFRyYW5zcG9ydC5zY2hlbWVzID0gWyd0Y3AnLCAndGNwNCcsICd0Y3A2JywgJ3RscycsICd0bHM0JywgJ3RsczYnLCAnc3NsJywgJ3NzbDQnLCAnc3NsNicsICd1bml4J107XG4gICAgcmV0dXJuIFNvY2tldFRyYW5zcG9ydDtcbn0oKSk7XG5leHBvcnRzLlNvY2tldFRyYW5zcG9ydCA9IFNvY2tldFRyYW5zcG9ydDtcbnJwY19jb3JlXzEuQ2xpZW50LnJlZ2lzdGVyKCdzb2NrZXQnLCBTb2NrZXRUcmFuc3BvcnQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29ja2V0VHJhbnNwb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVWRwSGFuZGxlci50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFVkcEhhbmRsZXIgZm9yIFR5cGVTY3JpcHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IERlYyAxNywgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZ3JhbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZGdyYW1cIikpO1xudmFyIHJwY19jb3JlXzEgPSByZXF1aXJlKFwiQGhwcm9zZS9ycGMtY29yZVwiKTtcbnZhciBpb18xID0gcmVxdWlyZShcIkBocHJvc2UvaW9cIik7XG52YXIgVWRwSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVZHBIYW5kbGVyKHNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1zZywgcmluZm8pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3JjLCBoZWFkZXIsIGJvZHlMZW5ndGgsIGluZGV4LCByZXF1ZXN0LCBjb250ZXh0LCByZXNwb25zZSwgZV8xO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyYyA9IG1zZy5yZWFkSW50MzJCRSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBtc2cuc3ViYXJyYXkoNCwgOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJwY19jb3JlXzEuY3JjMzIoaGVhZGVyKSAhPT0gY3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUxlbmd0aCA9IG1zZy5yZWFkVUludDE2QkUoNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtc2cucmVhZFVJbnQxNkJFKDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoICE9PSBtc2cubGVuZ3RoIC0gOCB8fCAoaW5kZXggJiAweDgwMDApICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlMZW5ndGggPiB0aGlzLnNlcnZpY2UubWF4UmVxdWVzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoc29ja2V0LCBCdWZmZXIuZnJvbSgnUmVxdWVzdCBlbnRpdHkgdG9vIGxhcmdlJyksIGluZGV4IHwgMHg4MDAwLCByaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBVaW50OEFycmF5KG1zZy5idWZmZXIsIG1zZy5ieXRlT2Zmc2V0ICsgOCwgYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IG5ldyBycGNfY29yZV8xLlNlcnZpY2VDb250ZXh0KHRoaXMuc2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdGVBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFtaWx5JzogcmluZm8uZmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzcyc6IHJpbmZvLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwb3J0JzogcmluZm8ucG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2NhbEFkZHJlc3MgPSBzb2NrZXQuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGFuZGxlciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZXJ2aWNlLmhhbmRsZShyZXF1ZXN0LCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IHw9IDB4ODAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IChuZXcgaW9fMS5CeXRlU3RyZWFtKGVfMS5tZXNzYWdlKSkuYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHNvY2tldCwgQnVmZmVyLmZyb20ocmVzcG9uc2UuYnVmZmVyLCByZXNwb25zZS5ieXRlT2Zmc2V0LCByZXNwb25zZS5sZW5ndGgpLCBpbmRleCwgcmluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jbG9zZShzb2NrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFVkcEhhbmRsZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoc29ja2V0LCBib2R5LCBpbmRleCwgcmluZm8pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG4gPSBib2R5Lmxlbmd0aDtcbiAgICAgICAgdmFyIGhlYWRlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4KTtcbiAgICAgICAgaGVhZGVyLndyaXRlVUludDE2QkUobiwgNCk7XG4gICAgICAgIGhlYWRlci53cml0ZVVJbnQxNkJFKGluZGV4LCA2KTtcbiAgICAgICAgdmFyIGNyYyA9IHJwY19jb3JlXzEuY3JjMzIobmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ1ZmZlciwgaGVhZGVyLmJ5dGVPZmZzZXQgKyA0LCA0KSk7XG4gICAgICAgIGhlYWRlci53cml0ZUludDMyQkUoY3JjLCAwKTtcbiAgICAgICAgc29ja2V0LnNlbmQoW2hlYWRlciwgYm9keV0sIHJpbmZvLnBvcnQsIHJpbmZvLmFkZHJlc3MsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIF90aGlzLm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVWRwSGFuZGxlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyKHNvY2tldCk7XG4gICAgfTtcbiAgICBVZHBIYW5kbGVyLnNlcnZlclR5cGVzID0gW2RncmFtLlNvY2tldF07XG4gICAgcmV0dXJuIFVkcEhhbmRsZXI7XG59KCkpO1xuZXhwb3J0cy5VZHBIYW5kbGVyID0gVWRwSGFuZGxlcjtcbnJwY19jb3JlXzEuU2VydmljZS5yZWdpc3RlcigndWRwJywgVWRwSGFuZGxlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VZHBIYW5kbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgVWRwVHJhbnNwb3J0LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFVkcFRyYW5zcG9ydCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IERlYyAxOCwgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZ3JhbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZGdyYW1cIikpO1xudmFyIHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgaW9fMSA9IHJlcXVpcmUoXCJAaHByb3NlL2lvXCIpO1xudmFyIFVkcFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVZHBUcmFuc3BvcnQoKSB7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgVWRwVHJhbnNwb3J0LnByb3RvdHlwZS5nZXRTb2NrZXQgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzb2NrZXQsIHVkcCwgcGFyc2VyLCBwcm90b2NvbCwgdHlwZSwgb25lcnJvcjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc29ja2V0c1t1cmldXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNvY2tldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZHAgPSBycGNfY29yZV8xLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIgPSB1cmxfMS5wYXJzZSh1cmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3VkcDQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VkcDonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VkcDQ6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndWRwNjonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3VkcDYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkICcgKyBwcm90b2NvbCArICcgcHJvdG9jb2wnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldCA9IGRncmFtLmNyZWF0ZVNvY2tldCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdsaXN0ZW5pbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWRwLnJlc29sdmUoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmMsIGhlYWRlciwgYm9keUxlbmd0aCwgaW5kZXgsIGhhc19lcnJvciwgcmVzcG9uc2UsIHJlc3VsdHMsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyYyA9IG1zZy5yZWFkSW50MzJCRSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbXNnLnN1YmFycmF5KDQsIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnBjX2NvcmVfMS5jcmMzMihoZWFkZXIpICE9PSBjcmMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlMZW5ndGggPSBtc2cucmVhZFVJbnQxNkJFKDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUxlbmd0aCAhPT0gbXNnLmxlbmd0aCAtIDgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbXNnLnJlYWRVSW50MTZCRSg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2Vycm9yID0gKGluZGV4ICYgMHg4MDAwKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggJj0gMHg3RkZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KG1zZy5idWZmZXIsIG1zZy5ieXRlT2Zmc2V0ICsgOCwgYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZ2V0KHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEVycm9yKGlvXzEuZnJvbVVpbnQ4QXJyYXkocmVzcG9uc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cywgaW5kZXgsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5yZXN1bHRzLmdldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNvY2tldHNbdXJpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYS5zZW50KCkpID09PSBzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ja2V0c1t1cmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9uZXJyb3IobmV3IEVycm9yKCdjbG9zZWQnKSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0c1t1cmldID0gdWRwLnByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdWRwLnByb21pc2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVkcFRyYW5zcG9ydC5wcm90b3R5cGUudHJhbnNwb3J0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJpLCBpbmRleCwgcmVzdWx0LCBzb2NrZXQsIHJlc3VsdHMsIHRpbWVvdXRJZF8xLCBwYXJzZXIsIG4sIGhlYWRlciwgY3JjLCBib2R5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubGVuZ3RoID4gNjU0OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3QgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmkgPSBjb250ZXh0LnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gKHRoaXMuY291bnRlciA8IDB4N0ZGRikgPyArK3RoaXMuY291bnRlciA6IHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBycGNfY29yZV8xLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFNvY2tldCh1cmkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0cy5nZXQoc29ja2V0KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChzb2NrZXQsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHRoaXMucmVzdWx0cy5nZXQoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWRfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IHJwY19jb3JlXzEuVGltZW91dEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbnRleHQudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyID0gdXJsXzEucGFyc2UodXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZXF1ZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci53cml0ZVVJbnQxNkJFKG4sIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLndyaXRlVUludDE2QkUoaW5kZXgsIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JjID0gcnBjX2NvcmVfMS5jcmMzMihuZXcgVWludDhBcnJheShoZWFkZXIuYnVmZmVyLCBoZWFkZXIuYnl0ZU9mZnNldCArIDQsIDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci53cml0ZUludDMyQkUoY3JjLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShyZXF1ZXN0LmJ1ZmZlciwgcmVxdWVzdC5ieXRlT2Zmc2V0LCByZXF1ZXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChbaGVhZGVyLCBib2R5XSwgcGFyc2VyLnBvcnQgPyBwYXJzZUludChwYXJzZXIucG9ydCwgMTApIDogODQxMiwgKF9hID0gcGFyc2VyLmhvc3RuYW1lLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVZHBUcmFuc3BvcnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfaSwgdXJpLCBzb2NrZXQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfYiBpbiB0aGlzLnNvY2tldHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EucHVzaChfYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSB0aGlzLnNvY2tldHNbdXJpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvY2tldHNbdXJpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc29ja2V0KSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNvY2tldF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYy5zZW50KCkpLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVWRwVHJhbnNwb3J0LnNjaGVtZXMgPSBbJ3VkcCcsICd1ZHA0JywgJ3VkcDYnXTtcbiAgICByZXR1cm4gVWRwVHJhbnNwb3J0O1xufSgpKTtcbmV4cG9ydHMuVWRwVHJhbnNwb3J0ID0gVWRwVHJhbnNwb3J0O1xucnBjX2NvcmVfMS5DbGllbnQucmVnaXN0ZXIoJ3VkcCcsIFVkcFRyYW5zcG9ydCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VZHBUcmFuc3BvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxcXG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgIGhwcm9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IE9mZmljaWFsIFdlYlNpdGU6IGh0dHBzOi8vaHByb3NlLmNvbSAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBXZWJTb2NrZXRIYW5kbGVyLnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgV2ViU29ja2V0SGFuZGxlciBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IExhc3RNb2RpZmllZDogRGVjIDE3LCAyMDE5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgQXV0aG9yOiBNYSBCaW5neWFvIDxhbmRvdEBocHJvc2UuY29tPiAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cXCpfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndzXCIpKTtcbnZhciBodHRwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBodHRwcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgaW9fMSA9IHJlcXVpcmUoXCJAaHByb3NlL2lvXCIpO1xudmFyIFdlYlNvY2tldEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0SGFuZGxlcihzZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKHdlYnNvY2tldCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQucHJvdG9jb2wgPSAnaHByb3NlJztcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uYWNjZXB0KVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmFjY2VwdCh3ZWJzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdlYnNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY2xvc2UpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uY2xvc2Uod2Vic29ja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2Vic29ja2V0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmVycm9yKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2Vic29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdHJlYW0sIGluZGV4LCBjb250ZXh0LCByZXNwb25zZSwgZV8xLCBoZWFkZXI7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cmVhbSA9IG5ldyBpb18xLkJ5dGVTdHJlYW0oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbnN0cmVhbS5yZWFkSW50MzJCRSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgcnBjX2NvcmVfMS5TZXJ2aWNlQ29udGV4dCh0aGlzLnNlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdGVBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFtaWx5JzogcmVxdWVzdC5zb2NrZXQucmVtb3RlRmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzcyc6IHJlcXVlc3Quc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwb3J0JzogcmVxdWVzdC5zb2NrZXQucmVtb3RlUG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2NhbEFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYW1pbHknOiBuZXRfMS5pc0lQdjYocmVxdWVzdC5zb2NrZXQubG9jYWxBZGRyZXNzKSA/ICdJUHY2JyA6ICdJUHY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnOiByZXF1ZXN0LnNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwb3J0JzogcmVxdWVzdC5zb2NrZXQubG9jYWxQb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhhbmRsZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VydmljZS5oYW5kbGUoaW5zdHJlYW0ucmVtYWlucywgY29udGV4dCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCB8PSAweDgwMDAwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gKG5ldyBpb18xLkJ5dGVTdHJlYW0oZV8xLm1lc3NhZ2UpKS5ieXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpb18xLndyaXRlSW50MzJCRShoZWFkZXIsIDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuc2VuZChoZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzczogdGhpcy5jb21wcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vic29ja2V0LnNlbmQocmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzczogdGhpcy5jb21wcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBXZWJTb2NrZXRIYW5kbGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc2VydmVyIGluc3RhbmNlb2YgaHR0cC5TZXJ2ZXIgfHwgc2VydmVyIGluc3RhbmNlb2YgaHR0cHMuU2VydmVyKSB7XG4gICAgICAgICAgICBzZXJ2ZXIgPSBuZXcgd3NfMS5kZWZhdWx0LlNlcnZlcih7IHNlcnZlcjogc2VydmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlcnZlci5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2U7XG4gICAgICAgIHNlcnZlci5vcHRpb25zLm1heFBheWxvYWQgPSB0aGlzLnNlcnZpY2UubWF4UmVxdWVzdExlbmd0aCArIDQ7XG4gICAgICAgIHNlcnZlci5vbignY29ubmVjdGlvbicsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHNlcnZlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vbmVycm9yKVxuICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldEhhbmRsZXIuc2VydmVyVHlwZXMgPSBbaHR0cC5TZXJ2ZXIsIGh0dHBzLlNlcnZlciwgd3NfMS5kZWZhdWx0LlNlcnZlcl07XG4gICAgcmV0dXJuIFdlYlNvY2tldEhhbmRsZXI7XG59KCkpO1xuZXhwb3J0cy5XZWJTb2NrZXRIYW5kbGVyID0gV2ViU29ja2V0SGFuZGxlcjtcbnJwY19jb3JlXzEuU2VydmljZS5yZWdpc3Rlcignd2Vic29ja2V0JywgV2ViU29ja2V0SGFuZGxlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJTb2NrZXRIYW5kbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcXFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICBocHJvc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBPZmZpY2lhbCBXZWJTaXRlOiBodHRwczovL2hwcm9zZS5jb20gICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgV2ViU29ja2V0VHJhbnNwb3J0LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IFdlYlNvY2tldFRyYW5zcG9ydCBmb3IgVHlwZVNjcmlwdC4gICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBMYXN0TW9kaWZpZWQ6IERlYyAxNywgMjAxOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IEF1dGhvcjogTWEgQmluZ3lhbyA8YW5kb3RAaHByb3NlLmNvbT4gICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuXFwqX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBodHRwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBodHRwcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIHdzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndzXCIpKTtcbnZhciBycGNfY29yZV8xID0gcmVxdWlyZShcIkBocHJvc2UvcnBjLWNvcmVcIik7XG52YXIgaW9fMSA9IHJlcXVpcmUoXCJAaHByb3NlL2lvXCIpO1xudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoKSB7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5odHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5odHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlYnNvY2tldCwgd3MsIG9uZXJyb3I7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLndlYnNvY2tldHNbdXJpXV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWJzb2NrZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSB3c18xLmRlZmF1bHQuQ0xPU0lOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSB3c18xLmRlZmF1bHQuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHdlYnNvY2tldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3cyA9IHJwY19jb3JlXzEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByb3RvY29sID0gJ2hwcm9zZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFnZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWdlbnQgPSB0aGlzLmh0dHBzQWdlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWdlbnQgPSB0aGlzLmh0dHBBZ2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJzb2NrZXQgPSBuZXcgd3NfMS5kZWZhdWx0KHVyaSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldC5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cy5yZXNvbHZlKHdlYnNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RyZWFtLCBpbmRleCwgcmVzcG9uc2UsIGhhc19lcnJvciwgcmVzdWx0cywgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJlYW0gPSBuZXcgaW9fMS5CeXRlU3RyZWFtKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluc3RyZWFtLnJlYWRJbnQzMkJFKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gaW5zdHJlYW0ucmVtYWlucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2Vycm9yID0gKGluZGV4ICYgMHg4MDAwMDAwMCkgIT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICY9IDB4N0ZGRkZGRkY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZ2V0KHdlYnNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEVycm9yKGlvXzEuZnJvbVVpbnQ4QXJyYXkocmVzcG9uc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cywgaW5kZXgsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5yZXN1bHRzLmdldCh3ZWJzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLndlYnNvY2tldHNbdXJpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYS5zZW50KCkpID09PSB3ZWJzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vic29ja2V0c1t1cmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Vic29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Vic29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IobmV3IEVycm9yKGNvZGUgKyBcIjpcIiArIHJlYXNvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcihuZXcgRXJyb3IoXCJcIiArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0c1t1cmldID0gd3MucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB3cy5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnRyYW5zcG9ydCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmksIGluZGV4LCByZXN1bHQsIHdlYnNvY2tldCwgcmVzdWx0cywgdGltZW91dElkXzEsIGhlYWRlcjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaSA9IGNvbnRleHQudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAodGhpcy5jb3VudGVyIDwgMHg3RkZGRkZGRikgPyArK3RoaXMuY291bnRlciA6IHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBycGNfY29yZV8xLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNvbm5lY3QodXJpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHMuZ2V0KHdlYnNvY2tldCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5zZXQod2Vic29ja2V0LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZ2V0KHdlYnNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dElkXzEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBycGNfY29yZV8xLlRpbWVvdXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb250ZXh0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW9fMS53cml0ZUludDMyQkUoaGVhZGVyLCAwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuc2VuZChoZWFkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3M6IHRoaXMuY29tcHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Vic29ja2V0LnNlbmQocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzczogdGhpcy5jb21wcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LnByb21pc2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9pLCB1cmksIHdlYnNvY2tldDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9iIGluIHRoaXMud2Vic29ja2V0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5wdXNoKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBfYS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYnNvY2tldCA9IHRoaXMud2Vic29ja2V0c1t1cmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vic29ja2V0c1t1cmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3ZWJzb2NrZXQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2Vic29ja2V0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgKF9jLnNlbnQoKSkuY2xvc2UoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnNjaGVtZXMgPSBbJ3dzJywgJ3dzcyddO1xuICAgIHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59KCkpO1xuZXhwb3J0cy5XZWJTb2NrZXRUcmFuc3BvcnQgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5ycGNfY29yZV8xLkNsaWVudC5yZWdpc3Rlcignd2Vic29ja2V0JywgV2ViU29ja2V0VHJhbnNwb3J0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlNvY2tldFRyYW5zcG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXFxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgaHByb3NlICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgT2ZmaWNpYWwgV2ViU2l0ZTogaHR0cHM6Ly9ocHJvc2UuY29tICAgICAgICAgICAgICAgICAgICAgfFxufCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG58IGluZGV4LnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBAaHByb3NlL3JwYy1ub2RlIGZvciBUeXBlU2NyaXB0LiAgICAgICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbnwgTGFzdE1vZGlmaWVkOiBGZWIgMjcsIDIwMTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxufCBBdXRob3I6IE1hIEJpbmd5YW8gPGFuZG90QGhwcm9zZS5jb20+ICAgICAgICAgICAgICAgICAgICB8XG58ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcblxcKl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBIdHRwVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9IdHRwVHJhbnNwb3J0XCIpO1xuZXhwb3J0cy5IdHRwVHJhbnNwb3J0ID0gSHR0cFRyYW5zcG9ydF8xLkh0dHBUcmFuc3BvcnQ7XG52YXIgV2ViU29ja2V0VHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9XZWJTb2NrZXRUcmFuc3BvcnRcIik7XG5leHBvcnRzLldlYlNvY2tldFRyYW5zcG9ydCA9IFdlYlNvY2tldFRyYW5zcG9ydF8xLldlYlNvY2tldFRyYW5zcG9ydDtcbnZhciBTb2NrZXRUcmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL1NvY2tldFRyYW5zcG9ydFwiKTtcbmV4cG9ydHMuU29ja2V0VHJhbnNwb3J0ID0gU29ja2V0VHJhbnNwb3J0XzEuU29ja2V0VHJhbnNwb3J0O1xudmFyIFVkcFRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vVWRwVHJhbnNwb3J0XCIpO1xuZXhwb3J0cy5VZHBUcmFuc3BvcnQgPSBVZHBUcmFuc3BvcnRfMS5VZHBUcmFuc3BvcnQ7XG52YXIgSHR0cEhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL0h0dHBIYW5kbGVyXCIpO1xuZXhwb3J0cy5IdHRwSGFuZGxlciA9IEh0dHBIYW5kbGVyXzEuSHR0cEhhbmRsZXI7XG52YXIgV2ViU29ja2V0SGFuZGxlcl8xID0gcmVxdWlyZShcIi4vV2ViU29ja2V0SGFuZGxlclwiKTtcbmV4cG9ydHMuV2ViU29ja2V0SGFuZGxlciA9IFdlYlNvY2tldEhhbmRsZXJfMS5XZWJTb2NrZXRIYW5kbGVyO1xudmFyIFNvY2tldEhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL1NvY2tldEhhbmRsZXJcIik7XG5leHBvcnRzLlNvY2tldEhhbmRsZXIgPSBTb2NrZXRIYW5kbGVyXzEuU29ja2V0SGFuZGxlcjtcbnZhciBVZHBIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9VZHBIYW5kbGVyXCIpO1xuZXhwb3J0cy5VZHBIYW5kbGVyID0gVWRwSGFuZGxlcl8xLlVkcEhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBjb3JlIC1vIC4vZGlzdC9sb2Rhc2guY29yZS5qc2BcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMTUnO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHZhbHVlcyk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYmFzZU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgKiBvZiB2YWx1ZXMuXG4gICAqL1xuICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgdmFyIG5hdGl2ZUlzRmluaXRlID0gcm9vdC5pc0Zpbml0ZSxcbiAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICpcbiAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgKlxuICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgKlxuICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgKlxuICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgKlxuICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAqXG4gICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICpcbiAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICpcbiAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICpcbiAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICpcbiAgICogQG5hbWUgX1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGNhdGVnb3J5IFNlcVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgKiAgIHJldHVybiBuICogbjtcbiAgICogfVxuICAgKlxuICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICpcbiAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICogLy8gPT4gNlxuICAgKlxuICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgKlxuICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyXG4gICAgICA/IHZhbHVlXG4gICAgICA6IG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAqL1xuICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgfVxuXG4gIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShsb2Rhc2gucHJvdG90eXBlKTtcbiAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAqL1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAqIHZhbHVlIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICovXG4gIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYFxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWZhbHNlKVxuICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqL1xuICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYmFzZUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqL1xuICB2YXIgYmFzZUlzQXJndW1lbnRzID0gbm9vcDtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGJhc2VHZXRUYWcob2JqZWN0KSxcbiAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGJhc2VHZXRUYWcob3RoZXIpO1xuXG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBbXSk7XG4gICAgdmFyIG9ialN0YWNrID0gZmluZChzdGFjaywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeVswXSA9PSBvYmplY3Q7XG4gICAgfSk7XG4gICAgdmFyIG90aFN0YWNrID0gZmluZChzdGFjaywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeVswXSA9PSBvdGhlcjtcbiAgICB9KTtcbiAgICBpZiAob2JqU3RhY2sgJiYgb3RoU3RhY2spIHtcbiAgICAgIHJldHVybiBvYmpTdGFja1sxXSA9PSBvdGhlcjtcbiAgICB9XG4gICAgc3RhY2sucHVzaChbb2JqZWN0LCBvdGhlcl0pO1xuICAgIHN0YWNrLnB1c2goW290aGVyLCBvYmplY3RdKTtcbiAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgdmFyIHJlc3VsdCA9IChvYmpJc0FycilcbiAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUoZnVuYykge1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH1cbiAgICByZXR1cm4gKHR5cGVvZiBmdW5jID09ICdvYmplY3QnID8gYmFzZU1hdGNoZXMgOiBiYXNlUHJvcGVydHkpKGZ1bmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgIHZhciBwcm9wcyA9IG5hdGl2ZUtleXMoc291cmNlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF07XG4gICAgICAgIGlmICghKGtleSBpbiBvYmplY3QgJiZcbiAgICAgICAgICAgICAgYmFzZUlzRXF1YWwoc291cmNlW2tleV0sIG9iamVjdFtrZXldLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHByb3BzKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuIHJlZHVjZShwcm9wcywgZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgfVxuICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICB9XG4gICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlKSB7XG4gICAgcmV0dXJuIGJhc2VTbGljZShzb3VyY2UsIDAsIHNvdXJjZS5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gZmFsc2U7XG5cbiAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgIG90aElzU3ltYm9sID0gZmFsc2U7XG5cbiAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05ldykge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICB9XG4gICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gW10gOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgdmFyIGNvbXBhcmVkO1xuICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIGlmICghYmFzZVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICBpZiAoIWluZGV4T2Yoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcblxuICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgdmFyIGNvbXBhcmVkO1xuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICB9XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICovXG4gIHZhciBzZXRUb1N0cmluZyA9IGlkZW50aXR5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgcmV0dXJuIGJhc2VGaWx0ZXIoYXJyYXksIEJvb2xlYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAqIGFuZC9vciB2YWx1ZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICpcbiAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgKlxuICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAqIC8vID0+IFsxXVxuICAgKi9cbiAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IEFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHVzZXJzID0gW1xuICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAqIC8vID0+IDBcbiAgICpcbiAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICogLy8gPT4gMVxuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAqIC8vID0+IDBcbiAgICpcbiAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAqIC8vID0+IDJcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQGNhdGVnb3J5IEFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAqL1xuICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGFsaWFzIGZpcnN0XG4gICAqIEBjYXRlZ29yeSBBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAxXG4gICAqXG4gICAqIF8uaGVhZChbXSk7XG4gICAqIC8vID0+IHVuZGVmaW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgKiAvLyA9PiAxXG4gICAqXG4gICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAqIC8vID0+IDNcbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IGZyb21JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGlzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICgoaXNSZWZsZXhpdmUgPyBvdGhlciA9PT0gdmFsdWUgOiBvdGhlciAhPT0gb3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAzXG4gICAqL1xuICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjAuMFxuICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogK3N0YXJ0O1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogK2VuZDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSA6IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMy4wXG4gICAqIEBjYXRlZ29yeSBTZXFcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciB1c2VycyA9IFtcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAqIF07XG4gICAqXG4gICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICogICAuY2hhaW4odXNlcnMpXG4gICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICogICB9KVxuICAgKiAgIC5oZWFkKClcbiAgICogICAudmFsdWUoKTtcbiAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICovXG4gIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBTZXFcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSlcbiAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICogIH0pXG4gICAqICAucmV2ZXJzZSgpXG4gICAqICAudmFsdWUoKTtcbiAgICogLy8gPT4gWzIsIDFdXG4gICAqL1xuICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQGNhdGVnb3J5IFNlcVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXygnICBhYmMgICcpXG4gICAqICAuY2hhaW4oKVxuICAgKiAgLnRyaW0oKVxuICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAqICB9KVxuICAgKiAgLnZhbHVlKCk7XG4gICAqIC8vID0+IFsnYWJjJ11cbiAgICovXG4gIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICpcbiAgICogQG5hbWUgY2hhaW5cbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBTZXFcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciB1c2VycyA9IFtcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICpcbiAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgKiBfKHVzZXJzKVxuICAgKiAgIC5jaGFpbigpXG4gICAqICAgLmhlYWQoKVxuICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICogICAudmFsdWUoKTtcbiAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICpcbiAgICogQG5hbWUgdmFsdWVcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICogQGNhdGVnb3J5IFNlcVxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIHZhciB1c2VycyA9IFtcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgIHByZWRpY2F0ZSA9IGd1YXJkID8gdW5kZWZpbmVkIDogcHJlZGljYXRlO1xuICAgIHJldHVybiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKiBAc2VlIF8ucmVqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciB1c2VycyA9IFtcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAqXG4gICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICpcbiAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgKlxuICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgdXNlcnMgPSBbXG4gICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAqIF07XG4gICAqXG4gICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICpcbiAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICpcbiAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICpcbiAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAqL1xuICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBhbGlhcyBlYWNoXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgKiB9KTtcbiAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAqXG4gICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgKiB9KTtcbiAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICpcbiAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgKiAgIHJldHVybiBuICogbjtcbiAgICogfVxuICAgKlxuICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAqIC8vID0+IFsxNiwgNjRdXG4gICAqXG4gICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICpcbiAgICogdmFyIHVzZXJzID0gW1xuICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgKiBdO1xuICAgKlxuICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGJhc2VNYXAoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgKlxuICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAqIGFuZCBgc29ydEJ5YFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAqIH0sIDApO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH0sIHt9KTtcbiAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHJldHVybiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSksIGFjY3VtdWxhdG9yLCBhcmd1bWVudHMubGVuZ3RoIDwgMywgYmFzZUVhY2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICogLy8gPT4gN1xuICAgKi9cbiAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiBuYXRpdmVLZXlzKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHZhciB1c2VycyA9IFtcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgKiBdO1xuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgcHJlZGljYXRlID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwcmVkaWNhdGU7XG4gICAgcmV0dXJuIGJhc2VTb21lKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHVzZXJzID0gW1xuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICogXTtcbiAgICpcbiAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAqXG4gICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUpO1xuXG4gICAgcmV0dXJuIGJhc2VNYXAoYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4geyAndmFsdWUnOiB2YWx1ZSwgJ2luZGV4JzogaW5kZXgrKywgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbikgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlQXNjZW5kaW5nKG9iamVjdC5jcml0ZXJpYSwgb3RoZXIuY3JpdGVyaWEpIHx8IChvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleCk7XG4gICAgfSksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjAuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICB9XG4gICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgKlxuICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgKiB9XG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAqXG4gICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICogYm91bmQoJyEnKTtcbiAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgKlxuICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAqIGJvdW5kKCdoaScpO1xuICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAqL1xuICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnRpYWwoZnVuYywgV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRywgdGhpc0FyZywgcGFydGlhbHMpO1xuICB9KTtcblxuICAvKipcbiAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAqL1xuICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICovXG4gIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuMC4wXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAqIH1cbiAgICpcbiAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAqL1xuICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAqIGluaXRpYWxpemUoKTtcbiAgICogaW5pdGlhbGl6ZSgpO1xuICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgKi9cbiAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAqXG4gICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gY29weUFycmF5KHZhbHVlKSA6IGNvcHlPYmplY3QodmFsdWUsIG5hdGl2ZUtleXModmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhXG4gICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICpcbiAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5lcSgnYScsICdhJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5lcShOYU4sIE5hTik7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICB2YXIgaXNEYXRlID0gYmFzZUlzRGF0ZTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICpcbiAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRW1wdHkoMSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkgfHxcbiAgICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAhbmF0aXZlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICogZXF1aXZhbGVudC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICpcbiAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNMZW5ndGgoMyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNOYU4oTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgKlxuICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc051bWJlcignMycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgdmFyIGlzUmVnRXhwID0gYmFzZUlzUmVnRXhwO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNTdHJpbmcoMSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgKlxuICAgKiBfLnRvQXJyYXkoMSk7XG4gICAqIC8vID0+IFtdXG4gICAqXG4gICAqIF8udG9BcnJheShudWxsKTtcbiAgICogLy8gPT4gW11cbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyBjb3B5QXJyYXkodmFsdWUpIDogW107XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICogLy8gPT4gMFxuICAgKlxuICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAqXG4gICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICogLy8gPT4gM1xuICAgKi9cbiAgdmFyIHRvSW50ZWdlciA9IE51bWJlcjtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAqIC8vID0+IDMuMlxuICAgKlxuICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiA1ZS0zMjRcbiAgICpcbiAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAqIC8vID0+IEluZmluaXR5XG4gICAqXG4gICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgKiAvLyA9PiAzLjJcbiAgICovXG4gIHZhciB0b051bWJlciA9IE51bWJlcjtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAqIC8vID0+ICcnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoLTApO1xuICAgKiAvLyA9PiAnLTAnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gJzEsMiwzJ1xuICAgKi9cbiAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEwLjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgKiAgIHRoaXMuYSA9IDE7XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgKiAgIHRoaXMuYyA9IDM7XG4gICAqIH1cbiAgICpcbiAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICpcbiAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgKi9cbiAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgY29weU9iamVjdChzb3VyY2UsIG5hdGl2ZUtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGFsaWFzIGV4dGVuZFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBzZWUgXy5hc3NpZ25cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgKiAgIHRoaXMuYSA9IDE7XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgKiAgIHRoaXMuYyA9IDM7XG4gICAqIH1cbiAgICpcbiAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICpcbiAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgKi9cbiAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICBjb3B5T2JqZWN0KHNvdXJjZSwgbmF0aXZlS2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMi4zLjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICogICB0aGlzLnggPSAwO1xuICAgKiAgIHRoaXMueSA9IDA7XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAqIH1cbiAgICpcbiAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAqL1xuICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgKlxuICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAqICAgdGhpcy5hID0gMTtcbiAgICogICB0aGlzLmIgPSAyO1xuICAgKiB9XG4gICAqXG4gICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAqXG4gICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKlxuICAgKiBfLmtleXMoJ2hpJyk7XG4gICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICovXG4gIHZhciBrZXlzID0gbmF0aXZlS2V5cztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuMC4wXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAqICAgdGhpcy5hID0gMTtcbiAgICogICB0aGlzLmIgPSAyO1xuICAgKiB9XG4gICAqXG4gICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAqXG4gICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICovXG4gIHZhciBrZXlzSW4gPSBuYXRpdmVLZXlzSW47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICpcbiAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgKi9cbiAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICpcbiAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAqIC8vID0+IDRcbiAgICpcbiAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAqXG4gICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAqIC8vID0+ICdkZWZhdWx0J1xuICAgKi9cbiAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbcGF0aF07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAqICAgdGhpcy5hID0gMTtcbiAgICogICB0aGlzLmIgPSAyO1xuICAgKiB9XG4gICAqXG4gICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAqXG4gICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICpcbiAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICovXG4gIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAqXG4gICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAqIFhTUyB2ZWN0b3JzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgIDogc3RyaW5nO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgdXNlcnMgPSBbXG4gICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAqXG4gICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAqXG4gICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAqXG4gICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqXG4gICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICogLy8gPT4gWydkZWYnXVxuICAgKi9cbiAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqXG4gICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjAuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICovXG4gIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgcmV0dXJuIGJhc2VNYXRjaGVzKGFzc2lnbih7fSwgc291cmNlKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgKiAgIH0pO1xuICAgKiB9XG4gICAqXG4gICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgKiAvLyA9PiBbJ2UnXVxuICAgKlxuICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICogLy8gPT4gWydlJ11cbiAgICpcbiAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgKiAvLyA9PiBbJ2UnXVxuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgIGJhc2VFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAqL1xuICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDIuMy4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgKlxuICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAqIC8vID0+ICcxMDUnXG4gICAqL1xuICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBNYXRoXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgKiAvLyA9PiA4XG4gICAqXG4gICAqIF8ubWF4KFtdKTtcbiAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAqL1xuICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiBfLm1pbihbXSk7XG4gICAqIC8vID0+IHVuZGVmaW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICBsb2Rhc2gucGljayA9IHBpY2s7XG4gIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICBsb2Rhc2gudGFwID0gdGFwO1xuICBsb2Rhc2gudGhydSA9IHRocnU7XG4gIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcblxuICAvLyBBZGQgYWxpYXNlcy5cbiAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgbG9kYXNoLmhhcyA9IGhhcztcbiAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICBsb2Rhc2gubWF4ID0gbWF4O1xuICBsb2Rhc2gubWluID0gbWluO1xuICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgbG9kYXNoLnNpemUgPSBzaXplO1xuICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gIC8vIEFkZCBhbGlhc2VzLlxuICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gIGJhc2VFYWNoKFsncG9wJywgJ2pvaW4nLCAncmVwbGFjZScsICdyZXZlcnNlJywgJ3NwbGl0JywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZ1bmMgPSAoL14oPzpyZXBsYWNlfHNwbGl0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyBTdHJpbmcucHJvdG90eXBlIDogYXJyYXlQcm90bylbbWV0aG9kTmFtZV0sXG4gICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxqb2lufHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IGxvZGFzaDtcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2Rhc2g7XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IGxvZGFzaCkuXyA9IGxvZGFzaDtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IGxvZGFzaDtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gbG9kYXNoO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGdyYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZmNub2RlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImd1aWQtdHlwZXNjcmlwdFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5ldFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZXF1ZXN0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwid3NcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==